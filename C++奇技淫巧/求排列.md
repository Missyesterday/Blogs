# C++求排列

`next_permutation(first, last)`函数会以**字典序**取得`[first, last)`所标示序列的下一个排列组合。

它还有个相似功能的函数`prev_permutation(first, last)`用来求当前排列的上一个排列。

需要引入头文件：

```cpp
#include <algorithm>
```

当「当前序列」不存在下一个排列时，函数返回`false`，否则返回`true`。

**需要注意的是：**

-   一个序列按**字典序**排序就可以得到「第一个排列」
-   所以这个函数经常和`sort()`一起使用



>   例如《剑指Offer》的38题就是典型的求排列，用`sort()`+`next_permutation()`秒解。

```cpp
vector<string> permutation(string s)
{
    sort(s.begin(),  s.end());
    vector<string> res;
    do
    {
        res.emplace_back(s);
    }while(next_permutation(s.begin(),  s.end()));
    return res;
}
```

