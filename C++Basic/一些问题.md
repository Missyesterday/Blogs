# 一些问题

>   这里记录了一些在看书和写代码的时候想到的问题，在此记录。

## 1. 同步IO和异步IO的区别

同步I/O和异步I/O是I/O操作的两种基本模式，它们的区别在于I/O操作是否需要等待。

1.  同步I/O模式

在同步I/O模式下，进程会直接等待I/O操作的完成，直到读取或写入操作完成后，才会继续执行后续的操作。在这个等待期间，进程会一直阻塞，无法做其他的事情。同步I/O的优点是简单直观，易于控制，缺点是效率较低，因为等待期间无法做其他的操作，造成了CPU的浪费。

1.  异步I/O模式

在异步I/O模式下，进程会发起I/O操作后，立即返回，并继续执行后续的操作，而不会等待I/O操作的完成。当I/O操作完成时，操作系统会通知进程，并返回I/O操作的结果。在这种模式下，I/O操作的等待和执行是由操作系统来完成的，进程可以继续执行其他的任务。异步I/O的优点是效率高，能够充分利用CPU资源，缺点是编程复杂度相对较高，因为需要使用回调函数等机制来处理I/O完成后的结果。

需要注意的是，同步和异步I/O的区别是针对进程的操作而言，与底层实现无关。底层实现可能会使用阻塞、非阻塞、多线程、事件通知等不同的技术来实现同步和异步I/O。



## 2. 阻塞和非阻塞的区别

阻塞和非阻塞是指程序在等待某个操作完成时的不同处理方式。

在阻塞模式下，当程序执行某个操作时，如果该操作不能立即完成，程序将停止执行，直到该操作完成。在这种情况下，程序会一直等待直到该操作完成，并且在此期间无法执行任何其他操作。阻塞模式通常用于同步编程模型，其中每个操作都必须等待前一个操作完成后才能进行下一个操作。

在非阻塞模式下，当程序执行某个操作时，如果该操作不能立即完成，程序将继续执行并立即返回，以便可以执行其他操作。在这种情况下，程序不会等待该操作完成，而是会继续执行，并且可以通过后续的轮询来查询该操作是否已经完成。非阻塞模式通常用于异步编程模型，其中程序可以同时执行多个操作，并且在等待某个操作完成时，可以继续执行其他操作。

需要注意的是，阻塞和非阻塞是相对于当前线程而言的，一个线程可以以阻塞的方式等待某个操作完成，同时也可以以非阻塞的方式执行其他操作。



## 3.  IO多路复用（select、poll、epoll）是同步还是异步的？

IO多路复用（如select、poll、epoll等）属于同步IO模型。

在同步IO中，当用户程序发起一个IO请求时，程序会阻塞等待直到IO操作完成并返回结果。而在IO多路复用中，程序通过一个函数（如select、poll、epoll）将多个IO操作一起发起并等待，一旦其中任何一个IO操作完成，函数就会返回并通知程序哪个IO操作已经完成。

虽然IO多路复用的工作方式看起来类似于异步IO模型，但实际上它是同步IO模型的一种扩展，因为程序仍然需要在IO操作完成后再继续进行后续处理。与异步IO模型不同，异步IO模型中IO操作完成后会通过回调函数通知程序结果，程序无需等待IO操作完成。



## 4. 水平触发和边缘触发的区别

水平触发（Level Triggered）和边缘触发（Edge Triggered）是 epoll I/O 多路复用机制中的两种不同触发方式。

在水平触发模式下，当一个文件描述符上有数据到达时，epoll_wait 函数会立即返回，应用程序可以通过读取该文件描述符来处理到达的数据。如果数据没有被处理完全，epoll_wait 函数会一直返回该文件描述符上的事件，直到数据被处理完毕。

而在边缘触发模式下，当一个文件描述符上有数据到达时，epoll_wait 函数只会返回一次该文件描述符上的事件，并且仅在文件描述符上有新的事件到达时才会返回。因此，在边缘触发模式下，应用程序需要尽可能快地读取所有到达的数据，否则可能会丢失一些数据。

边缘触发模式相对于水平触发模式更加高效，因为它可以减少 epoll_wait 函数的调用次数，从而降低系统调用的开销。但是，边缘触发模式对应用程序的编写要求也更高，需要确保能够及时读取到所有到达的数据。

总的来说，水平触发模式是 epoll I/O 多路复用的默认模式，可以用于处理大部分的 I/O 事件。而边缘触发模式可以提高处理效率，但需要开发人员更加小心谨慎地编写代码，以避免出现数据丢失等问题。



## 5. 什么是布隆过滤器

布隆过滤器（Bloom filter）是一种基于哈希的快速、空间效率高的随机数据结构，用于判断某个元素是否属于一个集合。它可以用来判断某个元素是否在集合中，但是不能保证一定存在或一定不存在，因为可能存在哈希冲突。

布隆过滤器由布隆于1970年提出，它的原理比较简单，即将每个元素通过多个哈希函数映射到一个位数组中，一个元素映射到的位可以是多个。当判断某个元素是否在集合中时，将该元素通过相同的哈希函数映射到位数组中，如果这些位都被标记了，那么该元素可能在集合中；如果其中任何一位未被标记，则该元素一定不在集合中。

布隆过滤器的优点是空间占用少，时间复杂度低，且可以容忍一定的误判率。它可以用于缓存系统、网络爬虫、数据去重、数据压缩等领域。

需要注意的是，布隆过滤器存在一定的误判率，这是由哈希冲突引起的。为了降低误判率，可以增加位数组的大小、增加哈希函数的个数、增加元素的特征值等。同时，由于布隆过滤器无法删除元素，因此需要结合其他算法进行使用。



## 6. C++模版的缺点？

C++ 模板的主要缺点包括：

1.  编译时间长：由于 C++ 模板的实现依赖于编译器，在模板的使用过程中，编译器需要对模板进行实例化，生成相应的代码，这会增加编译时间。
2.  难以调试：由于模板的实现是在编译期完成的，所以当模板出现问题时，错误信息通常不太直观，调试起来比较困难。
3.  代码可读性差：使用模板的代码通常比较复杂，且使用了很多元编程技巧，这会导致代码的可读性降低。
4.  空间开销大：由于 C++ 模板的实现需要生成多个实例化代码，而每个实例化都需要占用内存空间，这会增加程序的内存使用量。
5.  容易出现代码膨胀：由于 C++ 模板是在编译期进行实例化的，所以当模板被多次使用时，会生成大量的重复代码，这会导致代码膨胀，增加可执行文件的大小。

需要注意的是，尽管 C++ 模板存在一些缺点，但是它也是 C++ 语言的一个重要特性，能够提高程序的灵活性和重用性。在实际开发中，应该根据具体情况进行选择，权衡使用模板带来的收益和成本。



## 7. C++的static怎么使用

在 C++ 中，static 关键字可以用于以下几种场合：

1.  在函数内部使用 static 关键字修饰一个变量，则该变量成为静态局部变量。静态局部变量与普通局部变量的不同在于，静态局部变量只会被初始化一次，而且只有在第一次调用函数时才会初始化，之后再调用函数时不会重新初始化。静态局部变量的作用域只限于该函数内部，但它的生命周期与程序的生命周期相同。
2.  在类内部使用 static 关键字修饰一个变量，则该变量成为静态成员变量，它属于整个类而不是某个对象。静态成员变量只有一份拷贝，所有对象共享这份拷贝。静态成员变量可以通过类名和作用域解析运算符来访问，例如 MyClass::static_var。
3.  在类内部使用 static 关键字修饰一个函数，则该函数成为静态成员函数。静态成员函数与普通成员函数的不同在于，静态成员函数不属于任何对象，因此它不能访问非静态成员变量和非静态成员函数。静态成员函数可以通过类名和作用域解析运算符来调用，例如 MyClass::static_func()。
4.  在文件作用域或命名空间作用域中使用 static 关键字修饰一个变量或函数，则该变量或函数成为静态全局变量或静态全局函数，它们只能在定义它们的文件中访问，其他文件无法访问。

需要注意的是，static 关键字在不同的上下文中具有不同的含义和作用，因此需要根据具体的情况来理解和使用它。





## 8. new和malloc有什么区别

`new` 和 `malloc` 都可以用来动态分配内存空间，但是它们有几个不同点：

1.  语法不同：`new` 是 C++ 中的一个操作符，而 `malloc` 是 C 语言中的一个函数。
2.  类型安全：`new` 在分配内存时会根据对象的类型确定所需的内存空间大小，从而避免了手动计算所需的字节数可能出现的错误，这使得 `new` 更加类型安全。而 `malloc` 分配的内存空间大小必须手动指定。
3.  构造函数调用：使用 `new` 分配对象时，会自动调用该对象的构造函数；而使用 `malloc` 分配内存空间时，必须手动调用构造函数。
4.  返回值类型：`new` 返回的是一个指向对象的指针，而 `malloc` 返回的是一个指向 `void` 的指针。需要将 `malloc` 返回的指针强制转换成需要的类型。

在 C++ 中，推荐使用 `new` 来分配内存空间，因为它更加类型安全，并且可以自动调用对象的构造函数。当需要在 C++ 中使用 C 库函数时，可以使用 `malloc` 分配内存空间。



## 9. 什么是C++11的完美转发

C++11中的完美转发（perfect forwarding）是指一种技术，可以将一个函数的参数原封不动地转发给另一个函数，同时保留参数的值和类型。在使用完美转发时，被调用的函数接收的参数类型和值应该和调用函数接收的参数类型和值一致。

完美转发的实现依赖于两个新特性：引用折叠（reference collapsing）和可变参数模板（variadic templates）。

引用折叠是C++11中的一个特性，它允许在一定程度上简化模板代码中的引用类型。可变参数模板则允许定义一个参数数量不固定的函数模板，使得在调用该函数时可以接受任意数量的参数。

通过结合引用折叠和可变参数模板，可以实现完美转发。具体来说，可以在函数模板中使用引用类型的参数，并使用“&&”符号表示右值引用。这样可以将调用函数中的参数原封不动地转发给被调用函数，同时保留参数的值和类型。在实现中，可以使用std::forward模板函数来实现完美转发，该函数会根据参数的类型来判断是使用左值引用还是右值引用进行转发。



## 10. 虚函数的作用

虚函数是 C++ 中的一个重要特性，它具有以下作用：

1.  实现多态：通过定义虚函数，可以在子类中覆盖父类中的同名函数，从而实现多态，让不同的子类对象调用同一个虚函数时表现出不同的行为。
2.  支持动态绑定：在运行时根据对象的实际类型决定调用哪个版本的虚函数，从而实现动态绑定。这使得程序更加灵活，可以根据实际情况来决定调用哪个函数。
3.  使得继承层次结构更加灵活：通过将基类中的函数定义为虚函数，可以让子类在不改变基类接口的情况下扩展和修改基类的行为。

需要注意的是，虚函数的使用需要在类的声明中将其定义为虚函数，而非普通函数。同时，虚函数需要通过指针或引用来调用，而不能直接调用。



## 11. new和delete的实现

在C++中，new和delete是用来分配和释放动态内存的操作符。它们的实现通常是由编译器提供的标准库函数来完成的，这些函数的具体实现方式可能会因编译器而异。

new的实现：

1.  首先，new会调用operator new函数来分配一块足够大的内存空间。
2.  然后，new会调用类的构造函数来初始化这块内存，如果是基本数据类型则不需要构造函数。
3.  最后，new会返回指向该内存块的指针。

delete的实现：

1.  首先，delete会调用类的析构函数来销毁这个对象，如果是基本数据类型则不需要析构函数。
2.  然后，delete会调用operator delete函数来释放这块内存空间。

在这里，需要注意的是，operator new和operator delete是C++中预定义的全局函数，它们可以被重载，以便于实现自定义的内存分配策略。另外，new和delete操作符还支持数组形式，分别对应于new[]和delete[]操作符，它们可以用来分配和释放数组类型的动态内存。



## 12. 虚函数的实现原理？

虚函数的实现原理是通过虚函数表（Vtable）来实现的，这是C++用于支持多态性的一种机制。虚函数表是一个指向虚函数地址的指针数组，它是针对每个含有虚函数的类在内存中的一个固定位置。

当一个类中包含虚函数时，编译器会自动生成一个虚函数表，其中存放着该类中的虚函数的地址。当这个类被实例化为对象时，对象会在其内存空间中存储一个指向虚函数表的指针，这个指针通常被称为虚指针（Vpointer）。

当对象调用虚函数时，编译器会通过虚指针找到对应的虚函数表，并从中取出相应的虚函数地址，然后跳转到这个地址处执行对应的虚函数。由于虚函数表是由编译器生成的静态数据结构，因此虚函数的调用速度比普通函数稍慢。

在派生类中覆盖虚函数时，编译器会将派生类中的函数地址存储到虚函数表中相应虚函数的位置上，这样派生类的对象调用虚函数时就会调用覆盖后的函数。

总之，虚函数表的实现原理就是让每个对象在运行时能够根据其实际类型来选择调用正确的虚函数，从而实现多态性。



## 13. 如何实现编译器处理虚函数表

实现编译器处理虚函数表通常需要以下几个步骤：

1.  编译器为每个含有虚函数的类生成一个虚函数表，该表是一个数组，其中每个元素存储一个指向虚函数的指针。
2.  编译器在类的对象中添加一个虚指针，用于指向该对象对应的虚函数表。
3.  对于派生类，编译器需要在其虚函数表中添加自己的虚函数指针，以便覆盖基类的虚函数。如果派生类中定义了新的虚函数，编译器会将其添加到虚函数表中。
4.  在编译时，编译器会将虚函数表中的指针替换成实际的函数地址。由于虚函数表是静态的，因此这个过程只需要进行一次。
5.  在运行时，当一个对象调用虚函数时，程序会先根据该对象的虚指针找到其对应的虚函数表，然后从表中取出相应的虚函数指针，跳转到函数地址并执行函数。

需要注意的是，不同编译器对虚函数表的实现方式可能有所不同，但基本思路和步骤是相似的。同时，虚函数表的实现也是C++支持多态的关键机制之一，它使得对象能够在运行时根据实际类型来调用正确的虚函数，从而实现多态性。



## 14. 在类中，基类的析构函数为什么要设置成虚函数

在 C++ 中，将基类的析构函数设置为虚函数是为了支持多态和动态绑定，这也是 C++ 的面向对象编程中的一个重要特性。

假设有一个基类 `Animal` 和一个派生类 `Dog`，如果我们使用指向派生类的基类指针来调用析构函数，且该析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数，从而导致派生类对象没有被正确地销毁，造成资源泄露。

为了解决这个问题，C++中使用虚析构函数来支持多态和动态绑定，即如果基类的析构函数设置为虚函数，当使用基类指针删除一个派生类对象时，会首先调用派生类的析构函数，然后再调用基类的析构函数，这样就能确保派生类对象被正确地销毁，释放掉它所占用的资源。

因此，在 C++ 中，如果一个类是作为基类使用的，那么通常需要将其析构函数设置为虚函数，以确保在使用基类指针删除派生类对象时能够正确地调用派生类的析构函数。



## 15. new和operator new的区别

在 C++ 中，`new` 是一个运算符，用于在堆上动态分配内存并返回指向该内存的指针。而 `operator new` 是一个函数，用于在堆上动态分配内存并返回指向该内存的指针。

虽然它们的目的都是在堆上动态分配内存，但它们的作用范围不同。`new` 运算符是 C++ 中的关键字，可以直接使用，而 `operator new` 是一个标准库函数，需要通过 `#include <new>` 来引入头文件，然后使用 `operator new` 函数进行内存分配。

此外，`new` 运算符会在分配内存后自动调用类的构造函数，从而创建一个对象；而 `operator new` 只是分配内存，并不会调用类的构造函数，需要通过显式调用构造函数来创建对象。

另外，对于数组类型，使用 `new` 运算符可以轻松地分配一维或多维数组，而使用 `operator new` 则需要手动计算元素的大小和数量，并且在返回指针之前还需要调用 `placement new` 来进行对象的构造。

总之，`new` 运算符和 `operator new` 函数的主要区别在于它们的使用方式和功能。`new` 运算符通常比 `operator new` 更方便，因为它自动管理对象的构造和析构，但在一些特殊情况下，`operator new` 也是必需的，例如在需要进行对象池分配时。



## 16. 左值和右值

在 C++ 中，表达式可以分为左值和右值两种类型。

左值指的是具有内存地址的表达式，即表达式返回一个在内存中有实际位置的对象，比如变量、数组、函数返回的左值引用等。左值可以出现在赋值语句的左边，可以进行取地址、前置/后置递增/递减等操作。

右值指的是没有内存地址的表达式，即表达式返回的是一个值而不是一个对象，比如字面值、临时对象、返回右值引用的函数调用等。右值不能出现在赋值语句的左边，不能进行取地址、前置递增/递减等操作。

从语义上讲，左值表示可以被修改的数据，右值表示只能被访问的数据。在 C++11 中，右值引入了移动语义，使得右值可以被移动而不是被复制，这一特性可以在一些情况下提高程序的性能。

需要注意的是，在某些情况下，一个表达式既可以是左值也可以是右值，这就需要根据具体的上下文来判断它是左值还是右值。例如，数组名可以作为左值也可以作为右值，取决于它出现的上下文。另外，在 C++11 中，引入了右值引用类型和完美转发，使得左值可以被转换为右值，这样可以更方便地利用移动语义和提高程序性能。



## 17. 如何突破最大端口号的限制

在TCP/IP协议中，端口号是一个16位的无符号整数，因此最大端口号为2^16-1，即65535。

如果需要超过这个限制，可以采用以下几种方法：

1.  通过多个IP地址来扩展端口号范围。可以使用多个网络接口，并为每个接口分配一个不同的IP地址，从而扩展端口号范围。
2.  采用负载均衡技术来扩展端口号范围。可以使用负载均衡设备将请求分发到多台服务器上，从而扩展端口号范围。
3.  使用虚拟IP地址来扩展端口号范围。可以为服务器分配一个虚拟IP地址，并在多个物理接口上使用这个IP地址，从而扩展端口号范围。

需要注意的是，扩展端口号范围可能会导致一些安全问题，例如恶意攻击者可以利用开放的端口进行攻击。因此，应该根据实际情况进行合理的端口号规划，并采取相应的安全措施来保护网络安全。



## 18. C++的调用惯例是什么？cdecl和stdcall的区别

C++的默认调用惯例是 "cdecl"（C declaration），它是一种函数调用的规则，指定了函数参数的传递方式和堆栈的处理方式。在 cdecl 中，调用方负责清理堆栈上的参数。这种调用惯例适用于大多数函数，包括函数指针、回调函数和递归函数。

另一种调用惯例是 "stdcall"（standard call），也称为 "Pascal" 调用惯例。在 stdcall 中，被调用函数负责清理堆栈上的参数。这种调用惯例通常用于 Windows API 中的函数，以确保不同编译器和语言之间的兼容性。

区别：主要是在函数参数传递和堆栈处理方式上。在 cdecl 中，函数参数是由调用方在调用时将它们压入堆栈上的，而在 stdcall 中，函数参数是由被调用函数自己负责从堆栈中取出的。因此，在使用不同调用惯例的函数之间进行调用时，必须遵循正确的参数传递和堆栈处理方式，否则会导致程序出错或崩溃。



## 19. 输入URL，浏览器做了什么？

当用户在浏览器的地址栏中输入一个网站的 URL 时，浏览器会按照以下步骤来获取和显示网站的内容：

1.  域名解析：浏览器首先需要将输入的域名解析成 IP 地址，以便向服务器发送请求。浏览器会检查本地 DNS 缓存以获取解析后的 IP 地址，如果缓存中没有，浏览器会向本地 DNS 服务器发送请求，如果本地 DNS 服务器也没有缓存该域名，则会向根域名服务器发起查询。
2.  发起连接：一旦浏览器获得了服务器的 IP 地址，它会使用 HTTP 协议向服务器发起一个 TCP 连接请求。
3.  发送请求：一旦建立了 TCP 连接，浏览器会向服务器发送一个 HTTP 请求，该请求包括用户想要访问的资源的类型和位置。
4.  接收响应：服务器会根据浏览器的请求，返回相应的内容，这个内容包括 HTML 文件，CSS 文件，JavaScript 文件，图片等等。
5.  解析内容：浏览器接收到服务器响应后，会根据响应头中的内容类型，判断要如何解析响应内容。如果是 HTML 文件，则浏览器会解析文件，并使用 DOM (文档对象模型) 来构建网页的结构。
6.  显示网页：一旦浏览器解析完 HTML 文件并构建了页面结构，它会开始解析 CSS 文件和 JavaScript 文件，并将它们应用到页面上，最终呈现出一个完整的网页。
7.  断开连接：当浏览器获取到了所有的资源并将它们显示在页面上之后，它会断开与服务器的连接。



## 20. 服务器线程池的大小

服务器的线程池大小需要根据服务器的实际情况来确定，一般来说，线程池大小的设置需要考虑以下几个方面：

1.  系统资源：线程池大小不能超过系统资源的承受能力，包括 CPU、内存等，否则会导致系统性能下降。
2.  并发请求数：线程池大小应该能够满足并发请求的处理，即能够同时处理多少个请求，通常可以通过压力测试来确定。
3.  任务类型：不同类型的任务需要的线程资源也不同，例如 CPU 密集型任务需要更多的 CPU 资源，而 I/O 密集型任务则需要更多的 I/O 资源。
4.  应用架构：不同的应用架构需要的线程资源也不同，例如单机应用可能只需要设置较小的线程池，而分布式应用可能需要设置更大的线程池。

综上所述，线程池大小需要根据具体情况来确定，一般来说，可以先根据系统资源和并发请求数来设置一个较小的线程池，然后通过不断的测试和优化来逐渐调整线程池大小，以达到最优的性能





## 21. 什么是监听端口

监听端口是指在计算机网络中，程序或进程通过指定一个特定的端口号，使其可以接收网络连接请求并处理连接请求的能力。当一个程序或进程开始监听一个特定的端口，**它会持续等待来自网络上的连接请求，一旦有连接请求到来，该程序或进程就会接收该连接请求并进行相应的处理。**

在网络中，每个应用程序通常都有一个特定的端口号，例如Web服务器通常使用80端口，SMTP服务器使用25端口，FTP服务器使用21端口等。通过监听这些端口，应用程序可以接收来自网络上的请求并对其进行响应，从而提供相应的服务。监听端口是网络编程中非常重要的一个概念，它是实现网络通信的基础之一。



## 22. 对于文件夹，drx权限分别指什么？

-   读：可以查看文件夹中的子文件夹和文件
-   写：可以创建、删除和重命名文件和子文件夹
-   执行：可以进入文件夹，可执行权限的意义是能否访问该文件夹的内容，而不是指该文件夹本身是否可执行。



## 23. 使用epoll的LT模式，当socket可写的时候，会不停触发socket可写的事件，直到该socket发送缓冲区被写满为止，如何处理？

### 方法一：

也是比较普遍的方法：需要向socket写数据的时候才把socket加入epoll（调用epoll_ctl），等待可写事件。接受到可写事件后，调用`write()`/`send()`发送数据。当所有的数据都写完后，把socket移出epoll。这样即使发送很小的数据，也要把socket加入epoll，写完再移除epoll，有一定操作代价。



### 改进的处理：

开始不把socket加入epoll，需要向socket写数据的时候，直接调用`write()`或`send()`发送数据。如果返回`EAGAIN`，把socket加入epoll，在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll。

这样，在数据不多的情况下，可以避免epoll的事件处理，提高效率。



## 24. 读写锁和条件变量的区别

读写锁是一种提供对共享资源读写的并发控制机制，允许多个线程同时读取共享资源，但是在有写操作的时候，必须独占访问，即写锁必须互斥，写锁被占用时不能再有任何读锁或写锁。读写锁的主要作用是在高并发读的场景下，提升并发度，以提高性能。读写锁适用于读操作远远多于写操作的情况。

条件变量是一种同步机制，主要用于线程间的通信，当线程需要等待某些条件满足时，就可以通过条件变量将自己挂起，等待条件满足后再被唤醒。条件变量可以与互斥锁结合使用，线程在访问共享资源之前获取互斥锁，如果发现条件不满足就等待条件变量，条件满足后再释放互斥锁。条件变量适用于需要等待某些事件发生后再执行的场景。

因此，读写锁和条件变量主要的区别在于：

1.  作用不同：读写锁用于控制对共享资源的读写访问，而条件变量用于线程间的通信，等待某些条件满足后再执行。
2.  使用场景不同：读写锁适用于读操作远远多于写操作的场景，而条件变量适用于需要等待某些事件发生后再执行的场景。
3.  粒度不同：读写锁的粒度比条件变量粗，读写锁控制对整个共享资源的访问，而条件变量可以只控制某个线程的访问。



互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。
