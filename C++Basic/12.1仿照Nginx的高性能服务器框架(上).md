# 仿照Nginx的高性能服务器框架(上)

>   提炼有用的代码，放入自己的知识库。



## 1. nginx简介、选择理由、安装和使用

### 1.1nginx简介

nginx是一个web服务器，性能相当优秀，市场份额排在第二位，仅次于出现的最早的Apache。

它可以作为Web服务器，反向代理，负载均衡，邮件代理，所以经常被称为轻量级服务器。纯C语言编写的，并且开源。

nginx号称并发处理百万级别的TCP连接，非常稳定，支持热部署（运行时能升级），高度模块化设计，可以开发自己的模块来增强nginx。第三方业务模块可以用C++开发。

不同平台下nginx可能代码不同，Linux有epool技术，windows使用IOCP。





### 1.2 选择理由

-   单机10万并发，并且同时能够保持高效的服务，nginx充分挖掘了linux的性能，使用epoll技术，高并发只是占用更多内存就能做到。
-   使用了：内存池、进程池、线程池、事件驱动等。
-   学习这种大师级别的代码



### 1.3 安装nginx，搭建web服务器

#### 1.3.1 **安装前提**

-   epoll 内核版本为2.6或者以上
-   gcc编译器、g++编译器
-   pcre库：函数库，支持解析正则表达式
-   zlib库：压缩解压缩功能



#### 1.3.2 **nginx源码下载和目录结构**

nginx官网：[http://www.nginx.org](http://www.nginx.org)



nginx的几个版本：

-   mainline版本：版本号中间数字一般为奇数。更新快，一个月内就会发布一个新版本，有最新功能，bug修复等，稳定性差一点
-   stable版本：稳定版本，版本号中间数字一般为偶数版本，经过了长时间的测试，比较稳定，这种版本发布周期长
-   Legacy版本：遗留版本，以往发布的稳定版或者mainline版本



安装方式：

-   可以通过命令行直接安装二进制版本，但是不灵活，不好添加第三方模块
-   通过编译nginx版本可以把第三方模块加载进来

下载路径：[https://nginx.org/download/nginx-1.14.2.tar.gz](https://nginx.org/download/nginx-1.14.2.tar.gz)



源码树形结构图：

```
.
├── auto
├── CHANGES
├── CHANGES.ru
├── conf
├── configure
├── contrib
├── html
├── LICENSE
├── man
├── README
└── src
```

-   `auto/`：编译相关的脚本，可以执行文件configure会用到这些脚本
    -   `cc/`：检查编译器的脚本
    
    -   `lib/`：检查依赖类型的脚本
    
    -   `os/`：检查操作系统类型的脚本
    
    -   `type/`：检查平台类型的脚本
    
-   `CHANGES`：这个版本修复的bug，新增的功能
-   `CHANGES.ru`：俄语版CHANGES
-   `conf/`：默认的配置文件
-   `configure`：编译nginx前必须编译此脚本，生成一些必要的中间文件
-   `contrib/`：脚本和工具，例如vim高亮工具
-   `html/`：两个缺省的html页面，一个index.html,一个错误的50x.html
-   `LICENSE`：协议
-   `man/`：帮助文档
-   `objs/`：执行了configure生成的中间文件目录
    -   `ngx_modules.c`中的内容决定了我们编译nginx的时候会有哪些模块呗编译到nginx中来
-   `Makefile`：编译规则文件，执行`make`命令时用到
-   `src/`：nginx源代码目录
    -   `core/`：核心代码
    -   `event/`：事件模块代码
    -   `http/`：http（web服务）模块相关代码
    -   `mail`：邮件模块相关代码
    -   `os`：系统相关代码
    -   `stream`：流处理相关代码


#### 1.3.3 nginx编译和安装

1.   执行`configure`来进行编译之前的配置工作，生成一个`objs`目录

     使用`./configure --help`查看参数：

     -   `--prefix`：指定最终安装的目录，默认值`/usr/local/nginx`，是下面所有路径的根目录
     -   `--sbin-path`：指定可执行文件目录，默认是`sbin/nginx`
     -   `--conf-path`：用来指定配置文件了目录，默认是`conf/nginx.d`
     -   `-with-xxx`：xxx模块默认不会加载到nginx中，需要加上这个参数才加载到nginx
     -   `-without-xxx`：xxx模块默认会加载到nginx中，加上这个参数则不会加载到nginx

2.   `make`编译，在`objs/`下生成nginx可执行文件

3.   `make install`安装，把可执行文件和配置文件拷贝到指定目录下，也就是`/usr/local/nginx`



#### 1.3.4 nginx的启动和简单使用

进入`/usr/local/nginx/sbin`，`sudo ./nginx`，默认监听的是80端口。

使用`ps -ef | grep nginx`：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227143614535.png" alt="image-20230227143614535" style="zoom:50%;" />

-   `worker process`：把html的内容发送到客户端
-   `master process`：可能就是监听80端口的进程



## 2. nginx整体结构、进程模型

### 2.1 nginx整体结构

#### 2.1.1 master进程和worker进程

使用`ps -ef | grep nginx`：

1.   第一列代表进程所属用户：

     启动后nginx有一个master进程和一个worker进程，worker进程属于`nobody`用户，权限很低，防止被入侵。master进程属于`root`用户。

2.    第二列是pid，

3.    第三列是ppid（父进程id）：

      worker进程是master进程用`fork()`函数创建出来的。


#### 2.1.2 nginx进程模型

一个master进程，一到多个worker进程，这种工作机制来对外服务的，这种工作机制保证了nginx**稳定、灵活**地运行。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227145702098.png" alt="image-20230227145702098" style="zoom:40%;" />

master进程：

-   负责监控，不处理具体业务，专门用来管理和监控worker进程，角色是监工，比较清闲

worker进程：

-   用来处理业务

master和worker之间的通信：

-   信号
-   共享内存

稳定性体现之一：

-   master进程能发现worker进程挂了，能迅速`fork()`出一个新的worker进程，worker进程的数量由配置文件指定。



#### 2.1.3 调整worker进程数量

worker进程几个合适呢？

公认做法：多核计算机，就让每个worker运行在一个单独的内核上，最大限度地减少CPU进程切换的成本，提高系统效率。

>   查看CPU是几核的：
>
>   M1是8核。也就是8个processor，而不是8个CPU。
>
>   `grep -c processor /proc/cpuinfo`

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227153046069.png" alt="image-20230227153046069" style="zoom:50%;" />

例如上图某个工作站，有两个CPU，每个CPU有4个core，每个core还能有虚拟出两个逻辑处理器（超线程技术/sigbling），每个逻辑处理器就是一个processor（最细小的单位，也就是处理器的个数）。



在`/usr/local/nginx/conf/nginx.conf`文件中修改`worker_processes  2;`，再次启动nginx，发现存在两个worker 进程。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227154611304.png" alt="image-20230227154611304" style="zoom:40%;" />

### 2.2 进一步了解nginx进程模型

一个master进程多个worker进程的进程模型优点：「稳定+灵活」。

#### 2.2.1 nginx重载配置文件

nginx可以在不重启的情况下对服务器进行升级，客户端没有感知。

-   修改`/usr/local/nginx/conf/nginx.conf`文件
-   `./nginx -s reload`
    -   `-s`代表发送一个信号:`send signal to a master process: stop, quit, reopen, reload`

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227155405103.png" alt="image-20230227155405103" style="zoom:40%;" />

可以看到worker进程的pid被修改了，但是master进程没有变化。

#### 2.2.2 nginx热升级

如果要更新nginx服务器，不想中止原来的服务，这种技术叫「热升级」，nginx甚至还可以降版本，（热回滚）。需要master和worker的通信。

#### 2.2.3 nginx的关闭

可以直接`kill`掉master进程。

也可以：
- `./nginx -s stop`：暴力退出
- ``./nginx -s quit`：不接受新连接退出。

#### 2.2.4 总结

为什么不用多线程模型？多线程模型的弊端：

多线程是共享内存的，如果某个线程报错，一定会影响其他线程，导致整个服务器程序崩溃。



## 3. 学习之前需要掌握

### 3.1 准备过程

源码在`src/`目录下，使用VSCode查看源码。

**nginx源码入口函数：**

`src/core/nginx.c`



创建一个自己的linux下的c语言程序：`/root/cpp_code/nginx/nginx.c`。

### 3.2 终端和进程的关系

#### 3.3.1 终端

bash, zsh等同理。

每多一个新连接，都会有一个`-bash`进程，`pts`代表「虚拟终端」，每连接一个虚拟终端到linux操作系统，就会出现一个bash进程(shell)，用来解释用户输入的命令。

shell本质上也是一个可执行程序运行产生的进程



#### 3.3.2 终端上开启进程

运行的进程就是终端的子进程。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227214025076.png" alt="image-20230227214025076" style="zoom:40%;" />



每一个进程还属于一个进程组：一个或者多个进程的集合。每一个进程组有一个唯一的进程组ID，可以调用系统函数来创建进程组，加入进程组

session（会话）就是进程组的集合。只要不进行特殊的系统函数调用，一般一个bash上的所有进程都属于一个会话，而这个会话有一个session leader，一般这个shell就是 session leader，可以通过系统调用增加session

```bash
ps -eo pid,ppid,sid,tty,pgrp,comm | grep -E 'bash|PID|nginx'
```

-   如果关闭终端，系统会发送`SIGHUP`信号（终端断开信号），给session leader，也就是这个bash进程
-   bash进程收到`SIGHUP`信号后，会把这个信号发送给session中的所有进程



#### 3.3.4 strace工具

这是一个Linux下调试分析诊断工具：可以跟踪程序执行时进程的系统调用以及所收到的信号；

-   跟踪`nginx`进程：`strace -e trace=signal -p 11184`（可以想象成贴一块膏药到进程上），发送SIGHUP给所在进程组（可能只有一个进程）

`strace`输出：

```bash
+++ killed by SIGHUP +++
```



如果关闭一个shell，则bash先把SIGHUP发送给同一个session中所有进程，然后发送`SIGHUP`给自己。



#### 3.3.5 终端关闭时如何让进程不退出



**忽略`SIGHUP`信号**

我们可以通过忽略`SIGHUP`信号，使得终端关闭，进程依然执行，同时该进程的ppid变成1。

```cpp

 //忽略SIGHUP信号,设置某个信号来的时候处理程序。
 //SIG_IGN: 要求忽略这个信号，请操作系统不要用缺省的方式对待本进程（不要杀掉我）
 signal(SIGHUP, SIG_IGN);

```



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227223431253.png" alt="image-20230227223431253" style="zoom:40%;" />



**设置一个新的session id**

```cpp

    else if(pid == 0)
    {
        //子进程
        setsid();
        for(;;)
        {
        printf("子进程休息一秒\n");
        sleep(1);
        }
    }
    else if(pid > 0)
    {
        //父进程
        setsid();//父进程的setsid()无效
        for(;;)
        {

        printf("父进程休息一秒\n");
        sleep(1);
        }

    }

```



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227233945464.png" alt="image-20230227233945464" style="zoom:50%;" />

可以看到两个`nginx`进程，只有一个有新的`sid`，而另一个的`sid`和某个zsh相同。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227234059256.png" alt="image-20230227234059256" style="zoom:50%;" />

关闭执行`nginx`的zsh，子进程依然存在！成为孤儿进程，PPID为1。

也可以使用`setsid`命令，而且能够使启动的进程在一个新的session中，这样终端关闭时该进程就不会退出

```bash
setsid ./nginx
```

这样进程的sid pid都与之前的无关：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230227234831946.png" alt="image-20230227234831946" style="zoom:50%;" />



**nohup**

`nohup` 也可以忽略`SIGHUP`信号，与之前的忽略`SIGHUP`信号道理相同，用于在后台运行一个命令，即使用户退出登录或关闭终端窗口，命令也能够继续运行，它会把输出重定位到`nohup.out`文件中。只有关闭终端才会出现孤儿进程的效果，没有关闭终端和正常进程一样。



#### 3.3.6 后台运行 `&`

在命令后加一个`&`就是后台运行，在执行的同时终端可以干其他事。

`fg`可以切换到前台。



### 3.3 信号的概念、认识、处理动作

#### 3.3.1 信号的基本概念

进程之间常用通信手段：发送信号，例如`SIGHUP`信号，`kill`命令。nginx很多内容都依赖于信号，例如：热升级等。

-   信号用来通知某一个进程发生了某一个事情：
    -   事情，信号都是突发事件，也就是说信号是「异步发生」的，信号也被称为「软中断」。



**信号如何产生：**

-   某一个进程发送给另外一个进程或者发送给自己；
-   由内核（操作系统）发送给某个进程
    -   在键盘上输入命令`Ctrl + c`，发送一个中断信号，或者`kill`命令
    -   内存访问异常（例如除数为零），硬件都会检测并且通知内核



**信号的名字：**

-   都是以`SIG`开头，UNIX以及类UNIX操作系统（Linux、freebsd、solaris）所支持的信号各不相同，在10到64个之间。

-   信号既有名字，其实也是一些数字，信号是一些正整数常量，需要引入`#include <signal.h>``

-   ``gcc`搜索头文件的路径：

    -   `/usr/local/include/`
    -   `/usr/local/`

-   `gcc`搜索库文件

    -   `/usr/`等

-   在根路径下搜索`signal.h`文件，并在「文件内容」中搜索`SIGHUP`在第几行：

    ```bash
    find / -name "signal.h" | xargs grep -in "SIGHUP"
    ```

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228133128968.png" alt="image-20230228133128968" style="zoom:50%;" />

信号就是一些宏定义，从1开始。



#### 3.3.2 `kill`命令

`kill`命令可以杀死进程，但是有个误解，`kill`的工作是发送信号给进程，而不是所谓「杀死」，如果自己的程序没有特殊处理，操作系统对信号由默认动作，绝大多数都是直接杀死进程，但是例如`SIGSTOP`和`SIGTSP`就是放入后台。

-   `kill`能给进程发送「所有的信号」，默认发送`SIGTERM`（15），可以通过`strace -e trace=signal -p pid`追踪。
-   `kill -n pid`：给pid进程发送n信号。



**重要信号：**

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228135349918.png" alt="image-20230228135349918" style="zoom:50%;" />

`-9 SIGKILL`是代码不能处理的信号。同时`-18`继续运行也是在后台运行，需要`fg`。



#### 3.3.3 进程的状态

>    aux是BSD风格显示格式，

进程状态及其含义，`ps`命令的`STAT`列：

| 状态 | 含义                                                      |
| ---- | --------------------------------------------------------- |
| D    | 不可中断的休眠状态(通常是I/O的进程)，可以处理信号，有延迟 |
| R    | 可执行状态&运行状态(在运行队列里的状态)                   |
| S    | 可中断的休眠状态之中（等待某事件完成），可以处理信号      |
| T    | 停止或被追踪（被作业控制信号所停止）                      |
| Z    | 僵尸进程                                                  |
| X    | 死掉的进程                                                |
| <    | 高优先级的进程                                            |
| N    | 低优先级的进程                                            |
| L    | 有些页被锁进内存                                          |
| s    | Session  leader（进程的领导者），在它下面有子进程         |
| t    | 追踪期间被调试器所停止                                    |
| +    | 位于前台的进程组                                          |

 

#### 3.3.4 信号处理的相关动作

当某个信号出现时，我们可以按三种方式进行「信号处理」：

1.   执行系统默认动作，绝大部分都是杀死这个进程，少数是停止，或者继续运行
2.   忽略此信号，例如`signal(SIGHUP, SIG_IGN);`就是忽略`SIGHUP`信号，但是`SIGKILL`和`SIGSTOP`无法被忽略或者被捕捉
3.   捕捉该信号，写一个处理函数，信号来的时候用处理函数来处理，当然对`SIGKILL`和`SIGSTOP`无效。



### 3.4 Unix/Linux体系结构、信号变成初步

#### 3.4.1 Unix/Linux操作系统体系结构

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228144208636.png" alt="image-20230228144208636" style="zoom:50%;" />

类Unix操作系统分为两个状态：

1.   用户态
2.   内核态



-   操作系统/内核：用来控制计算机硬件资源，提供应用程序运行的环境。

    程序要么运行在用户态，用么运行在内核态，一般来说运行在用户态，当程序要执行一些「特殊代码」的时候，程序就可能切换到内核态，这种切换由操作系统控制，不需要人为控制。

    也就是说用户态就是最外圈的活动空间。

-   系统调用：一些系统函数（大概200～300个库函数），只需要调用系统函数接口

-   bash和shell的关系：

    -   bash：borne again shell（重新装配的shell），是shell的一种，linux默认用bash，可以改成zsh等

        -   bash也是一个可执行程序，主要作用是：把用户输入的命令翻译给操作系统（命令解释器）
        -   可以在bash上再执行bash，此时`exit`就会退出最上层的bash
        -   bash分隔系统调用和应用程序，有「胶水」的感觉；
    
-   用户态和内核态的切换：

    -   运行于用户态的进程可以执行的操作和访问的资源会受到限制（用户态权限小）
    -   而运行在内核态的进程可以执行任何操作并且在资源的使用上没有限制（内核态权限大）
    -   进程执行的时候大部分时间处于用户态，只有需要内核提供服务时才会切换到内核态，内核态做完事情后，又回到用户态
    -   `malloc()`和`printf()`都会切换，这种状态是操作系统干的，不需要人为介入



>   为什么要区分内核态和用户态：
>
>   -   一般情况下，程序都运行在用户态，权限小，不至于危害到系统的其他部分；当需要进行一些危险操作的时候，系统提供接口来操作
>
>   -   既然这些接口是系统提供的，那么这些接口也是操作系统统一管理的，资源是有限的，如果大家都来访问这些资源，不加以管理，会出现「访问冲突」和「访问资源耗尽导致系统崩溃」。系统提供这些接口，就是为了减少有限的资源的访问和使用上的冲突。例如经典的「卖票问题」：
>
>       <img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228150001535.png" alt="image-20230228150001535" style="zoom:50%;" />
>       
>       



**什么时候出现用户态切换到内核态？**

-   系统调用，例如调用`malloc()`
-   异常时间，比如来了个信号
-   外围设备中断



#### 3.4.2 `signal`函数

信号来了之后，可以忽略，可以捕捉，利用`signal()`来处理这个事情。



**c3/nginx3_4_1.c**

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

int g_mysign = 0;
//这个函数能够修改这个全局变量g_mysign的值
//这是一个不可重入函数
void muNEfunc(int value)
{
    //.....其他处理代码
    g_mysign = value;
    //.....其他处理代码
}

//信号处理函数,系统调用的时候会自动把信号的值传递过来
void sig_usr(int signo)
{
    //int tmpsign = g_mysign;
    muNEfunc(22); //因为一些实际需求必须要在sig_user这个信号处理函数里调用muNEfunc

    int myerrno = errno;

    if(signo == SIGUSR1)
    {
        printf("收到了SIGUSR1信号!\n");
    }
    else if(signo == SIGUSR2)
    {
        printf("收到了SIGUSR2信号!\n");
    }
    else
    {
        //其他信号不太可能执行到这里
        printf("收到了未捕捉的信号%d!\n",signo);
    }


    //g_mysign = tmpsign;
    errno = myerrno;
}

int main(int argc, char *const *argv)
{
    //注册两个信号处理函数
    if(signal(SIGUSR1,sig_usr) == SIG_ERR)  //系统函数，参数1：是个信号，参数2：是个函数指针，代表一个针对该信号的捕捉处理函数
    {
        printf("无法捕捉SIGUSR1信号!\n");
    }
    if(signal(SIGUSR2,sig_usr) == SIG_ERR)
    {
        printf("无法捕捉SIGUSR2信号!\n");
    }
    for(;;)
    {
        sleep(1); //休息1秒
        printf("休息1秒\n");

        muNEfunc(15);
        printf("g_mysign=%d\n",g_mysign);
        //拿g_mysign做一些其他用途；
    }
    printf("再见!\n");
    return 0;
}
```

使用`kill -USR1 pid`对进程发送`SIGUSR1`信号。

进程收到信号，这个事件就会被内核注意到，进入内核态：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228153810149.png" alt="image-20230228153810149" style="zoom:50%;" />

-   信号处理函数是在用户态执行的，再去内核态执行收尾工作
-   最后再回到用户态



#### 3.4.3 可重入函数

所谓的「可重入函数」（或叫异步信号安全），就是在信号处理中是安全的函数：

-   可重入函数：在信号处理程序中保证调用安全的函数，这些函数是可重入的并被称为异步信号安全的

有很多大家周知的函数都是不可重入的，例如`malloc()`和`printf()`，最好在信号处理函数中不要调用「不可重入函数」，还有可能导致`errno`的错误，因为信号处理函数的执行时间是未知的，如果在信号处理函数中改变了`errno`，可能会覆盖主流程的`errno`。

**信号处理函数的注意事项：**

1.   在信号处理函数中，尽量使用简单的语句，做简单的事情，尽量不要调用系统函数以免引起麻烦（这是最好的方法，就改改局部变量就行）

2.   如果必须要在信号处理函数中调用一些系统函数，那么要保证在信号处理函数中调用的 系统函数 一定要是「可重入的」

3.   如果必须要在信号处理函数中调用那些可能修改`errno`的值的系统函数，那么就得事先备份`errno`的值，从信号处理函数返回之前，在信号处理函数的返回值前将`errno`恢复。

     ```cpp
     void fun(int signo)
     {
         int myerrno = errno;
         //信号处理
         errno = myerrno;
         return ;
     }
     ```

     

#### 3.4.4 不可重入函数（错用演示）

在信号处理函数和main函数中都无限循环`malloc()`：

**c3/nginx3_4_2.c**

```cpp
#include <stdio.h>
#include <stdlib.h>  //malloc
#include <unistd.h>
#include <signal.h>

//信号处理函数
void sig_usr(int signo)
{
    //这里也malloc，这是错用，不可重入函数不能用在信号处理函数中；
    int* p;
    p = (int *) malloc (sizeof(int)); //用了不可重入函数；
    free(p);

    if(signo == SIGUSR1)
    {
        printf("收到了SIGUSR1信号!\n");
    }
    else if(signo == SIGUSR2)
    {
        printf("收到了SIGUSR2信号!\n");
    }
    else
    {
        printf("收到了未捕捉的信号%d!\n",signo);
    }

}

int main(int argc, char *const *argv)
{
    if(signal(SIGUSR1,sig_usr) == SIG_ERR)  //系统函数，参数1：是个信号，参数2：是个函数指针，代表一个针对该信号的捕捉处理函数
    {
        printf("无法捕捉SIGUSR1信号!\n");
    }
    if(signal(SIGUSR2,sig_usr) == SIG_ERR)
    {
        printf("无法捕捉SIGUSR2信号!\n");
    }
    for(;;)
    {
        //sleep(1); //休息1秒
        //printf("休息1秒\n");
        int* p;
        p = (int *) malloc (sizeof(int));
        free(p);
    }
    printf("再见!\n");
    return 0;
}
```

一旦在信号处理中用了不可重入函数，可能导致程序错乱，导致再发送信号没用了，进程的状态变成`S+`也就是休眠。

**这种错误在实际操作中很难发现。**

>   `signal()`因为兼容性和可靠性等一些历史问题，不建议使用，官方建议使用`sigaction()`来代替。
>
>   坚决不用`signal()`!



### 3.5 信号编程进阶、`sigprocmask()`函数

如果在信号处理函数正在执行的时候，又来了一个「相同的信号」，此时系统还会执行对应的信号处理函数吗？

不会，需要排队。

#### 3.5.1 信号集

一个进程必须记住当前阻塞了哪些信号，需要「信号集」的数据类型，这种类型能表示60多种信号。

如果信号集对应的位置为1，则代表正在处理该信号，再来一个相同的信号就会「排队」，在执行期间，不管来多少个相同的信号，都只会合并成一次。

在linux中用`sigset_t`结构类型表示信号集：

```cpp
typedef struct
{
    unsigned long sig[2];
}sigset_t;
```

信号集一共能表示64个信号，0表示信号没来，1表示信号来了。

一个进程里面会有一个信号集，这个信号集用来记录当前屏蔽（阻塞）了哪些信号，如果把这个信号集中某个信号位设置为1，那么同类信号会被屏蔽，不会传递给该进程。



#### 3.5.2 信号集相关函数

-   `sigemptyset()`：清空信号集，把64位全部清零，表示64个信号都没有来
-   `sigfillset()`：填充信号集，把信号集中所有信号都设置为1，与`sigemptyset()`相反
-   `sigaddset()`和`sigdelset()`可以在信号集中 「增加或删除」 特定信号。
-   `sigprocmask()`和`sigismember()`
    -   `sigprocmask()`函数能设置该进程阻塞信号集中的内容
    -   `sigismember()`函数



#### 3.5.3 `sigpromask()`等信号函数范例



```cpp
#include <stdio.h>
#include <stdlib.h>  //malloc
#include <unistd.h>
#include <signal.h>

//信号处理函数
void sig_quit(int signo)
{   
    printf("收到了SIGQUIT信号!\n");
}

int main(int argc, char *const *argv)
{
    sigset_t newmask,oldmask; //信号集，新的信号集，原有的信号集
    if(signal(SIGQUIT,sig_quit) == SIG_ERR)  //注册信号对应的信号处理函数,对应键盘"ctrl+\" 输入
    {        
        printf("无法捕捉SIGQUIT信号!\n");
        exit(1);   //退出程序，参数是错误代码，0表示正常退出，非0表示错误，但具体什么错误，没有特别规定，这个错误代码一般也用不到，可以先不管；
    }

    sigemptyset(&newmask); //newmask信号集中所有信号都清0（表示这些信号都没有来）；
    sigaddset(&newmask,SIGQUIT); //设置newmask信号集中的SIGQUIT信号位为1，再来SIGQUIT信号时，进程就收不到，设置为1就是该信号被阻塞掉

    //sigprocmask()：设置该进程所对应的信号集
    if(sigprocmask(SIG_BLOCK,&newmask,&oldmask) < 0)  //第一个参数用了SIG_BLOCK表明设置 进程 新的信号屏蔽字 为 “当前信号屏蔽字 和 第二个参数指向的信号集的并集
    {                                                 //一个 ”进程“ 的当前信号屏蔽字，刚开始全部都是0的；所以相当于把当前 "进程"的信号屏蔽字设置成 newmask（屏蔽了SIGQUIT)；
                                                      //第三个参数不为空，则进程老的(调用本sigprocmask()之前的)信号集会保存到第三个参数里，用于后续，这样后续可以恢复老的信号集给线程
        printf("sigprocmask(SIG_BLOCK)失败!\n");
        exit(1);
    }
    printf("我要开始休息10秒了--------begin--，此时我无法接收SIGQUIT信号!\n");
    sleep(10);   //这个期间无法收到SIGQUIT信号的；
    printf("我已经休息了10秒了--------end----!\n");
    if(sigismember(&newmask,SIGQUIT))  //测试一个指定的信号位是否被置位(为1)，测试的是newmask
    {
        printf("SIGQUIT信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGQUIT信号没有被屏蔽!!!!!!\n");
    }
    if(sigismember(&newmask,SIGHUP))  //测试另外一个指定的信号位是否被置位,测试的是newmask
    {
        printf("SIGHUP信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGHUP信号没有被屏蔽!!!!!!\n");
    }

    //现在我要取消对SIGQUIT信号的屏蔽(阻塞)--把信号集还原回去
    if(sigprocmask(SIG_SETMASK,&oldmask,NULL) < 0) //第一个参数用了SIGSETMASK表明设置 进程  新的信号屏蔽字为 第二个参数 指向的信号集，第三个参数没用
    {
        printf("sigprocmask(SIG_SETMASK)失败!\n");
        exit(1);
    }

    printf("sigprocmask(SIG_SETMASK)成功!\n");
    
    if(sigismember(&oldmask,SIGQUIT))  //测试一个指定的信号位是否被置位,这里测试的当然是oldmask
    {
        printf("SIGQUIT信号被屏蔽了!\n");
    }
    else
    {
        printf("SIGQUIT信号没有被屏蔽，您可以发送SIGQUIT信号了，我要sleep(10)秒钟!!!!!!\n");
        int mysl = sleep(10);
        if(mysl > 0)
        {
            printf("sleep还没睡够，剩余%d秒\n",mysl);
        }
    }
    printf("再见了!\n");
    return 0;
}



```

**如果在阻塞信号的时候输入 ctrl + \\**



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228170418272.png" alt="image-20230228170418272" style="zoom:50%;" />

输入的多个`ctrl + \`，会在屏蔽后发送一个`SIGQUIT`信号，先执行`sig_quit()`信号处理函数，再处理`sigprocmask()`。



**如果没有在阻塞的时候输入 ctrl + \\**

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228165721621.png" alt="image-20230228165721621" style="zoom:50%;" />

没有显示“收到了`SIGQUIT`信号，同时会打断`sleep()`函数，直接运行到结束。

`sleep()`函数能够被打断:

1.   时间到了
2.   某个信号处理函数使`sleep()`提前结束，此时`sleep()`会返回剩余的时间。



**如果把`sig_quit()信号处理函数修改为：**

```cpp
void sig_quit(int signo)
{
    printf("收到了SIGQUIT信号!\n");
    if(signal(SIGQUIT,SIG_DFL) == SIG_ERR)
    {
        printf("无法为SIGQUIT信号设置缺省处理(终止进程)!\n");
        exit(1);
    }
}

```



意思是：在收到一次`SIGQUIT`信号之后，就用缺省的方式（终止进程）。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228170738109.png" alt="image-20230228170738109" style="zoom:50%;" />

在屏蔽之后再按`ctrl + \`，会直接终止程序，不会输出`sleep()`的剩余时间，但是合二为一的那个`SIGQUIT`信号还是按照信号处理函数的首次执行，输出语句，间接证明在阻塞期间发送多个`SIGQUIT`信号只会执行一次（如果不是的话，阻塞一结束就直接退出了！）



在阻塞期间不发送`SIGQUTI`信号，而是在非阻塞期间发送：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228171210022.png" alt="image-20230228171210022" style="zoom:50%;" />

可以看到第一次执行`SIGUIT`的处理函数会打断`sleep()`，并执行到结束。

>   这个例子来自《APUE》。
>
>   为什么需要注册`SIGQUIT`呢？它不是有默认的处理方法吗?
>
>   因为收到的`SIGQUIT`信号的默认处理是终止进程，屏蔽的信号会阻塞，当屏蔽结束后立即发送过来，执行信号处理函数，所以如果不先注册`SIGQUIT`，使用自己的处理函数，则会立即退出程序。



### 3.6 `fork()`详解

#### 3.6.1 简单认识`fork()`

用来创建进程。

一个可执行程序，执行起来就是一个进程，再执行一次，又是一个进程（多个进程可以共享一个可执行文件），文雅一点：

「进程 定义为程序执行的一个实例」。当该子进程创建时，它从`fork()`函数的返回处开始执行与父进程相同的代码。

`fork()`函数产生了一个与当前进程完全一样的新进程，并和当前进程一样从`fork()`返回。`fork()`就是一分为二。



子进程被杀死前，会向父进程发送`SIGCHLD`信号：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228191418024.png" alt="image-20230228191418024" style="zoom:50%;" />

同时子进程变成「僵尸进程」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228191605063.png" alt="image-20230228191605063" style="zoom:50%;" />



#### 3.6.2 僵尸进程的产生、解决、`SIGCHLD`信号

**僵尸进程的产生：**

在Unix系统中，一个子进程结束了，但是它的父进程还活着，但是该父进程没有调用`wait() / waitpid()`函数来进行额外处理，则这个子进程就会变成一个僵尸进程。

僵尸进程已经被终止，不干活了，但是依旧没有被内核丢弃，因为内核认为父进程可能还需要子进程的一些信息。

僵尸进程会占用资源（至少会占用一个pid），作为开发人员，坚决不允许僵尸进程存在！



**僵尸进程的解决：**

-   重启电脑
-   手工把僵尸进程的父进程`kill`掉，僵尸进程就会消失



**`SIGCHLD`信号：**

一个进程被终止或者停止时，会向父进程发送`SIGCHLD`信号，所以，对于代码中有`fork()`调用的进程，需要拦截`SIGCHLD`信号，信号处理函数需要调用`waitpid()`：

```cpp
//信号处理函数
void sig_usr(int signo)
{
    int  status;

    switch(signo)
    {
        case SIGUSR1:
            printf("收到了SIGUSR1信号，进程id=%d!\n",getpid());
            break;

        case SIGCHLD:
            printf("收到了SIGCHLD信号，进程id=%d!\n",getpid());
            //waitpid获取子进程的终止状态，这样，子进程就不会成为僵尸进程了；

            //第一个参数为-1，表示等待任何子进程，
            //第二个参数：保存子进程的状态信息
            //第三个参数：提供额外选项，WNOHANG表示不要阻塞，让这个waitpid()立即返回
            pid_t pid = waitpid(-1,&status,WNOHANG); 
            if(pid == 0)       //子进程没结束，会立即返回这个数字，但这里应该不是这个数字
                return;
            if(pid == -1)      //这表示这个waitpid调用有错误，有错误也立即返回出去，我们管不了这么多
                return;
            //走到这里，表示  成功，那也return吧
            return;
            break;
    } //end switch
}
```



#### 3.6.3 `fork()`进一步认识

-   `fork()`产生新进程的速度非常快，`fork()`产生新进程并不会复制原进程的内存空间，而是和父进程一起共享一个内存空间，这个内存空间的特点是：「写时复制」。
-   原来的进程和`fork()`出来的子进程可以同时、自由地读取内存，但是子进程或父进程 对内存进行修改的话， 则内存会复制原来的内存。
-   `fork()`会返回两次，在父进程中返回子进程的pid，在子进程中返回0，父进程和子进程互不影响。

连续两个`fork()`：

```cpp
fork();
fork();
```

会产生4个进程：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228193230694.png" alt="image-20230228193230694" style="zoom:50%;" />



**一个`fork()`的逻辑题：**

```cpp
((fork() && fork()) || (fork() && fork()));
```

上面的代码执行会有几个进程？

>   答案是7个。

`fork()`中，父进程执行到哪，子进程就执行到哪！

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228194855416.png" alt="image-20230228194855416" style="zoom:40%;" />

需要注意对于`&&`而言，出现0后面的就不执行了，对于`||`而言，出现1后面的就不执行了。这个题目还真不是考的`fork()`，考的是逻辑运算的「短路求值」。

#### 3.6.4 `fork()`失败的可能性

一般不会失败，但也有失败的可能，原因有：

-   系统中进程太多，系统最大的pid：32767

-   每隔用户有允许开启的进程总数：`printf("每个实际用户ID的最大进程数=%ld\n",sysconf(_SC_CHILD_MAX));`

    我的机器是7282



### 3.7 文件描述符

#### 3.7.1 文件描述符简介

**文件描述符：**

-   一个正整数，用来标识一个文件
-   当打开一个存在的文件，或者创建一个新文件，操作系统都会返回一个文件描述符（代表该文件）
-   后续对文件操作的函数，都需要到文件对应的文件描述符



#### 3.7.2 三个特殊文件描述符

Linux三个特殊的文件描述符，0，1，2:

-   0：标准输入，键盘，对应常量为`STDIN_FILENO`
-   1：标准输出，屏幕，对应的符号常量为`STDOUT_FILENO`
-   2：标准错误，对应屏幕，对应的符号常量为`STDERR_FILENO`

>   类Unix操作系统，默认从`STDIN_FILENO`读取数据，向`STDOUT_FILENO`写数据，向`STDERR_FILENO`来写错误。
>
>   「一切皆文件」，所以它把标准输入、标准输出、标准错误 都看作文件。
>
>   -   像看待文件一样看待 标准输入、标准输出、标准错误
>   -   像操作文件一样操作标准输入、标准输出、标准错误

同时，程序一旦运行起来，这三个文件描述符：0，1，2会被自动打开，自动指向对应的设备。

文件描述符虽然是数字，但是如果把文件描述符理解成指针（指针里面保存的是地址，地址本质上也是一个数字）

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228205323584.png" alt="image-20230228205323584" style="zoom:40%;" />

下面的代码相当于向屏幕写"aaaabbb"的前6个字符。

```cpp
write(STDIN_FILENO, "aaaabbb", 6);
```



#### 3.7.3 输入输出重定向

-   标准输出文件描述符可以不指向屏幕，可以指向（重定向）一个文件，在命令行中用`>`就可以输出重定向
-   在命令行中使用`<`就可以输入重定向，例如`cat < myinfile`，意思是从`myinfile`读入内容，并通过`cat`显示到标准输出上来，`cat`不加参数就是写入什么，终端显示什么。
-   `cat < myinfile > myoutfile`代表从`myinfile`读入内容，重定向到`myoutfile`中



#### 3.7.4 空设备

`/dev/null`：这是一个特殊的设备文件，丢弃一切写入其中的数据（就像黑洞一样）



#### 3.7.5 `dup2()`函数

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228211936650.png" alt="image-20230228211936650" style="zoom:50%;" />

`dup2()`把第一个参数复制给第二个参数，相当于指针赋值，而不拷贝内容，拷贝前会先关闭，也就是`close`。

`close(fd)`等价于`fd = null`。

### 3.8 守护进程

#### 3.8.1 普通进程运行观察

-   普通进程有对应的终端，如果终端退出，那么对应的进程也就消失了；它的父进程是一个bash
-   终端被占住了，输入各种命令这个终端没有反应

#### 3.8.2 守护进程基本概念

守护进程是一种长期运行的进程，这种进程在后台运行，**并且不和任何的控制终端相关联**。

**基本特点：**

-   生存期长，一般是操作系统启动它就启动，操作系统关闭它才关闭。（不是必须，但一般应该这样做）
-   守护进程和终端无关，也就是说没有控制终端，退出终端不会导致守护进程退出。
-   守护进程在后台运行



Linux操作系统本身有很多守护进程在后台运行，一般我们不用管。



`ps -efj`可以查看工作进程：

-   ppid = 0的内核进程，例如pid=1和2的进程都是和系统启动而启动。
-   cmd列带`[]`的都是内核守护进程，它们都以`kthreadd`为父进程。
-   `init`进程也是系统守护进程，它负责启动各运行层次特定的系统服务，所以很多进程的ppid是init，同时还负责收养孤儿进程。



**共同点总结：**

-   大多数守护进程都是以root权限运行的
-   守护进程没有控制终端TT这列显示
    -   内核守护进程以无控制终端方式启动
    -   普通守护进程可能是守护进程调用了`setsid()`的结果（无控制终端）



#### 3.8.3 守护进程编写规则

1.   调用`umask(0)`，用来限制文件权限，设置为0代表「不让umask设置权限」

2.    `fork()`一个子进程出来，然后父进程退出（固定套路），把终端空出来，不让终端卡住

      `fork()`的目的是让子进程来调用`setsdi()`来建立新会话，子进程不会是进程组组长。目的是让`fork()`出来的子进程有单独的sid，而且子进程也成为了一个新进程组的组长进程，同时子进程脱离终端。

3.    守护进程虽然可以通过终端启用，但是和终端不挂钩。守护进程是在后台运行，所以它不应该从键盘上接受任何东西，也不应该把输出结构打印到屏幕或者终端上来。所以按照规则，我们应该把守护进程的标准输入和输出都重定向到`/dev/null`中去。从而确保守护进程不从键盘接受任何东西，也不把输出结果打印到屏幕（我们不希望守护进程的输出打印到屏幕，也不希望输入的内容输入到守护进程中）。



**nginx中的守护进程创建代码，c3/nginx3_7_2.c**

```cpp
#include <stdio.h>
#include <stdlib.h>  //malloc
#include <unistd.h>
#include <signal.h>

#include <sys/stat.h>
#include <fcntl.h>

//创建守护进程
//创建成功则返回1，否则返回-1
int ngx_daemon()
{
    int  fd;

    switch (fork())  //fork()子进程
    {
    case -1:
        //创建子进程失败，这里可以写日志......
        return -1;
    case 0:
        //子进程，走到这里，直接break;
        break;
    default:
        //父进程，直接退出
        exit(0);
    }

    //只有子进程流程才能走到这里
    if (setsid() == -1)  //脱离终端，终端关闭，将跟此子进程无关
    {
        //记录错误日志......
        return -1;
    }
    umask(0); //设置为0，不要让它来限制文件权限，以免引起混乱

    fd = open("/dev/null", O_RDWR); //打开黑洞设备，以读写方式打开
    if (fd == -1)
    {
        //记录错误日志......
        return -1;
    }
    //先关闭STDIN_FILENO[这是规矩，已经打开的描述符，动他之前，先close]，类似于指针指向null，让/dev/null成为标准输入；
    if (dup2(fd, STDIN_FILENO) == -1)
    {
        //记录错误日志......
        return -1;
    }

    if (dup2(fd, STDOUT_FILENO) == -1) //先关闭STDIN_FILENO，类似于指针指向null，让/dev/null成为标准输出；
    {
        //记录错误日志......
        return -1;
    }

     if (fd > STDERR_FILENO)  //fd应该是3，这个应该成立
    {
        if (close(fd) == -1)  //释放资源这样这个文件描述符就可以被复用；不然这个数字【文件描述符】会被一直占着；
        {
            //记录错误日志......
            return -1;
        }
    }

    return 1;
}

int main(int argc, char *const *argv)
{
    if(ngx_daemon() != 1)
    {
        //创建守护进程失败，可以做失败后的处理比如写日志等等
        return 1;
    }
    else
    {
        //创建守护进程成功,执行守护进程中要干的活
        for(;;)
        {
            sleep(1); //休息1秒
            printf("休息1秒，进程id=%d!\n",getpid()); //你就算打印也没用，现在标准输出指向黑洞（/dev/null），打印不出任何结果【不显示任何结果】
        }
    }
    return 0;
}
```



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228212847801.png" alt="image-20230228212847801" style="zoom:50%;" />

`STAT`中的`s`小写s代表它是session leader 。

对比启动nginx服务器：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230228213126985.png" alt="image-20230228213126985" style="zoom:50%;" />

可以看到nginx的master默认就是以守护进程启动的。

守护进程可以命令启动，也可以借助脚本开机启动。



#### 3.8.4 守护进程不会收到的信号

**`SIGHUP`信号**

守护进程不会收到 来自内核的`SIGHUP`信号，如果守护进程收到了这个信号，那么一定是另外的进程发送给你的。很多守护进程把这个信号作为通知信号，表示配置文件已经发生改变，需要重新读入配置文件。

例如`nginx -s reload pid`和`kill -1 pid`的效果相同。



**`SIGINT`和`SIGWINCH`**

守护进程也不会收到来自内核的`SIGINT`（ctrl + c）和`SIGWINCH`（终端窗口大小改变信号）。

#### 3.8.5 守护进程和后台进程的区别

-   守护进程和终端没有联系，后台进程能往终端上输出（和终端有关联）
-   守护进程关闭终端不受影响，关闭终端后台进程也会退出
-   守护进程是session leader



## 4. 服务器程序框架初步

### 4.1 服务器程序目录规划、makefile编写

#### 4.1.1 信号高级认识范例

对于`SIGUSR1`和`SIGUSR2`有如下信号处理函数：

```cpp
//信号处理函数
void sig_usr(int signo)
{
    if(signo == SIGUSR1)
    {
        printf("收到了SIGUSR1信号，我休息10秒......!\n");
        sleep(10);
        printf("收到了SIGUSR1信号，我休息10秒完毕，苏醒了......!\n");
    }
    else if(signo == SIGUSR2)
    {
        printf("收到了SIGUSR2信号，我休息10秒......!\n");
        sleep(10);
        printf("收到了SIGUSR2信号，我休息10秒完毕，苏醒了......!\n");
    }
    else
    {
        printf("收到了未捕捉的信号%d!\n",signo);
    }
}
```

-   收到信号休息10秒，这个时候流程回不到`main()`，所以`main()`中的语句无法执行
-   在触发`SIGUSR1`信号并因此`sleep`10秒的期间，这个信号是阻塞的（加入阻塞信号集），就算多次发送`SIGUSR1`信号，也不会重新执行对应的信号处理函数，而是等待「上一次信号处理函数执行完毕」才第二次执行`SIGUSR1`，因为为「未决信号集」只能是0或1。

**但是如果发送`SIGUSR1`和`SIGUSR2`信号：**

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230301132009294.png" alt="image-20230301132009294" style="zoom:50%;" />

-   在`USR1`sleep期间，发送`USR2`信号，会进入`USR2`的sleep，而`USR2`sleep完毕后，`USR1`的sleep是**立即结束！**例如USR1休息10秒，在第五秒时发送`USR2`信号，会打断`USR1`的sleep，`USR2`休息10秒，出来后`USR1`的sleep立即结束。

-   执行USR1信号处理函数，没有执行完的时候，是可以继续进入USR2信号处理函数中去的；

    相当与USR1和USR2的信号处理函数都没有结束，都在阻塞着，此时发送`USR1`和`USR2`都不会有反应

-   只有USR2的信号处理函数处理完毕，才会返回到USR1的信号处理程序，只有USR1的信号处理函数执行完毕（注意USR2的信号处理函数只是打断了USR1的sleep，USR1处理程序的剩下部分会继续执行），才会回到`main()`主流程去继续执行。



>   如果希望在处理USR1信号，执行USR1信号处理函数的时候，如果来了USR2信号，如何屏蔽这个USR2信号呢？也就是说不希望跳转到别的信号处理函数中去。



#### 4.1.2 服务器架构初步

一套通讯架构源代码，应该存在不同的目录，需要注意：

-   文件名中不要带空格，不要用中文！
-   字母、数字、下划线



**本项目的目录规划如下：**

-   `_include/`：专门存放各种头文件，如果分散的话，引用头文件还需要不同的目录前缀
-   `app/`：放主应用程序.c（main函数所在文件）以及一些比较核心的文件，`app/`下还有：
    -   `link_obj/`：临时目录，存放临时的`.o`文件，这个目录不是手工创建，由makefile创建
    -   `dep/`：临时目录，存放`.d`的依赖文件，依赖文件能够告知系统哪些相关的文件发生变化，需要重新编译，也是由makefile创建
    -   `nginx.c`：主文件，`main()`入口函数
    -   `nginx_conf.c`：普通的源码文件，与`nginx.c`关系密切
-   `misc/`：专门存放不好归类的`.c`文件
-   `net/`：专门存放和网络处理相关的`.c`文件
-   `proc/`：专门存放和进程处理的相关`.c`文件
-   `signal/`：专门存放和信号处理相关的`.c`文件



**本项目的makefile规划：**

-   根目录下三个文件：
    -   `makefile`：编译项目的入口脚本，编译项目从这里开始，起总体控制作用
    -   `config.mk`：配置脚本，被makefile包含，单独分离出来有利于修改，有变动的东西都可以写到这里
    -   `common.mk`：核心的编译脚本，用来定义makefile的编译规则，依赖规则等，通用性很强，每个子目录的`makefile`都用到了这个脚本
-   每个子目录都有一个`makefile`文件，每个文件都会包含根目录下的`common.mk`
-   本项目的`makefile`不支持目录中还有子目录，只支持一级目录。

#### 4.1.3 编译工具make

-   每个`.c`生成一个`.o`，最终链接到一起，生成一个可执行文件。

编译实际的项目肯定要用`make`，这个命令能编译，链接。。。最终生成可执行文件，大型项目一般用make：

-   make去当前的目录读取`Makefile`文件，根据`Makefile`里的规则，把源代码编译成可执行文件。
-   `Makefile`定义了项目的编译、链接规则，实际上`Makefile`就是编译工程中要用到的各种源文件的一个依赖关系描述。
-   有的工具能自动生成`Makefile`，例如`autotools`，`Makefile`文件没有扩展名，放在`make`命令执行的目录，一般就是放在根目录下，也会根据需要放在子目录。



本项目写一个通用性比较好（还行）的Makefile。



#### 4.1.4 makefile介绍

-   `make`编译项目，生成可执行文件
-   `make clean`清除临时文件，实际写在makefile中

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230301143325188.png" alt="image-20230301143325188" style="zoom:40%;" />

makefile中记录的就是上图的依赖关系。

如果修改了`ngx_func.h`，重新编译只会编译`nginx.o`和`ngx_conf.c`，而不会编译与其无关的`ngx_signal.o`。



#### 4.1.5 makefile的实现



代码中有详细注释。



### 4.2 配置文件读取和解析

#### 4.2.1 前提内容和修改

使用配置文件，能使服务器程序有极大的灵活性，应该首先解决服务器配置文件，读取配置文件中的配置项到内存中来。



配置文件：是一个文本文件，里面除了注释行之外，不要用中文，只在配置文件中使用字母数字下划线。

我们规定：

-   以`#`开始的行为注释行，注释可以有中文
-   每个有效配置项用 等号`=` 处理，等号前不超过40个字符，等号后不超过400个字符；
-   `[`开头的表示组信息，也等价于注释行



#### 4.2.2 配置功能读取实战

nginx的配置文件在`conf/`目录下，但是里面的内容太丰富了，嵌套了太多层，我们简化了配置文件，并将配置文件写在项目根目录下的`nginx.conf`文件中。

读取配置文件的代码：

**_include/ngx_c_conf.h:**

文件名字中间有个`_c`代表和类相关的文件。

```cpp

#ifndef __NGX_CONF_H__
#define __NGX_CONF_H__

#include <vector>

#include "ngx_global.h"  //一些全局/通用定义

//类名可以遵照用C开头的命名规范,代表Class
class CConfig
{

//单例设计模式
private:
	CConfig();
public:
	~CConfig();
private:
	static CConfig *m_instance;

public:	
	static CConfig* GetInstance() 
	{	
		if(m_instance == NULL)
		{
			//锁,多线程才用,第一次调用要在主线程中调用
            //这个代码可能不是那么好
			if(m_instance == NULL)
			{					
				m_instance = new CConfig();
                //定义一个静态的变量,这个变量是类中类型的，用来释放单例对象,而不是程序结束,系统自动释放
				static CGarhuishou cl; 
			}
			//放锁		
		}
		return m_instance;
	}	

	class CGarhuishou  //类中套类，用于释放单例对象
	{
	public:				
		~CGarhuishou()
		{
			if (CConfig::m_instance)
			{						
				delete CConfig::m_instance;
				CConfig::m_instance = NULL;				
			}
		}
	};
//
public:
    //重要的成员函数
    bool Load(const char *pconfName); //装载配置文件
	const char *GetString(const char *p_itemname);
	int  GetIntDefault(const char *p_itemname,const int def);

public:
    //存储配置信息的列表, 里面存的是指针
	std::vector<LPCConfItem> m_ConfigItemList; 

};

#endif

```

**`_include/ngx_global.h`**

```cpp
//结构定义
typedef struct
{
	char ItemName[50];
	char ItemContent[500];
}CConfItem,*LPCConfItem;

```

-   `CConfItem`结构体有两个成员，一个存配置名，一个存配置信息。



-   使用了单例设计模式
-   `m_ConfigItemList`存储配置信息，里面是一个`LPCConfItem`的指针，
-   `Load()`函数装载配置文件到内存中
-   `GetString()`根据配置名查询配置信息，返回`string`类型
-   `GetIntDefault()`也是根据配置名查询配置信息，返回`int`类型，如果没有查询到，会有一个缺省值(`def`).



**app/ngx_c_conf.cxx:**



```cpp

//系统头文件放上面
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>

//自定义头文件放下面,因为g++中用了-I参数，所以这里用<>扩起来也可以
#include "ngx_func.h"     //函数声明
#include "ngx_c_conf.h"   //和配置文件处理相关的类,名字带c_表示和类有关

//静态成员赋值
CConfig *CConfig::m_instance = NULL;

//构造函数
CConfig::CConfig()
{		
}

//析构函数
CConfig::~CConfig()
{    
    //删除迭代器中的内容
	std::vector<LPCConfItem>::iterator pos;	
	for(pos = m_ConfigItemList.begin(); pos != m_ConfigItemList.end(); ++pos)
	{		
		delete (*pos);
	}//end for
	m_ConfigItemList.clear(); 
}

//加载配置文件的函数
bool CConfig::Load(const char *pconfName) 
{   
    //首先根据传入的字符串打开文件
    FILE *fp;
    fp = fopen(pconfName,"r");
    if(fp == NULL)
        return false;

    //每一行配置文件读出来都放到linebuf
    char  linebuf[501];   //每行配置都不要太长，保持<500字符内，防止出现问题
    
    //走到这里，文件打开成功 
    while(!feof(fp))  //检查文件是否结束 ，没有结束则条件成立
    {    
        //注意代码的严密性
        //从文件中读数据，每次读一行，一行最多不要超过500个字符 
        if(fgets(linebuf,500,fp) == NULL) 
            continue;

        //读到空行
        if(linebuf[0] == 0)
            continue;

        //处理注释行, 也就是判断第一个字符是下面这些字符开头的
        //以及处理其他的情况,例如换行,空行等, 直接跳过
        if(*linebuf==';' || *linebuf==' ' || *linebuf=='#' || *linebuf=='\t'|| *linebuf=='\n')
			continue;
        
    //与goto语句一起使用
    lblprocstring:
        //读取的字符串后边有换行，回车，空格等都截取掉
		if(strlen(linebuf) > 0)
		{
            //ascii码的形势来判断
			if(linebuf[strlen(linebuf)-1] == 10 || linebuf[strlen(linebuf)-1] == 13 || linebuf[strlen(linebuf)-1] == 32) 
			{
				linebuf[strlen(linebuf)-1] = 0;
				goto lblprocstring;
			}		
		}
        //空行
        if(linebuf[0] == 0)
            continue;
        //也等价于配置行
        if(*linebuf=='[') //[开头的也不处理
			continue;

        // 类似于的“ListenPort = 5678”配置项走下来；
        //用 = 分割, 右边的保存到ptmp中
        char *ptmp = strchr(linebuf,'=');
        if(ptmp != NULL)
        {
            //LPConfItem是一个指向结构体的指针, CConfItem是结构体, 里面存储配置项名字ItemName和配置项内容ItemContent
            //new的时候是new结构
            LPCConfItem p_confitem = new CConfItem;                    //注意前边类型带LP，后边new这里的类型不带

            //清零
            memset(p_confitem,0,sizeof(CConfItem));
            //拷贝前n个字符
            strncpy(p_confitem->ItemName,linebuf,(int)(ptmp-linebuf)); //等号左侧的拷贝到p_confitem->ItemName
            strcpy(p_confitem->ItemContent,ptmp+1);                    //等号右侧的拷贝到p_confitem->ItemContent, 遇到'\0'结束

            //去掉首位的空格，定义在`app/ngx_string.cxx`中
            Rtrim(p_confitem->ItemName);
			Ltrim(p_confitem->ItemName);
			Rtrim(p_confitem->ItemContent);
			Ltrim(p_confitem->ItemContent);

            //printf("itemname=%s | itemcontent=%s\n",p_confitem->ItemName,p_confitem->ItemContent);            
            
            
            m_ConfigItemList.push_back(p_confitem);  //内存要释放，因为这里是new出来的 
        } //end if
    } //end while(!feof(fp)) 

    
    //关闭文件
    fclose(fp); 
    return true;
}

//根据ItemName获取配置信息字符串，没有修改不用考虑互斥
const char *CConfig::GetString(const char *p_itemname)
{
	std::vector<LPCConfItem>::iterator pos;	
	for(pos = m_ConfigItemList.begin(); pos != m_ConfigItemList.end(); ++pos)
	{	
		if(strcasecmp( (*pos)->ItemName,p_itemname) == 0)
			return (*pos)->ItemContent;
	}//end for
	return NULL;
}
//根据ItemName获取int类型配置信息，没有修改,所以不用考虑互斥
//def是缺省值, 如果没找到则返回缺省值
int CConfig::GetIntDefault(const char *p_itemname,const int def)
{
	std::vector<LPCConfItem>::iterator pos;	
	for(pos = m_ConfigItemList.begin(); pos !=m_ConfigItemList.end(); ++pos)
	{	
		if(strcasecmp( (*pos)->ItemName,p_itemname) == 0)
            //转为int类型
			return atoi((*pos)->ItemContent);
	}//end for
	return def;
}
```

-   成员函数的实现



**测试代码：**

**nginx.conf**

```
 
#[开头的表示组信息，也等价于注释行
[Socket]

#监听端口
ListenPort = 5678    

#DBInfo代表数据信息
DBInfo = 127.0.0.1;1234;myr;123456;mxdb_g
```

**在nginx.cxx的main函数中添加：**

```cpp
//我们在main中，先把配置读出来，供后续使用,不要在子线程中首次调用GetInstance
CConfig *p_config = CConfig::GetInstance(); //单例类

//把项目根目录下的配置文件加载到内存
if(p_config->Load("nginx.conf") == false) 
{
    printf("配置文件载入失败，退出!\n");
    exit(1);
}
//测试, 打印一些配置项信息  
int port = p_config->GetIntDefault("ListenPort", 0); //0是缺省值
 printf("port=%d\n",port);
 const char *pDBInfo = p_config->GetString("DBInfo");
 if(pDBInfo != NULL)
 {
   printf("DBInfo=%s\n",pDBInfo);
 }
```

可以打印出`ListenPort`的值和`DBInfo`的值。



### 4.3 内存泄露的检测工具memcheck

写完代码之后，需要检查，例如`fd`是否关闭，内存是否释放，有没有内存泄漏的问题。

「**valgrind**」工具可以帮助程序员寻找程序里的bug和改进程序性能的工具集。擅长发现内存的管理问题，这个工具集中有若干工具，其中最重要的工具是「**Memcheck**」，用来检查内存是否泄漏。

没有就直接安装：

```bash
yum install valgrind
```

#### 4.3.1 memcheck的基本功能

它能发现如下问题：

-   使用未初始化的内存
-   使用已经释放的内存
-   使用超过`malloc()`分配的内存
-   对于 堆栈 的非法访问
-   申请的内存是否有释放
-   `malloc/free`和`new/delete`申请和释放内存的匹配
-   `memcpy()`内存拷贝函数中 源指针和目标指针 重叠



#### 4.3.2 内存泄漏检查

所有应该释放的内存，都要释放掉，这点一定要绝对的严谨和认真。

首先，将`config.mk`的`DEBUG`设置为`true`，很多工具能输出更多调试信息。

格式如下：

```bash
valgrind --tool=memcheck 一些开关 可执行文件名
```

常用选项：

-   `--tool=memcheck`：使用valgrind工具集中的memcheck工具
-   `--leak-check=full`：完全（full）检查内存泄漏
-   `--show-reachable=yes`：显示内存泄漏的地点
-   `--trace-children=yes`：是否跟入子进程
-   `--log-file=log.txt`：将调试信息输出到`log.txt`，不输出到屏幕



例如`valgrind --tool=memcheck ./nginx`，它会输出一个报告：

```
==4039==
==4039== HEAP SUMMARY:
==4039==     in use at exit: 0 bytes in 0 blocks
==4039==   total heap usage: 7 allocs, 7 frees, 5,035 bytes allocated
==4039==
==4039== All heap blocks were freed -- no leaks are possible
==4039==
==4039== For lists of detected and suppressed errors, rerun with: -s
==4039== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

可以看到没有问题，7次分配，7个释放。



如果把`CConfig`的析构函数内容注释掉，重新执行上述命令，输出：

```
==4213==
==4213== HEAP SUMMARY:
==4213==     in use at exit: 1,100 bytes in 2 blocks
==4213==   total heap usage: 7 allocs, 5 frees, 5,035 bytes allocated
==4213==
==4213== LEAK SUMMARY:
==4213==    definitely lost: 1,100 bytes in 2 blocks
==4213==    indirectly lost: 0 bytes in 0 blocks
==4213==      possibly lost: 0 bytes in 0 blocks
==4213==    still reachable: 0 bytes in 0 blocks
==4213==         suppressed: 0 bytes in 0 blocks
==4213== Rerun with --leak-check=full to see details of leaked memory
==4213==
==4213== For lists of detected and suppressed errors, rerun with: -s
==4213== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

可以看到有7个分配，5个释放，配置项的两项都是内存泄漏，确定的内存泄漏有1100字节，共两个block。

加上`--leak-check=full`可以知道哪里泄漏了：

```
==4275== 1,100 bytes in 2 blocks are definitely lost in loss record 1 of 1
==4275==    at 0x4C2A593: operator new(unsigned long) (vg_replace_malloc.c:344)
==4275==    by 0x401519: CConfig::Load(char const*) (ngx_c_conf.cxx:87)
==4275==    by 0x4010DA: main (nginx.cxx:24)
```

从下往上看，得知，是`ngx_c_conf.cxx`的87行没有释放，这一行就是一条` LPCConfItem p_confitem = new CConfItem;`new语句。



加上`--show-reachable=yes`：

```
==4369==    at 0x4C2A593: operator new(unsigned long) (vg_replace_malloc.c:344)
==4369==    by 0x401519: CConfig::Load(char const*) (ngx_c_conf.cxx:87)
==4369==    by 0x4010DA: main (nginx.cxx:24)
```

测试发现多了0x开头的地址。

>   综合来说使用`valgrind --tool=memcheck --leak-check=full --show-reachable=yes  ./nginx`即可。



**第二种泄漏：**

如果`fopen()`打开的文件没有`fclose()`：

`valgrind --tool=memcheck --leak-check=full --show-reachable=yes  ./nginx`输出：

```bash
 ==4528== Memcheck, a memory error detector
==4528== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==4528== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info
==4528== Command: ./nginx
==4528==
程序退出，再见!
==4528==
==4528== HEAP SUMMARY:
==4528==     in use at exit: 568 bytes in 1 blocks
==4528==   total heap usage: 7 allocs, 6 frees, 5,035 bytes allocated
==4528==
==4528== 568 bytes in 1 blocks are still reachable in loss record 1 of 1
==4528==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)
==4528==    by 0x56C5C4C: __fopen_internal (in /usr/lib64/libc-2.17.so)
==4528==    by 0x4013C8: CConfig::Load(char const*) (ngx_c_conf.cxx:37)
==4528==    by 0x40109A: main (nginx.cxx:24)
==4528==
==4528== LEAK SUMMARY:
==4528==    definitely lost: 0 bytes in 0 blocks
==4528==    indirectly lost: 0 bytes in 0 blocks
==4528==      possibly lost: 0 bytes in 0 blocks
==4528==    still reachable: 568 bytes in 1 blocks
==4528==         suppressed: 0 bytes in 0 blocks
==4528==
==4528== For lists of detected and suppressed errors, rerun with: -s
==4528== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

可以看到`ngx_c_conf.cxx:37`有泄漏，这行语句是`fp = fopen(pconfName,"r");`也就是打开文件的语句。



>   偶尔用用，不要太依赖它。



### 4.4 设置可执行程序的标题（名称）

#### 4.4.1 原理和实现思路分析

本项目也仿照nginx，设置了一个主进程和多个子进程。我们要设置主进程和子进程名，区分主进程和子进程，否则都叫`nginx`。

参照eginx源码的`src/os/unix/ngx_setproctitle.c`，实现这个功能。



>   需要知道：
>
>   -   可以通过命令行向`main()`函数传递参数，`argc`是参数个数，不需要给，`argv`是字符串数组，有多个
>   -   第一个参数是执行可执行文件的命令`./nginx`，我们用ps查看也是这个进程
>   -   如果在程序中修改`argv[0]`为hello，那么ps查看进程显示的是进程
>   -   `argv`内存之后，紧接着的就是环境变量参数信息内存（是可执行程序执行时有关的所有环境变量参数信息），这一块内存可以通过一个全局的`environ[char **]`访问

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230301190332571.png" alt="image-20230301190332571" style="zoom:50%;" />

**证明：**

```cpp
    //证明argv后面就是environ
     /* points to environment, in Un*x */
	if ( 	argv + argc + 1 == environ ) 
	{
		printf("========== ptr equals environ ==========\n\n");
	}
```



**打印环境变量**

```cpp
for(int i = 0; i < argc; ++i)
{        
    printf("argv[%d]地址=%x    " ,i,(unsigned int)((unsigned long)argv[i]));
    printf("argv[%d]内容=%s\n",i,argv[i]);
}
//下边环境变量随便打两个
for(int i = 0; i < 2; ++i)
{
    printf("evriron[%d]地址=%x    " ,i,(unsigned int)((unsigned long)environ[i]));
    printf("evriron[%d]内容=%s\n" ,i,environ[i]);
}
```

输出：

```
argv[0]地址=4d1c7361    argv[0]内容=./nginx
argv[1]地址=4d1c7369    argv[1]内容=-v
argv[2]地址=4d1c736c    argv[2]内容=-s
argv[3]地址=4d1c736f    argv[3]内容=4
evriron[0]地址=4d1c7371    evriron[0]内容=LANG=zh_CN.UTF-8
evriron[1]地址=4d1c7382    evriron[1]内容=USER=root
========== ptr equals environ ==========
```

说明，它们的内存是紧紧挨着的。



<mark>所以修改标题的主要难点在于，标题太长的话，可能把`argv`甚至`environ`中的内容覆盖掉。</mark>



**实现思路：**

1.   重新分配一块内存保存环境变量`environ`，用`environ`指向这块内存，原来的就算被修改也无所谓了。
2.   再修改`argv[0]`所指向的内存，所以后面的参数是有可能覆盖的，但是无所谓，只要在修改前使用这些参数就行了



创建`app/ngx_setproctitle.cxx`文件，在其中添加`ngx_init_setproctitle()`函数和`ngx_setproctitle()`：

**app/ngx_setproctitle.cxx**

```cpp
//设置可执行程序标题相关函数：分配内存，并且把环境变量拷贝到新内存中来
void ngx_init_setproctitle()
{    
    int i;
    //统计环境变量所占的内存。注意判断方法是environ[i]是否为NULL作为环境变量结束标记
    for (i = 0; environ[i]; i++) 
    {
        //g_environlen是全局变量
        g_environlen += strlen(environ[i]) + 1; //+1是因为末尾有\0,是占实际内存位置的，要算进来
    } //end for

    //这里无需判断penvmen == NULL,有些编译器new会返回NULL，有些会报异常，但不管怎样，如果在重要的地方new失败了，无法收场，让程序失控崩溃，助你发现问题为好； 
    
    //gp_envmem是全局变量
    gp_envmem = new char[g_environlen]; 
    memset(gp_envmem,0,g_environlen);  //内存要清空防止出现问题

    char *ptmp = gp_envmem;

    //把原来的内存内容搬到新地方来
    for (i = 0; environ[i]; i++) 
    {
        size_t size = strlen(environ[i]) + 1 ; //不要忘记+1，否则内存全乱套了，因为strlen是不包括字符串末尾的\0的
        strcpy(ptmp,environ[i]);      //把原环境变量内容拷贝到新地方【新内存】
        environ[i] = ptmp;            //然后还要让新环境变量指向这段新内存
        ptmp += size;
    }
    return;
}

//设置可执行程序标题
void ngx_setproctitle(const char *title)
{
    //前提是: 所有的命令行参数我们都不需要用到了(或者被使用过了)，可以被随意覆盖了；
    //注意：我们的标题长度，不会长到原始标题和原始环境变量都装不下，否则怕出问题，不处理
    
    //(1)计算新标题长度
    size_t ititlelen = strlen(title); 

    //(2)计算总的原始的argv那块内存的总长度【包括各种参数】
    size_t e_environlen = 0;     //e表示局部变量吧
    for (int i = 0; g_os_argv[i]; i++)  
    {
        e_environlen += strlen(g_os_argv[i]) + 1;
    }

    size_t esy = e_environlen + g_environlen; //argv和environ内存总和
    if( esy <= ititlelen)
    {
        //标题太长了，argv和environ总和都存不!! 注意字符串末尾多了个 \0，所以这块判断是 <=【也就是=都算存不下】
        return;
    }

    //空间够保存标题的，够长，存得下，继续走下来    

    //(3)设置后续的命令行参数为空，表示只有argv[]中只有一个元素了，这是好习惯；防止后续argv被滥用，因为很多判断是用argv[] == NULL来做结束标记判断的;
    g_os_argv[1] = NULL;  

    //(4)把标题弄进来，注意原来的命令行参数都会被覆盖掉，不要再使用这些命令行参数,而且g_os_argv[1]已经被设置为NULL了
    char *ptmp = g_os_argv[0]; //让ptmp指向g_os_argv所指向的内存
    strcpy(ptmp,title);
    ptmp += ititlelen; //跳过标题

    //(5)把剩余的原argv以及environ所占的内存全部清0，否则会出现在ps的cmd列可能还会残余一些没有被覆盖的内容；
    size_t cha = esy - ititlelen;  //内存总和减去标题字符串长度(不含字符串末尾的\0)，剩余的大小，就是要memset的；
    memset(ptmp,0,cha);  
    return;
}
```

main函数需要在最开始就调用`ngx_init_setproctitle()`函数，同时记得`delete`，否则会出现内存泄漏。

main函数可以调用` ngx_setproctitle("nginx master");`，修改进程名。



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230301202641297.png" alt="image-20230301202641297" style="zoom:40%;" />



### 4.5 日志打印

#### 4.5.1 相关函数

出现情况需要输出日志，同时供日后运行维护人员查看、定位和解决问题。



两个新文件：`ngx_printf.cxx`和`ngx_log.cxx`，前者存放打印格式相关的函数，后者放和日志相关的函数，借鉴了nginx的源码。



-   **app/ngx_log.cxx/ngx_log_stderr()：**这个函数往屏幕上打印信息!说明这个错误特别紧急,需要终端人员立即知道！功能类似于`printf()`函数，手写一个，有利于理解`printf()`和支持任意想支持的格式化字符（使用了可变参数）
    -   这个函数调用的是`app/ngx_printf.cxx/ngx_vslprintf()`函数：
        -   上面的函数调用`app/ngx_printf.cxx/ngx_sprintf_num()`

    -   `ngx_log_errno()`函数用来解析错误码，也就是添加一个错误码对应的信息到末尾

-   代码并不复杂，但是非常繁琐



#### 4.5.2 设置时区

需要设置成CST时区，以保证日期、时间显示都正确，常见的时区：

-   PST：美国太平洋标准时间 = GMT - 8
-   GMT：格林威治平均时间 = 英国伦敦本地时间
-   UTC：通用协调时 = GMT
-   CST：东八区时间 = UTC + 8

可以使用`tz`命令修改。



#### 4.5.3 日志等级划分

在nginx中，日志被分为8个等级：

```cpp
//我们把日志一共分成八个等级【级别从高到低，数字最小的级别最高，数字大的级别最低】，以方便管理、显示、过滤等等
#define NGX_LOG_STDERR            0    //控制台错误【stderr】：最高级别日志，日志的内容不再写入log参数指定的文件，而是会直接将日志输出到标准错误设备比如控制台屏幕
#define NGX_LOG_EMERG             1    //紧急 【emerg】
#define NGX_LOG_ALERT             2    //警戒 【alert】
#define NGX_LOG_CRIT              3    //严重 【crit】
#define NGX_LOG_ERR               4    //错误 【error】：属于常用级别
#define NGX_LOG_WARN              5    //警告 【warn】：属于常用级别
#define NGX_LOG_NOTICE            6    //注意 【notice】
#define NGX_LOG_INFO              7    //信息 【info】
#define NGX_LOG_DEBUG             8    //调试 【debug】：最低级别
```

nginx中日志分了模块来处理，本项目简化了一下日志处理。

通过配置，将「严重」以下的日志过滤掉，只在日志文件中输出「0、1、2、3」四个等级的日志。

#### 4.5.4 配置文件中和日志相关的选项和相关函数



```
[log]
# 日志文件输出目录和文件名
# Log=logs/error.log
Log = logs/error.log

# 打印日志的最低等级(<= 数字)到日志文件中
# 测试时可以使用8, 运行时可以用 4
LogLevel = 8
```



-   `app/ngx_log.cxx/ngx_log_init()`函数：打开日志文件

-   `app/ngx_log/.cxx/ngx_error_core()`函数：写入日志文件间的核心函数，其实就是把`ngx_vsprintf()`的结果写入到日志文件中：

    -   调用`    ngx_log_error_core(5, 8 , "某个地方出现问题， 显示结果为: %s", "test test");`

    -   日志文件中会有：

        ```
        2023/03/04 15:12:44 [warn] 0: 某个地方出现问题， 显示结果为: test test (8: Exec format error) 
        ```



#### 4.5.5 main函数的代码顺序

有不少的代码需要在`main()`函数中执行，需要捋一捋这些代码的顺序：

1.   不需要释放资源的代码可以最先调用
2.   初始化失败，就要直接退出的代码
3.   其余的初始化函数
4.   不好归类的代码
5.   释放该释放的资源（在main函数中写一个`freeresource()`函数）



### 4.6 信号功能

我们可以用`signal()`或`sigaction()`函数来注册信号处理函数，前者已经不推荐使用了。

本项目中，信号处理相关函数在`signal/`文件夹中。





#### 4.6.1 创建worker子进程

官方的nginx中，一个master中，创建了多个worker进程。

在`proc/ngx_process_cycle.cxx/ngx_master_process_cycle()`函数中，做了如下事情：

1.   调用`ngx_setproctitle()`设置主进程的标题
2.   创建worker子进程`ngx_start_worker_processes()`
3.   父进程继续在这个函数执行，子进程不会继续执行该函数！



在`proc/proc_ngx_process_cycle/ngx_start_worker_processess()`函数中，创建了子进程：

1.   ` ngx_spawn_process()`：创建子进程分支，子进程分支进入`ngx_worker_process_cycle()`，并重新为子进程设置名字
2.   父进程分支循环n次（多少个子进程多少次），并返回 `ngx_master_process_cycle()`,



#### 4.6.2  `sigsuspend()`函数详解

master进程并不干活，`sigsuspend()`函数的作用就是阻塞在这里，不占用CPU时间，等待信号，只有收到信号才会被唤醒，所以，这个函数后面的代码才是信号的处理，这个函数把一系列原子操作融合在一起，在某些特定的时候替代`sigprocmask()`，它不能被打断。



>    `sigprocmask()`可以阻塞信号，但是存在一个问题，那么就是正在函数设置阻塞的时候，来了一个信号，那么这个信号可能会**丢**！但是`sigsuspend()`不会丢掉这个信号。



所以我们只在master进程中调用`sigsuspend()`函数，只用信号驱动就行了，但是子进程要干活。



### 4.7 日志打印重要信息谈

#### 4.7.1 `\r`和`\n`

`\r`和`\n`：

-   前者是回车（carriage return CR）符：把打印（输出）信息的位置定位到本行开头
-   后者是换行（line feed LF）符：把打印（输出）信息的位置移动到下一行（但是不会到开头）
-   所以一般把光标移动到下一行的开头：`\r\n`，但是这样特别麻烦，所以有了分歧
    -   win下：`\r\n`
    -   类Unix下：`\n`即能回车又能换行
    -   Mac：只有`\r`既能回车有能换行
    -   但现代的操作系统都能正常显示，代码中使用`\n`就行了



#### 4.7.2 `printf()`没有`\n`不能及时输出

unix上标准输入输出都是带有缓存的，一般是「行缓存」，但是Windows下没有。

对于标准输出，需要输出的数据并不是直接输出到终端上，而是首先缓存到某个地方，当遇到行刷新标志或者该缓存已满的情况下，才会把缓存的数据显示到终端设备上。

-   ANSI C中定义换行符`\n`可以认为是行刷新标志。所以，printf函数没有带`\n`是不会自动刷新输出流，直至缓存被填满。
-   除了用`\n`，还可以用`fflush(stdout)`刷新标准输出缓冲区
-   或者可以使用`setvbuf(stdout, NULL, _IONBF, 0)`将缓冲区禁止，printf就能直接输出了







### 4.8 `writhe()`函数思考



#### 4.8.1 父子进程同时写一个文件

如果多个进程同时写一个文件，例如本项目中的多个子进程不停向日志文件写入，通过`ngx_log_error_core()`调用`write()`，可能会造成日志文件的混乱吗？

>    测试了一下，10秒运行时间产生了4M的日志文件，居然没有问题，日志代码对应多进程往日志文件写时没有出现问题。



为什么能正常写入呢？

-   《APUE 第三版》第三章的文件IO的3.10-3.12，涉及到了文件共享、原子的操作以及`dup()`,`dup2()`
-   第八章8.3涉及到了`fork()`函数



>   -   父子进程的日志文件同时写日志不会出现混乱，父子进程会共享文件表项
>   -   如果有多个进程没有父子关系，可能会出现数据覆盖、混乱等情况
>   -   **open文件的时候使用了`O_APPEND`标记，保证了多个进程操作同一个文件时不会相互覆盖**
>   -   内核`write()`写入的时候是原子操作，不会被打断



#### 4.8.2 `write()`函数的写安全问题

**`write()`函数没有返回-1， 是否就是成功写入到磁盘了呢？**

答案是：<mark>不一定</mark>

-   `write()`调用返回时，内核已经将「应用程序缓冲区」所提供的内容放到了「内核缓冲区」，但是无法保证数据已经写出到其预定的目的地（磁盘），因为`write()`调用速度极快（磁盘写入是很慢的），可能没有完成实际写磁盘的工作，所以`write()`调用 **不等于** 数据真正写入到磁盘了！



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230304215155124.png" alt="image-20230304215155124" style="zoom:40%;" />

-   调用文件操作函数只是执行 逻辑操作， 而真正写入磁盘叫 「物理操作」；二者的速度有着成千上万的速度差
-   为了让快速的操作和慢速的操作协调工作，所以有了两个缓冲区：数据只是从「用户态」的应用程序缓冲区 送到了「内核缓冲区」，函数就返回了，剩下的写入磁盘工作 文件系统操作接口不会等待。「内核缓冲区」可以极大加快`write()`等函数的速度。
-   同时对于`read()`读操作，内核缓冲区还可以提供一个缓冲命中的功能（局部性原理），如果命中，就不会从磁盘中读取了，**可以大大提高性能**

从理论上讲，内核态可以任何时候写入磁盘，内核会把数据存到内核缓冲区，当积累了一定数量（或者到了一定的时间），一次写入磁盘，这就会导致一个问题，如果积累的过程中，突然断电了，此时数据就会丢失。



没有写入磁盘的脏数据相关的数据，放在` /proc/sys/vm/`目录下：

-   `dirty_expire_centisecs`：3000（us）



#### 4.8.3 掉电导致`write()`函数丢失数据

上面说了，掉电可能导致内存缓冲区没有来得及写入到磁盘，解决方法有如下几种：

-   直接IO：直接访问物理磁盘，调用`write()`直接写入磁盘，不经过「内核缓冲区」，但是「应用程序缓冲区」保留，在`open()`的时候加`O_DIRECT`标记就是直接访问磁盘，绕过「内核缓冲区」，并不推荐，需要分配512倍数的内存地址
-   `open()`文件`O_SYNC`选项：同步选项，把数据直接同步到磁盘，只针对`write()`有效，使每次write操作等待物理IO操作完成。具体来说，就是将写入「内核缓冲区」的内容立即写入磁盘，可以将掉电问题造成的损失减到最小，与`O_DIRECT`的区别就是没有绕开「内核缓冲区」。

对于上面两种方法，写入数据的时候一般大块地写，一般是 4k一次地写，都不推荐。

还有一种方法：

「缓存同步」：尽量保证缓冲数据和写到磁盘上的数据一致，它有三个函数：

-   `sync(void)`：将所有修改过的缓冲区排入写队列，然后返回，并不等待实际写磁盘操作结束，数据是否写入磁盘并没有保障，只是一种「往磁盘写入的**意图**」，比较适合写日志的操作，如果数据极为重要，不允许任何丢失
-   `fsync(int fd)`：将fd对应的文件的「块缓冲区」立即写入磁盘，并等待实际写磁盘结束返回。比较适合**极为重要的数据**，例如写入数据库的数据。推荐使用`fsync()`。
-   `fdatasync()`：类似于`fsync()`，但是只影响文件的数据部分（只需写一次，比`fsync()`快），而`fsync()`不一样，`fsync()`除了数据外，还会同步更新「文件属性」。如果不注重文件属性的话，可以调用这个函数。



>   「文件属性」：修改日期、文件大小等。

在实际使用时：

1.   for循环调用1000次write， 每次写入4字节数据
2.   1000次之后，再`fsync(fd)`，从这里就能看到`fsync()`和`O_SYNC`的区别。



#### 4.7.4 标准IO

`fopen,fclose, fread, fwrite, ffush, fseek, fgetc, getc, getchar, printf, fprintf, sprintf, scanf, fscan, sscanf`等都属于标准IO库，`fwrite()`和`write()`有什么区别？

-   `fwrite()`是标准IO库，一般在`stdio.h`（标准C语言库），`write()`是操作系统提供的系统调用，并且是原子性的。
-   在二者之间还有一层缓冲，最终都会调用系统调用，优先考虑系统调用。例如`printf()`可以用「`write()`到标准输出」代替。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230304223348624.png" alt="image-20230304223348624" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230304223440947.png" alt="image-20230304223440947" style="zoom:50%;" />



>   所有系统调用都是「原子性」的。
>
>   ​					----《Linux/UNIX系统编程手册》第13章

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230304224033487.png" alt="image-20230304224033487" style="zoom:50%;" />

可以看到不同函数工作在不同的层次。



### 4.9 守护进程功能的实现

我们拦截`SIGHUP`信号，终端窗口关闭，进程不会关闭。

nginx就是把master进程作为守护进程启动。

**守护进程：**

-   一运行就在后台



本项目创建守护进程的代码在`proc/ngx_daemon.cxx/ngx_daemon()`，按照创建守护进程的步骤进行。



**调用守护进程的时机：**

在创建worker子进程之前。



`S`表示休眠状态，没有`+`代表在后台，master进程的ppid是1，其他worker进程的ppid是master。同时TT项都为`?`，表示它们都脱离了终端，不与具体的终端挂钩了，它们的进程组都相同。

需要注意的是，虽然不与终端关联，但是如果还是写入标准错误，还是会向终端输出，关闭终端就没有了。（不占用终端，如果通过终端启动，还是能向中端输出内容）。但是如果不是通过终端启动，那么守护进程就无法在屏幕显示信息。



### 4.10 信号处理函数的进一步完善

**避免子进程被kill时变成僵尸进程🧟**

需要在父进程中处理`SIGCHLD`信号，并在信号处理函数中调用`waitpid()`解决僵尸进程的问题。



信号处理函数编写的原则：

-   代码尽可能简单，尽可能快速执行并返回
-   用一些全局量做一些标记，尽量不要调用函数
-   不要再信号处理函数中执行太复杂的代码，以免阻塞其他信号到来，甚至阻塞整个程序执行流程



在`nginx.cxx`中引入三个全局量

```cpp
//和进程本身有关的全局量
pid_t   ngx_pid;                //当前进程的pid
pid_t   ngx_parent;             //父进程的pid
int     ngx_process;            //进程类型，比如master,worker进程等
```

和在`ngx_macro.h`中引入：

```cpp
//进程相关----------------------
//标记当前进程类型
#define NGX_PROCESS_MASTER     0  //master进程，管理进程
#define NGX_PROCESS_WORKER     1  //worker进程，工作进程
//.......其他待扩展
```

用来标记父子进程。

这里借鉴了nginx的源代码，处理不同情况，`sigal/ngx_signal.cxx/ngx_signal_handler()`和`signal/ngx_signal.cxx/ngx_process_get_status()`。

>   这样kill -9掉子进程之后，子进程会直接死亡，不会变成僵尸进程。



>   事实上，真正的nginx中处理的信号众多，本项目只是简单处理了一下。
