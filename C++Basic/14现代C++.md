# 现代C++编程

## 开篇

>   C++是一门多范式的通用编程语言。

多范式，是因为 C++ 支持面向过程编程，也支持面向对象编程，也支持泛型编程，新版本还可以说是支持了函数式编程。同时，上面这些不同的范式，都可以在同一项目中组合使用，这就大大增加了开发的灵活性。因此，C++ 适用的领域非常广泛，小到嵌入式，大到分布式服务器，到处可以见到 C++ 的身影。

典型情况是，需要性能的组件用 C++ 来写，整个应用程序融合多种不同的语言。

完成同样的功能，C++ 需要的代码行数一般是 Python 的三倍左右，而性能则可以达到 Python 的十倍以上。



Bjarne 有一个洋葱理论：抽象层次就像一个洋葱，是层层嵌套的。如果想用较低的抽象层次表达较高的概念，就好比一次切过了很多层洋葱，你会把自己的眼泪熏出来的。学习应该自顶向下。



本专栏主要介绍「某个 C++ 的功能为什么存在和应该在什么情况下使用。」



>   ptr念`put`
>
>   std念`斯图的`



## 基础篇

### 01. 堆、栈、RAII：C++里该如何管理资源

#### 1.1 基本概念

**堆**，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。

C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：

-   new 和 delete 操作的区域是 free store
-   malloc 和 free 操作的区域是 heap

但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，所以一般都指「堆」



**栈**，英文是 stack，在内存管理的语境下，指的是「函数调用过程中产生的本地变量和调用数据的区域」。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。

**RAII**，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。



**RAII 依托栈和析构函数**，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。



#### 1.2 堆

 `malloc`失败返回`NULL`，下面的代码会导致队上分配内存

```cpp
auto ptr = new std::vector<int>();
```

动态内存带来的不确定性——内存分配耗时需要多久？失败了怎么办？



C++的内存管理器是什么？C++不会进行垃圾收集。

-   对于连续未使用的内存块，通常内存管理器需要将其合并成一块。
-   垃圾收集操作有很多不同的策略和实现方式



内存碎片，就是

<img src="https://static001.geekbang.org/resource/image/18/5a/1814fb6093744c64ac9d3861fb4d3a5a.png?wh=1042*744" style="zoom:50%;" />



<img src="https://static001.geekbang.org/resource/image/a7/3b/a7b72d6062c5cd798a2de991bffd713b.png?wh=1042*744" style="zoom:50%;" />

如上图所示，图1e未合并的情况就是会出现「内存碎片」。



漏掉`delete`就会「内存泄漏」，看一个例子：

```cpp

void foo()
{
  bar* ptr = new bar();
  …
  delete ptr;
}
```



1.   中间省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。
2.   在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。



#### 1.3 栈

```cpp

void foo(int n)
{
  …
}

void bar(int n)
{
  int a = n + 1;
  foo(a);
}

int main()
{
  …
  bar(42);
  …
}
```

上面代码中栈的变化可以用下图表示：

<img src="https://static001.geekbang.org/resource/image/6e/3b/6ef3d653af7fa6c9728ea4bea348093b.png?wh=1446*710" style="zoom: 40%;" />

在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。

上图每种颜色表示某个函数栈用的栈空间，这个空间称为「栈帧」（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 -fomit-frame-pointer，一般就是指栈帧。

新的函数进入后，**首先做一些必须的保存工作**，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。



栈的优点：

1.   分配/释放 简单
2.   不会出现内存碎片

对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。



**在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）**，下面的代码演示了栈展开：

```cpp

#include <stdio.h>

class Obj {
public:
  Obj() { puts("Obj()"); }
  ~Obj() { puts("~Obj()"); }
};

void foo(int n)
{
  Obj obj;
  if (n == 42)
    throw "life, the universe and everything";
}

int main()
{
  try {
    foo(41);
    foo(42);
  }
  catch (const char* s) {
    puts(s);
  }
}
```

执行结果：

```
Obj()
~Obj()
Obj()
~Obj()
life, the universe and everything
```

也就是说：「不管是否发生了异常，obj中的析构函数都会得到执行」。

C++中所有的变量缺省都是：值语义，如果不使用 * 和 & 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。

>   值语义就是一个对象被系统标准的复制方式复制后，与被复制的对象之间毫无关系，可以彼此独立改变互不影响。

除此之外，C++还有引用语义，在大部分其他语言里，访问成员只用 .，但在作用上实际等价于 C++ 的 ->。





#### 1.4 RAII

C++其实是支持将对象存储在栈上面，但是很多情况下，对象不应该存储在栈上，比如：

-   对象很大
-   对象的大小在编译时不能确定
-   对象是函数的返回值，但由于特殊原因，不能使用对象的值返回



delete空指针是合法的。

new 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 bad_alloc），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 new 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。delete 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。



在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：

-   关闭文件（fstream 的析构就会这么做）
-   释放同步锁
-   释放其他重要的系统资源

在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：关闭文件（fstream 的析构就会这么做）释放同步锁释放其他重要的系统资源。

>   就是在值语义的情况下，派生类对象赋值给基类对象，派生类独有独有的数据会丢失。但是在指针、引用情况下，由于多态性，可以将派生类对象的指针赋值给基类指针，而不会导致对象切片。
>
>   把指向堆内存的指针包裹到一个局部对象中，该对象的析构函数在析构时会 delete 自己的指针变量，这样可以通过栈展开保证new出来的内存被释放，不会遗漏。



### 02. 手写C++智能指针

智能指针内部实现了加锁，故是线程安全的，但是指针指向的资源不是线程安全的，需要访问的人处理。

### 03. 右值和移动究竟解决了什么问题



#### 3.1 左右值

<img src="https://static001.geekbang.org/resource/image/18/3c/18b692072537d4ce179d3857a8a0133c.png?wh=720*576" style="zoom:50%;" />

这些名词的字面含义：

-   lvalue是 通常**能**放在等号左边的表达式，左值
-   rvalue是 通常**只能**放在等号右边的表达式，右值
-   glvalue是 广义左值
-   xvalue是 expiring value，将亡值
-   prvalue是 pure rvalue，纯右值



只看其中两个概念：lvalue（左值）和prvalue（纯右值）：

左值lvalue是有标识符、可以取地址的表达式，常见的情况有：

-   变量、函数或数据成员的名字
-   返回**左值引用**的表达式，例如`++x`,`x = 1`, `cout << " "`。左值引用就是「左值的引用」。不像指针常量，是指向常量的指针。
-   字符串字面量，例如`"hello world"`

在函数调用时，左值可以绑定到左值引用的参数，如`T&`。一个常量只能绑定到常左值引用，如`const T&`。

>   个人感觉：《C++Primer》中的「左值」和「右值」更像是lvalue和prvalue。

纯右值是没有标识符、不可以取地址的表达式，一般称为「临时对象」。最常见的情况有：

-   返回非引用类型的表达式，如`x++`,`x + 1`,`makr_shared<int>(42)`
-   除字符串字面量之外的字面量，如`42`,`true`
-   匿名对象`new Person()`



在C++11之前，右值可以绑定到**常左值引用的参数**，如`cosnt T&`，但不可以绑定到「**非常左值引用**」，如`T&`。在C++11开始，C++语言里多了一种引用类型：「右值引用」。右值引用的形式是`T&&`，比左值引用多一个`&`符号，和左值引用一样，可以用`const`和`volatile`来进行修饰，但一般来说，我们不会用`const`和`volatile`来修饰右值。



>   类型是「右值引用」的变量是一个左值。这点有些反直觉，但是需要注意它本质还是一个变量，有标识符，有地址，所以是左值。

>   右值的引入目的是减少对象构造造成的性能损耗。 对象传参使用引用传递尽量避免值传递，目的减少对象构造。 指针传参并没有这个问题。所以不在乎左值/右值传参。

`std::move()`将一个「左值引用」强制转换为「右值引用」，而不改变其内容。

下面的代码是等价的：

```cpp
//ptr是一个shape类型的智能指针
std::move(ptr);
static_cast<smart_ptr<shape>&&> (ptr);
```

那么：

```cpp
smart_ptr<shape> ptr2 = std::move(ptr);
```

就会调用`T&&`版本的构造函数。

我们可以把`std::move(ptr)`看作一个有名字的右值，为了和无名的纯右值prvalue区别，C++目前称这种表达式为xvalue：

-   xvalue不能取地址，这点和prvalue相同
-   但是它有标识符

>   值类别（value category）和值类型（value type）：
>
>   -   前者代表左值、右值相关的概念
>   -   后者表示引用、结构、联合、类等。只有引用和指针才是引用类型。
>   -   在Java中，原生类型是值类型，类属于引用类型
>   -   在Python中，一切类型都是引用类型



<img src="https://static001.geekbang.org/resource/image/03/5a/036cc6865a9623a48918b504e408945a.png?wh=768*830" style="zoom:50%;" />



移动语义使得C++利返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。所有现代C++的标准容器都针对移动进行了优化。



#### 3.2 生命周期和表达式

一个变量的生命周期在超出作用域时结束。如果一个变量代表一个对象，当然这个对象的生命周期也在那时结束。那临时对象（prvalue）呢？在这儿，C++ 的规则是：一个临时对象会在包含这个临时对象的完整表达式估值完成后、按生成顺序的逆序被销毁，除非有生命周期延长发生。

```cpp
process_shape(circle(), triangle());
```

上面的代码生成了一个临时对象，一个circle和一个triangle，它们会在`process_shape()`执行完成并生成结果后被销毁。

>   如果一个 prvalue 被绑定到一个引用上，它的生命周期则会延长到跟这个引用变量一样长。

销毁`circle()`和`triangle()`的先后顺序没有明确要求。

```cpp
result&& r = process_shape(circle(), triangle());
```

而上面的代码中，这两个临时对象的析构被延长到了函数结束时。

**需要注意的是，上述生命延长规则只对prvalue有效，对xvalue无效。**例如：

```cpp
result&& r = std::move(process_shape(circle(), triangle()));
```

这时两个临时对象外加`r`都会在这条语句之后析构。所以r指向的对象已经不存在了。



#### 3.3 move的意义

在使用容器类的情况下，移动更有意义：

```cpp
string result = string("Hello, ") + name + ".";
```

在C++11之前，会引入很多额外的开销：

1.   调用构造函数`string(const char*)`，生成「临时对象1」；字符串`"Hello, "`被复制 1 次。
2.   调用 `operator+(const string&, const string&)`，生成「临时对象 2」；字符串`"Hello, "`被复制 2 次，变量`name`被复制 1 次。
3.   调用 `operator+(const string&, const char*)`，生成对象 3；`"Hello, "`被复制 3 次，`name` 复制 2 次，`"."` 复制 1 次。
4.   假设返回值优化能够生效（最佳情况），对象 3 可以直接在 result 里构造完成。
5.   「临时对象 2 」析构，释放指向 `string("Hello, ") + name` 的内存。
6.   「临时对象 1」 析构，释放指向 `string("Hello, ")` 的内存

但是从C++11开始，执行流程如下：

1.   调用构造函数 `string(const char*)`，生成「临时对象 1」；`"Hello, "`被复制 1 次。
2.   调用 `operator+(string&&, const string&)`，直接在「临时对象 1」 上面执行追加操作，并把结果移动到「临时对象 2」；`name` 复制 1 次。
3.   调用 `operator+(string&&, const char*)`，直接在临时对象 2 上面执行追加操作，并把结果移动到 result；"." 复制 1 次。
4.   临时对象 2 析构，内容已经为空，不需要释放任何内存。
5.   临时对象 1 析构，内容已经为空，不需要释放任何内存。



>   移动语义使得在 C++ 里返回大对象（如容器）的函数和运算符成为现实，因而可以提高代码的简洁性和可读性，提高程序员的生产率。
>
>   所有的现代 C++ 的标准容器都针对移动进行了优化。



#### 3.4 实现移动

-   类有分开的拷贝构造和移动构造函数，（除非只支持移动，不支持拷贝，例如`unique_ptr`
-   有`swap()`成员函数
-   一个全局的`swap()`成员函数

移动构造函数应当从另一个对象获取资源，清空其资源，并将其置为一个可析构的状态。



#### 3.5 引用坍缩和完美转发

对于类型`T`，左值引用是`T&`，右值引用是`T&&`，但是：

1.   看到`T&`，一定是左值引用
2.   看到`T&&`，不一定是右值引用

关键在于，在有模板的代码里，对于类型参数的推导结果可能是引用。我们可以略过一些繁复的语法规则，要点是：

1.   对于 `template typename<T> foo(T&&)` 这样的代码，如果传递过去的参数是左值，T 的推导结果是左值引用；如果传递过去的参数是右值，T 的推导结果是参数的类型本身。
2.   如果 T 是左值引用，那 T&& 的结果仍然是左值引用——即 type& && 坍缩成了 type&。
3.   如果 T 是一个实际类型，那 T&& 的结果自然就是一个右值引用。

，右值引用变量仍然会匹配到左值引用上去。

因为在 T 是模板参数时，T&& 的作用主要是保持值类别进行转发，它有个名字就叫“转发引用”（forwarding reference）。因为既可以是左值引用，也可以是右值引用，它也曾经被叫做“万能引用”（universal reference）。

>   ，对于一个函数，如果形参是右值引用，但在函数体内，这个“右值引用”实际上是一个左值变量，然后函数内再有一个函数传入这个参数，那么就会调用对应的左值引用版本，而完美转发的意义就相当于做一次类型转换，让这个参数保持一开始传入时的左值右值类别。





### 04 容器

#### 4.1 string

`string`是`basic_string`模版对于`char`类型的特化，可以认为是一个只存放字符char类型数据的容器。真正的容器与string的最大不同是里面可以存放任意类型的对象。

`swap()`成员函数可以和另外一个容器交换内容。

在`string`下，`end()`指向`\0`字符。

<img src="https://static001.geekbang.org/resource/image/ee/62/eec393f933220a9998b7235c8acc1862.png?wh=1298*450" style="zoom:50%;" />

`string`和`char *`的区别：

-   `string`负责自动维护字符串的生命周期
-   `string`支持字符串的拼接、查找
-   `string`支持从`istream`安全读入字符串(`getline()`)
-   `string`的`c_str()`成员函数可以转换成`const char*`
-   `string`支持到数字的互转（`stoi`和`to_string`)



使用`string`的成员函数：

-   如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 string 作为参数类型（自动拷贝）。
-   如果需要改变调用者的字符串内容，使用 string& 作为参数类型（通常不推荐）。



#### 4.2 vector

动态数组，vector允许：

-   使用 data 来获得指向其内容的裸指针（同 string）
-   可以使用 emplace 在指定位置构造一个元素
-   可以使用 emplace_back 在尾部新构造一个元素



尽量使用`emplace_back()`

#### 4.3 deque

double-endend queue。

#### 4.4 list和forward_list

在元素大小较小的情况下，forward_list 能节约的内存是非常可观的。在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。



#### priority_queue

容器适配器，用到了比较函数对象。

如果使用`less`作为缺省Compare模版参数，最大的值会出现在容器顶部，这似乎有点反直觉。



#### 无序关联容器

#### array

C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置。

如果数组大小固定，而且比较小的话，可以使用array，array保留了数组在栈上分配的特点。



### 03. 迭代器和新for循环

迭代器是一个很通用的概念，并不是一个特定的类型。「遍历」是比「迭代」更好的用词。

从C++17开始，`begin()`和`end()`可以返回不同的类型，这带来了更大的灵活性和更多的优化可能性。



不同的迭代器：

1.   前向迭代器
2.   前向迭代器
3.   双向迭代器
4.   随机访问迭代器
5.   连续迭代器（C++20）：vector和array



迭代器的基本要求：

-   对象可以被拷贝

迭代器通常是对象，但是指针也是迭代器。



输出迭代器，

对于输出迭代器，可以用`*`或`++`负责读取，常用的思路是后者。
