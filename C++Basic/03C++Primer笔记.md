# 《C++ Primer》笔记

>   2021.11.1
>   写在前面：
>
>   「欲速则不达」
>
>   「勿在浮沙筑高台」
>
>   本文基于《C++ Primer》中文第五版。
>
>   啃这本书是一件较为痛苦😖的事情，但是这本书写的特别详细，给基础有很大的巩固，之前很多内容都是一知半解，能用就行，看了此书之后有种「知其所以然」😄的感觉。

>    2022\.1\.2 
> 
>    关于记笔记的方式：
>
>   -   对于能理解的内容，就按我的理解方式写下
>   -   对于暂时不能理解的内容，就把书上的原文和代码摘录
>   -   如果对于某个知识点有了新的理解随时补充
>
>   所以笔记中的内容夹杂了书面语和口语。
>
>   https://cplusplus.com
>
>   https://zh.cppreference.com/w/

## 2. 变量和基本类型

>   前言：
>
>   第2章的内容非常基础，但是很多概念，很多内容都是本人不熟悉的。🤫

----------



### 2.2 变量

#### 2.2.2 变量声明和定义的关系

C++的声明和定义是分开的。「**声明**」(declaration)是使得名字为程序所知，一个文件如果想使用别处定义的名字必须包含对那个名字的声明；而「**定义**」(definition)负责创建与名字关联的实体：

-   变量声明规定了变量的类型和名字
-   定义额外申请**存储空间**，也有可能为变量赋一个初始值
-   如果想声明一个变量而不定义它，需要关键字`extern`，并且不要显式初始化变量：

```cpp
/*  
 *  Description : 变量的声明与定义
 *  Created by 旋风冲锋龙卷风 on 2022/11/26 00:42
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

extern int i = 1;//在函数体外可以初始化extern变量,但是这句话就不再是声明,而是定义

void test01()
{
    extern int i; //声明i而非定义i
    extern int i; //变量可以重复声明
    int j; //声明并定义i,只能定义一次
    // extern int i  = 1; //在函数体内不能初始化extern的变量,会引发错误
    
}

int main()
{

    return EXIT_SUCCESS;
}
```

声明和定义的区别看似微不足道。但是如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在一个文件中，而其他用来该变量的文件必须对其进行声明，但是绝不能重复定义。

**关键概念：静态类型**

>   C++是一种**静态类型**(statically typed)语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为**类型检查**(type checking)。
>
>   对象的类型决定了对象所能参与的运算。在C++中，编译器负责检查数据类型是否支持将要执行的运算，如果试图执行类型不支持的运算，则编译器会报错并不会生成可执行文件，所以需要在使用变量前声明其类型。



#### 2.2.3 标识符

**C++的标识符(identifier)**

-   字母数字下划线
-   字符或下划线开头，但是不能**连续两个下划线**或者**下划线连大写字母**
-   定义在函数体外的标识符不能以下划线开头
-   不能用关键字做标识符

值的注意的是,`_`单下划线可以做变量：

```cpp
int main()
{
    int _ = 1;
    cout << _ << endl;
    return EXIT_SUCCESS;
}
```



#### 2.2.4 名字的作用域

这里的名字指实体，它包括变量、函数、类型等。

例如，`main`定义于所有的`{}`外，它和其他大多数定义在函数体外的名字一样拥有「**全局作用域**」(global scope)，也就是声明后全局都可用。一般函数体内的名字有块作用域（for语句也包含在内）

**嵌套作用域：**

作用域是能彼此包含的，被嵌套的叫做「内层作用域」，包含它的称为「外层作用域」，内层作用域可以访问外层作用域声明的名字，也可以对外层作用域已有的名字进行覆盖。

```cpp
/*  
 *  Description : 名字的作用域
 *  Created by 旋风冲锋龙卷风 on 2022/11/26 01:07
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>


int reused = 42; //定义一个全局作用域的变量reused

int main()
{
    int unique = 0; //定义一个块作用域的变量unique
    // 42 0
    std::cout << reused << " " << unique << std::endl;

    //新建局部变量reused覆盖全局变量
    //可以是不同类型
    double resued = 1.1;
    std::cout << resued << " " << unique << std::endl;

    //如果被覆盖了还想访问全局变量,需要使用::显式访问
    std::cout << ::reused << std::endl;

    return EXIT_SUCCESS;
}
```

>   访问有就近原则，但是想访问全局变量可以用`::`操作符

### 2.3 复合类型

「**复合类型**」(compound type)是指基于其他类型定义的类型 ，C++有几种复合类型，本章介绍：「引用」和「指针」

声明语句：

-   一个「数据类型」和一个紧随其后的「声明符列表」组成，声明符命名了一个变量，并指定该变量与类型有关的某种类型（其实就是带`*/&`）

#### 2.3.1 引用

>   C++11新增了所谓「右值引用」(rvalue reference)，一般说引用都是指的「左值引用」(lvalue reference)

语法很简单，就是将声明符写成`&d`的形式，d是声明的变量名。引用使用时需要注意：

1.   引用必须初始化
2.   引用不是对象，它是一个已存在的对象的别名，所以不能定义引用的引用
3.   引用会与这个**对象绑定(bind)**，并且无法重新绑定到另一对象
4.   允许在一条语句中定义多个引用
5.   引用类型的初始值必须是对象，而不能是字面量，同时引用和它指向的对象类型要相同
6.   修改引用等于修改原对象

#### 2.3.2 指针

**指针**(pointer)是指向(point to)另外一种类型的复合类型，它与引用一样实现了对对象的间接访问，指针也必须指向同类型的对象，但它与指针不同：

-   指针是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期可以指向不同的对象
-   指针在定义时可以不初始化。与其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

**指针的值**，也就是地址，应该是下面四种状态之一：

1.   指向一个对象
2.   指向紧邻对象所占空间的下一个位置
3.   空指针，意味着指针没有指向任何对象
4.   无效指针，也就是上述情况之外的其他值
     -   需要注意的是，试图拷贝或者其他方式访问无效指针的值都会引发错误。编译器不会检查这种类型的错误，这和试图使用未初始化的变量是一样的。

**空指针：**

空指针的生成有下面三种方法

-   `int *p1 = nullptr;` //等价于 int *p1 = 0;
    -   这是C++11新引入的方法
    -   **推荐使用这种方法**
-   `int *p2 = 0;`//直接将p2初始化为字面常量0
-   `int *p3 = NULL`//等价于`int *p3 = 0`
    -   `NULL`是一个名为NULL的「预处理变量」。

**建议初始化所有指针**

**`void*`指针：**

`void*`是一种特殊类型的指针，可以存放任意对象的地址，`void*`也存放一个地址，但我们不清楚这个地址种是什么类型。所以也无法访问`void*`类型的指针。

#### 2.3.3 理解复合类型的声明

复合类型不是指类，而是某个类型+指针/引用。

首先本书探讨了指针和引用的两种写法：

```cpp
int* p; 
int *p;
```

**没有对错，坚持一种即可。本书使用第二种。**因为第一种容易被误导，`*`是用来修饰变量名的。



**指针指针的引用：**

>   引用本身不是一个对象，所以不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用。

```cpp
/*  
 *  Description : 指向指针的引用
 *  Created by 旋风冲锋龙卷风 on 2022/11/26 16:12
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    int i = 42;
    //p是一个int类型的指针
    int *p;
    //r是一个对指针p的引用
    int *&r = p;

    r = &i;//令p指向i
    *r = 0;//令i = 0.
    // 解引用r的到i,r就相当于i的别名! r是一个指针,当然能解引用,不要被误导,要理解r的本质

    //i = 0
    cout << i << endl;
}

void test02()
{
    // ip是指针,ip2是int类型对象
    //*是修饰ip的，不要被误导
    int *ip, ip2;
    int* i, j;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

面对一个复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。例如，对于上文的`int *&r`，离变量名`r`最近的是`&`，说明`r`是一个引用，声明符的其余部分用来确定`r`引用的类型是什么，`int *`说明`r`引用的是一个int类型的指针，直接对`r`操作就相当于对指针操作，因此`r`可以被解引用。



### 2.4 `const`限定符

`const`对象创建后不能修改，所以必须初始化：

-   可以将`const`对象拷贝给别的对象
-   `const`对象默认仅在文件内有效
    -   如果想在不同文件中使用同一个`const`变量，需要加`extern`关键字声明

#### 2.4.1 `const`的引用

可以把引用绑定到`const`对象上，就像绑定到其他对象上引用，称为「对常量的引用」(reference to const)，简称「常量引用」，它与普通引用有如下不同：

-   常量引用可以被初始化为任意表达式
-   常量引用可以绑定到另一种类型，也就是说常量引用在绑定的过程中可以进行类型转换
    -   但是这种情况需要注意，转换的过程中，产生了一个临时变量，常量引用引用的是这个临时变量，因此修改原来的变量不会修改常量引用。

除此之外，常量引用可以引用一个非`const`的对象，但是这样如果非`const`的对象被修改，常量引用的值也会被修改，因为引用相当于变量的别名，是同一块内存。但是不能修改常量引用。



```cpp
/*  
 *  Description : const的引用, 简称为"常量引用"
 *  Created by 旋风冲锋龙卷风 on 2022/11/26 23:28
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//常量引用可以被初始化为任意表达式
void test01()
{
    int i = 42;
    const int &r1 = i;
    i = 45;
    //r1 = 3;//但是r1不能修改
    //输出修改后的45
    cout << r1 << endl;
    const int &r2 = 42;
    const int &r3 = r1 * 2;

    //int &r4 = 3;//报错,非常量引用不能绑定到字面值
    int &r5 = i;
    int &r6 = r5;
    //int &r7 = r5 *2;//错误,非常量引用r7不能绑定到字面值和表达式
}

//常量引用可以绑定到另外一种类型
void test02()
{
    double dval = 3.14;
    const int &ri = dval;
    //输出3
    cout << ri << endl;
    //修改dval并不会改变ri的值
    //因为ri绑定的已经不是dval
    dval  = 4;
    cout << ri << endl;
}

void test03()
{
    int i = 42;
    int &r1 = i;
    const int &r2 = i;
    r1 = 0;
    //r2也被修改,因为r2是i的别名(引用)
    cout << r2 << endl;
}

int main()
{
    test03();
    return EXIT_SUCCESS;
}
```



#### 2.4.2 指针和`const`

要想存放常量对象的地址，必须使用「指向常量的指针」，是否可以叫做「常量指针」存疑，但一定不是「指针常量」，还需要区分「指向常量对象的指针常量」：

```cpp
/*  
 *  Description : 指针和const
 *  Created by 旋风冲锋龙卷风 on 2022/11/27 01:10
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//要想存放常量对象的地址,必须使用指向常量的指针
void test01()
{
    const double pi = 3.14;
    //double *ptr = &pi;//报错, ptr是一个指向普通对象的指针
    const double *ptr2 = &pi; //正确, ptr2是一个指向double常量的指针
    //*ptr2 = 1.1;//报错, 不能给*ptr2赋值,也就是不能修改ptr2指向的对象的值,不管这个对象是不是const
    double dval = 3.14;
    ptr2 = &dval;//正确,ptr2可以修改,但是不能通过ptr2修改dval的值

}

//int *const 和 const int* 和 const int *const
//指向int对象的常量指针 和 指向常量int对象的指针 和 指向常量int对象的常量指针
//可以修改int对象,不能修改指针指向
//可以修改指针指向,不能修改const int
//既不能修改指针指向,又不能修改const int
//其实引用就相当于一个常量指针,能修改引用的对象的值,但是不能改变引用绑定的对象
void test02()
{
    int i = 0;
    int *const pi = &i; //正确,定义了一个常量指针,pi不能修改了,但是*pi可以修改s
    const double i2 = 3.14;
    const double *const pi2 = &i2;//指向常量对象的常量指针
}

//指向常量的指针可以指向普通对象
void test03()
{
    int i = 0;
    const int *pi = &i;
}

int main()
{

    return EXIT_SUCCESS;
}
```

>   对于一个很长的声明，最好从右向左分析，这样能快速区分「常量指针」`*const`和「指针常量」`const *`。
>
>   同时，指向常量的指针或者引用，不过只是指针或者引用“自以为是”罢了，他们自以为自己指向了常量，所以不能通过他们修改所 指向/引用 对象的值。

const int a代表常量对象，不能修改对象的内容，

所以int *const a应该称为常量指针，从右往左分析。

#### 2.4.3 顶层`const`与底层`const`

>   个人认为：这部分是这一章的重中之重，来回看了几遍。

------



上面的「指向非常量对象的常量指针」和「指向常量的指针」又被称为「**顶层`const`**」(top-level const)和「**底层`const`**」(low-level const)：

-   顶层`const`表示任意对象是一个常量，注意指针是对象而引用不是，所以引用没有顶层`const`
-   底层`const`表示**指针或者引用等复合类型**所指向的对象是一个常量，普通数据类型没有底层`const`
-   右边是顶

一般来说，顶层`const`指针可以修改指向的对象的内容，但是不能改变所指向的对象，同时可以作为赋值的右值。

但是，底层`const`需要注意，要满足以下条件之一：

1.   拷入和拷出的对象具有相同的底层`const`资格
2.   两个对象的数据类型可以转换
     -   注意：「非常量」可以转换为「常量」，反之不行！
     -   这里的「非常量」和「常量」指的是底层`const`
     -   也就是指针常量不能转换为指针非常量，详细可以看下面代码的`test02`

>   通过上面的条件，可以知道：
>
>   1.   普通的`int &`不能绑定到`int`常量，`int *`不能指向`int`常量
>   2.   `const int &`可以绑定到普通`int`对象，`const int *`能指向普通`int`对象

```cpp
/*  
 *  Description : 顶层const与底层const
 *  Created by 旋风冲锋龙卷风 on 2022/11/27 15:35
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    int i = 0;
    int *const p1 = &i;//顶层const
    const int ci = 42;// 底层const
    const int *p2 = &ci;// 底层const
    const int *p3 = &i;// const int *可以指向普通int对象
    const int &r1 = i;
}

void test02()
{
    int i = 0;
    const int v2 = 0;
    int v1 = v2;
    int *p1 = &v1, &r1 = v1;
    const int *p2 = &v2, *const p3 = &i, &r2 =v2;


    r1 = v2;//正确,虽然r1是普通的int &, v2是const对象,但是这是赋值语句
    //如果写成 int &r1 = v2;则错误,这是初始化绑定,不能将int &绑定到const int
    //p1 = p2;// 错误不能将指向常量的指针赋值给指向普通int类型的指针,也就是指针常量不能转换为非常量
    p2 = p1;//正确,非常量可以转换为常量
    //p1 = p3;//错误,理由 同上,但是需要注意顶层const对于拷出没有影响
   p2 = p3;//正确, 顶层const对于拷入和拷出没有影响,只是不能再修改p3

}

int main()
{

    return EXIT_SUCCESS;
}
```



#### 2.4.4 `constexpr`和常量表达式

「**常量表达式**」(const expression)是指值不会改变并且在编译过程中就能得到计算结果的表达式，例如「字面值」，用常量表达式初始化的`const`对象也是常量表达式。

但是在一个复杂系统中，几乎不能分辨一个初始值到底是不是常量表达式，因此C++11新标准规定，允许将变量声明为`constexper`类型一边由编译器来验证变量的值是否是一个常量表达式。声明为`constexpr`的变量一定是一个常量，而且必须用常量表达式初始化，同时允许定义一种特殊的「`constexpr`函数」，这种函数足够简单以使编译时就能得到计算结果，这样就可以用「`constexpr`函数」去初始化「`constexpr`变量」，同时声明`constexpr`时用到的类型必须是「字面值」类型。

**字面值类型：**

-   算术类型
-   引用
-   指针
-   自定义类、string类不属于字面值类型

```cpp

void test01()
{
    //下面三个都是常量表达式
    const int max = 20;
    constexpr int mf = max;
    constexpr int limit = mf + 1;
    //constexpr string s = "adb";//string不属于"字面值类型",不能被定义为constexpr
    
}
```



**指针和`constexpr`:**

如果`constexpr`声明中如果定义了一个指针，那么这个`constexpr`仅对指针有效，对指针所指的对象无效，也就是说`constexpr`将这个对象置为了「顶层`const`」。

```cpp

//b c定义在函数体外
constexpr int b = 1000;
int c = 10;
void test02()
{
    const int*p = nullptr;// p是一个指向整型常量的指针
    constexpr int *q = nullptr; //q是一个指向整数的常量指针
    int a = 100;
    constexpr const int *q1 = &b; //常量指针指向整形常量b
    constexpr const int *p1 = &c; //常量指针指向整数c，非常量转换成常量
    constexpr int* p2 = &c;
}
```



### 2.5 处理类型



#### 2.5.1 类型别名

「**类型别名**」(type alias)，顾名思义，就是给类型取别名。有两种方法定义类型别名：

1.   `typedef`关键字
2.   C++11新增了用`using`取别名

需要注意的是，当别名是指针或者引用类型，再加`const`是用来修饰整个别名的，**不能直接把别名替换成它本来的样子**

```cpp
/*  
 *  Description : 类型别名
 *  Created by 旋风冲锋龙卷风 on 2022/11/27 20:52
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Person
{

};
//typedef和using的方法
void test01()
{
    typedef double wages;// 定义wages为double的别名
    typedef wages a, *p;//wages相当于double
    //对于自定义类型也是可以的
    using P = Person;
    wages b;// 使用时typedef可以省略
    P p1;
}

//需要注意的事项
void test02()
{
   typedef char *pstring;//pstring是char*的别名
   const pstring ctr = 0;//ctr是一个常量指针,这是个顶层const,而不是底层,不能直接用char* 替换pstring
   *ctr = 'a';//*ctr可以修改
   //ctr = 0;//ctr不能修改
}

int main()
{

    return EXIT_SUCCESS;
}
```

​    

#### 2.5.2 `auto`类型说明符

C++11新标准引入了`auto`类型说明符，用它能让编译器去分析表达式所属的类型，显然`auto`定义的变量必须有初始值。

使用`auto`也能再一条语句中声明多个变量，但是这些变量的初始基本数据类型必须一致。



编译器推断出来的`auto`类型会适当改变结果以使其更符合初始化规则：

1.   当引用被用作初始值时，编译器推断的`auto`会是引用对象的类型，而非引用
2.   `auto`会忽略顶层`const`，但是会保留底层`const`

```cpp
/*  
 *  Description :
 *  Created by 旋风冲锋龙卷风 on 2022/11/27 21:14
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//引用与auto
void test03()
{
    int i = 0, &r = i;
    auto a = r; //a是一个整数
}

//指针与auto
void test04()
{
    int i = 0;
    const int ci = i, &cr = ci;
    auto b = ci; //ci是一个整数,顶层const被忽略
    auto c = cr; //c也是一个整数
    auto d = &i; //d是一个int指针
    auto e = &ci;//e也是也个指针,但是指向常量,底层const不会被忽略
}
int main()
{

    return EXIT_SUCCESS;
}
```

>   切记：符号`&`和`*`只从属于某个声明符，而非基本数据类型的一部分。

#### 2.5.3 `decltype`类型指示符

C++引入了第二种类型说明符`decltype`，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，却不计算表达式的值。

`decltype`与`auto`在处理顶层`const`和引用的时候不同：

-   如果`decltype`使用的表达式是一个变量，则`decltype`返回该变量的类型（包括顶层`const`在内）
-   `decltype`的结果也可以是引用类型，但是对于表达式需要特别注意。
-   `decltype`中表达式的内容是解引用操作，那么将得到引用类型
-   如果`decltype`的表达式用`()`包围，例如`decltype((v))`则**必定**得到引用类型
-   赋值也是会产生引用的表达式，引用的类型就是左值的类型
    -   如果`i`是`int`，则`i=x`这个表达式会产生`int &`类型
-   `decltype`可以不初始化，这由类型决定，例如引用必须初始化

```cpp
/*  
 *  Description : decltype的使用
 *  Created by 旋风冲锋龙卷风 on 2022/11/27 21:23
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

int f()
{
    return 0;
}

void test01()
{
    decltype(f()) sum = 2;//sum的类型就是f函数的返回值,编译器不会调用f,只是
}

void test02()
{
    int a;
    decltype(a)  x;
    int i = 42, *p = &i, &r = i;
    int &j = i;
    decltype(r) y = i; // y是int&
    decltype(r + 1) b;//b是int类型
    decltype(*p) z = i; //z是引用类型,必须初始化
    decltype((i)) z1 = i;// 由于加了(),z1也是引用类型,必须初始化

}

int main()
{

    return EXIT_SUCCESS;
}
```



**2.5.3练习：**

```cpp
void test03()
{
    int a = 3, b = 4;
    decltype(a) c = a;//c是int类型,c不会绑定到a,c与a是两块内存
    decltype((b)) d = a;//d是int &, d会绑定a
    cout << ++c <<endl; //4
    cout << ++d <<endl;//4
}

void test04()
{
    int a = 3, b = 4;
    decltype(a) c;//int,其实可以不初始化
    decltype(a = b) d = a; //int&,必须初始化
}
```

### 2.6 自定义数据结构

>   这一节主要讲了`struct`关键字，比较熟悉了，在这里记录下头文件相关的一些不熟悉的概念。

#### 2.6.1 预处理器

确保头文件多次包含仍然能安全工作的常用技术是「**预处理器**」(preprocessor)，预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序，例如`#include`，当预处理器看到`#include`标记的时候会用指定的头文件内容代替`#include`

另外一个常用预处理功能是「**头文件保护符**」(header guard)，头文件保护符依赖于预处理变量。预处理变量有两个状态：已定义和未定义。`#define`指令把一个名字设置为预处理变量，`#ifndef`当且仅当变量未定义时为真，一直会执行到`#endif`指令。

```cpp

#ifndef XXX
#define XXX

#endif //XXX

```

使用这个能有效解决重复包含问题，**建议所有的头文件都加上！**

## 3. 字符串、向量和数组

>   第三章主要介绍了string、vector和数组，这一块的内容还是比较熟悉，笔记主要是查漏补缺补充一些不知道的知识点。😄

### 3.1 `using`声明

`using`声明不仅可以声明命名空间，例如：

```cpp
using namespace std;
```

还可以用来声明命名空间的名字：

```cpp
using std::cin;
using std::cout;
using std::endl;
```

以及，**不要在头文件中包含`using`声明**

### 3.2 标准库类型`string`

#### 3.2.1 定义和初始化`string`对象

`string`对象的初始化：

```cpp
void test01()
{
    string s1; //默认初始化,s1是一个空字符串, 如果不使用=则执行直接初始化
    string s2 = s1;// s2是s1的副本,如果使用了=,则执行拷贝初始化
    string s3 = "abc"; //拷贝初始化
    string s4("bcd"); //直接初始化
    string s5(10, 'c');//直接初始化, 10个c

    cout << s5[9] << endl; //string对象可以用[]随机访问
}
```

使用超出范围的下标将引发不可预知的效果。

**字面值和`string`相加：**

```cpp
//string 和 字面量 相加: 必须满足每个加法运算符+两侧运算对象有一个是string
void test02()
{
    string s1 = "hello";
    string s2 = "world";
    string s3 = s1 + ", " + s2; //正确,
    //string s4 = "hello" + ", " + s2;// 错误, 第一个+两边都是字面量
    //C++字符串字面值并不是标准库类型的string的对象
}
```

>   切记：C++字符串字面值与string是不同的类型



#### 3.2.3 处理`string`对象中的字符

如果我们需要改变某个字符的特性，可以使用`cctype`头文件中的标准库函数来处理这部分工作，下面是几个例子：

```cpp
isalnum(c) //当c是字母或数字时为真
isalpha(c) //当c时字母时为真
tolower(c)//如果c时大写字母，则输出对应小写字母；否则原样输出c
toupper(c) //当c是小写字母时，输出对应大写字母；否则原样输出c
```

还有很多判断的函数，不一一列举了。



>   关于C++版本的C标准库头文件
>
>   C语言中的头文件一般是`name.h`，C++中为`cname`，一般C++程序都用C++的头文件。



### 3.3 `vector`

在早期版本的C++标准中，如果`vector`的元素还是`vector`(或其他模版类型)，则必须在`>`之前加一个空格：

```cpp
//早期版本,多一个空格
vector<vector<int> >
//C++11
vector<vector<int>>
```



#### 3.3.1 定义和初始化`vector`对象

`vector`有很多初始化的方法，详情可见[02C++提高](02C++提高.md)中的3.2`vector`部分。这里需要注意一个细节，那就是初始化中的`()`与`{}`：

```cpp
void test01()
{
    vector<int> v1(10); //v1有10个元素, 每个值都是0
    vector<int> v2{10}; //v2有1个元素,该元素的值是10

    vector<int> v3(10, 1); //v3有10个元素, 每个值多是1
    vector<int> v4{10, 1}; //v4有2两个元素, 值分别是10 和 1
    
}

```

圆括号第一个参数用来构造「construct」`vector`对象，代表该对象的容量，第二个参数（如果有）则是元素的默认值。

花括号则是代表用列表初始化「list initialize」 `vector`对象，花括号内的值都是元素值的初始列表。

但是！！！**如果无法执行花括号的列表初始化时，编译器会考虑其他初始化方式：**

```cpp
void test02()
{
    vector<string> v5{"hi"}; //正确,列表初始化
    //vector<string> v6("hi"); //不能用字面值来构造
    vector<string> v7(10); //正确
    vector<string> v8(10, "hi"); //正确
    vector<string> v9{10, "hi"}; //正确,当无法执行列表初始化, 会考虑其他方式处理
}
```



#### 3.3.3 其他`vector`操作

详情可见[02C++提高](02C++提高.md)中的3.2`vector`部分，这里有一个细节是：

-   不能通过下标形式**添加**元素



### 3.4 迭代器介绍

所有标准库容器都可以使用「**迭代器**」(iterator)，但是其中只有少数几种菜同时指出下标运算。严格来说，`string`对象不属于容器类型，但是`string`不仅支持下标运算，还支持迭代器。



#### 3.4.1 使用迭代器

与指针不同，获取迭代器不是使用取地址符，而是使用返回迭代器的成员函数。如果不清楚迭代器的准确类型，可以使用`auto`关键字。 

**迭代器的`++`递增操作符：**

-   整数的++是在整数值上“+1”，而迭代器的++是“向后移动一个位置”。（这里书中P96写的是“向前移动一个位置”，但是我的理解还是向后，因为begin和end函数。
-   大多数迭代器没有定义`<`或`<=`运算符，所以在循环中养成使用`!=`的习惯。
-   `const_iterator`能读不能写，`iterator`可读可写
-   如果`vector`对象是一个常量，则只能使用`const_iterator`



### 3.5 数组

数组大小固定，对某些特殊的应用来说程序的运行时性能较好，但是损失了一些灵活性。



#### 3.5.1 定义和初始化数组

```cpp
#include <iostream>

using namespace std;
unsigned cnt = 42; //不是常量表达式,
//string a1[cnt];//这种方式在函数体外报错
void test01()
{
    //数组的维度在编译时应该是已知的
    unsigned cnt = 42; //不是常量表达式
    string a1[cnt]; //cnt不是常量表达式,这种方式严格意义上来说是不可以的,但是可能编译器优化了,在函数体内不报错
    constexpr unsigned sz = 42;
    string a2[sz]; //这才是标准的常量表达式
    int arr[10]; //含有10个整型的数组
    int *parr[10]; //含有10个整型指针的数组
}
```

默认情况下，数组的元素被默认初始化。和内置数据类型一样，如果在**函数体内**定义了某种内置数据类型的数组，那么默认初始化会令数组含有**未定义的值。**

例如arr：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221129170257791.png" alt="image-20221129170257791" style="zoom:40%;" />

里面的值十分混乱。

**显式初始化数组：**

-   如果对数组的元素进行列表初始化，允许忽略数组的维度
-   如果在声明时没有指定维度，编译器会根据初始值的数量推测
-   如果在初始化时指明了维度，那么初始值的总数量不能大于指定的维度
-   如果指定的维度比提供的初始值的数量大，则剩下的元素被初始化为默认值：string为空，整型为0，char也是整型 `0 '\000'`

```cpp
void test02()
{
    const unsigned sz = 3;
    int ial[sz] = {0, 1, 2}; //正常情况
    int a2[] = {0, 1, 2}; //编译器推测维度为3
    int a3[5] = {0, 1, 2}; //等价于 a3 = {0, 1, 2, 0, 0}
    string a4[3] = {"h1", "h2"}; //等价于a4 = {"h1", "h2", ""}
    //int a5[2] = {0, 1, 2}; //报错
}
```



**字符数组的特殊性：**

字符数组有一种额外的初始化形式，那就是用字符串字面值初始化。需要注意的是：字符串字面值的结尾还有一个空字符`'\0'`，这个空字符也会被拷贝到字符数组中去：

```cpp
void test03()
{
    char a1[] = {'C', '+', '+'}; //列表初始化,这种方式没有空字符
    char a2[] = {'C', '+', '+', '\0'}; //显式添加空字符
    char a3[] = "C++"; //字符串字面值初始化, 有空字符
    //char a4[3] = "C++"; //报错,没有空间存放空字符
}
```

可以通过debug查看内部的具体值



**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：

```cpp
//不允许拷贝和赋值
void test04()
{
    int a[] = {0, 1, 2};//初始化一个数组
    //int a2[] = a; // 错误,不能使用一个数组初始化另一个数组
    int a2[2];
    //a2 = a; //错误,也不能将一个数组赋值给另一个数组
}
```



>   一些编译器支持数组的赋值，这就是所谓「**编译器扩展**」(compiler extension)。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序可能在其他编译器上无法正常工作。



**理解复杂数组的声明：**

数组能存放大多数对象，所以能定义存放指针的数组，但是定义一个指向数组的指针和数组的引用就稍微复杂一点：

```cpp
//复杂数组声明
void test05()
{
    int arr[10];
    int *ptrs[10]; //ptrs是一个含有10个int指针的数组
    //int &refs[10] = XX; //引用不是对象
    int (*Parray)[10] = &arr; //Parray指向一个含有10个整数的数组
    int (&Rarray)[10] = arr; //Rarray引用一个含有10个整数的数组
}
```

对于`ptrs`，我们使用从右向左阅读很容易理解，`int *ptrs[10]`首先是一个大小为10的数组，它的名字是`ptrs`，然后数组中存放的是指向int的指针。

但是对于`Parray`，需要名字开始从内向外的顺序阅读，首先`Parray`是一个指针，然后从右向左阅读，指针指向一个大小为10的数组，最后它是int类型的数组。`Rarray`同理。

>   从右到左的顺序没错，但是括号的优先级要高于这个顺序！

--------

>   其实可以看的出来，第三章讲的还是比较浅的，并没有深入到底层去讲解，因此笔记也就一笔带过了。



#### 3.5.2 访问数组的元素

数组也可以使用范围for循环：

```cpp

void test01()
{
    int arr[10] = {}; //这里是全部默认初始化为0,而非未定义
    for (auto i : arr)
    {
        cout << i << endl;
    }
}
```



#### 3.5.3 指针与数组

在C++中，指针与数组有非常紧密的联系：**使用数组的时候编译器一般会将它转换为指针。**

使用取地址符，可以获得某个对象的指针，`&`可以用于任何对象。数组的元素也是对象，对数组的元素取地址可以得到指向该元素的指针。同时，在很多用到数组名字的地方，编译器都会自动将其替换为一个「指向数组首元素的**指针**」。

```cpp
void test01()
{
    string nums[] = {"one", "two", "three"};
    string *p = &nums[1]; //指向nums的第2个元素
    string *p2 = nums; //指向nums的第一个元素, 等价于 string *p2 = &nums[0]
}
```

当数组作为一个`auto`变量的初始值时，推断得到的类型是指针而不是数组：

```cpp
//auto与数组
void test02()
{
    int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto ia2(ia); //构造一个auto变量, 等价于auto ia2(&ia[0])
    //ia2 = 42; // 错误,ia2是一个int* ,不能赋值为int
}
```

但是使用`decltype`则不会发生上述转换：

```cpp
    decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};// ia3是一个数组
    int *p;
    //ia3 = p;//错误,不能使用整型指针给数组赋值
```



**指针也是迭代器：**

与普通指针相比，指向数组元素的指针拥有更多的功能。`vector`的迭代器支持的运算，数组的指针全部支持：

```cpp
//数组指针也是迭代器
void test03()
{
    int arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int *p = arr; //p指向arr的第一个元素
    ++p; //p指向arr的第二个元素
    int *e = &arr[10];//获取指向arr尾元素的后一个元素

    int *e1 = &arr[11];//甚至还能向后走, 编译器不会检查这个错误
    //输出arr的元素
    for (int *b = arr; b != e; ++b)
    {
        cout << *b << endl;
    }

```

**标准库函数`begin`和`end`：**

使用上述方法得到「尾后指针」极易出错，C++11新标准引入了`begin()`和`end()`的函数，这两个函数在头文件`iterator`中，注意由于数组不是「类类型」，因此这两个函数不是成员函数：

```cpp
void test04()
{
    int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    int *beg = begin(ia);
    int *last = end(ia);//尾后指针

}
```



**指针运算：**

**指向数组的元素指针**可以执行`vector`迭代器的所有运算，包括解引用、递增、比较、与整数相加、两个指针相减等，用在指针和用在迭代器上意义完全一致。

指针上+/-某整数值，结果仍然是指针。新指针指向的元素与原来的指针相比前进/后退了该整数值个位置。

```cpp
void test05()
{
    //注意size_t是一个标准库类型, 它是机器相关的 所以单独定义了, 还有很多这种类型
    constexpr size_t sz = 5;
    int arr[sz] = {1, 2, 3, 4, 5};
    int *p = arr; //等价于int*p = &arr[0]
    int *p2 = p + 4; //p2指向arr[4]

    int *ip = arr + sz; //ip是尾后指针, 不要解引用, 这是正确的
    int *ip2 = arr + 10; //arr只有五个元素, ip2指向的是arr+10 * sizeof(int)的地址,但是这个地址不属于数组了
    //上面的错误编译器是不会发现的,解引用会输出一个不确定的值
    cout << *ip2 << endl;


    //指针的减法
    auto n = end(arr) - begin(arr);
    cout << n << endl; //5
    cout << ip2 - arr << endl; //输出10 ,已经超过数组长度了,证明编译器不会检查

}
```



不要比较指向不相关对象的指针，这样没有任何意义：

```cpp
//不要比较指向不相关对象的指针
void test06()
{
    int i = 0, sz = 42;
    int *p = &i, *e = &sz;
    if(p < e)
    {
        cout << "不要这样比较" << endl;
    }
    else
    {
        cout << "不要比较" << endl;
    }
}
```



**解引用与指针、 下标与指针：**

下标运算会转换成指针运算

```cpp
void test07()
{
    int ia[] = {0, 2, 4, 6, 8};
    cout << *(ia + 4) << endl; //正确, 也就是输出ia[4]

    int n = *ia + 4; //正确, 但是是arr[0] + 4

    //下标运算会转换成指针运算
    int i = ia[2]; // 本质是: ia转换成首元素的指针, ia[2]则转换为 *(ia + 2)

    int *p = ia;
    i = *(p + 2); //等价于 i = ia[2]

    //甚至可以有负数
    p = &ia[2];

    cout << p[1] << endl; //转换为 *(p + 1)也就是ia[3]
    cout << p[-2] << endl; //转换为 *(p - 2) 也就是ia[0]
}
```



标准库类型`string`和`vector`也能执行下标运算，但是标准库类型的下标必须是「无符号整型」，而内置的下标运算没有此要求，下标可以是负数。



#### 3.5.4 C风格字符串

>   首先，尽管C++支持C风格字符串，但是在C++程序中最好不要使用：
>
>   1.   C风格字符串使用起来不方便
>   2.   易引发程序漏洞，是很多安全问题的根本原因

字符串字面值即为C++由C继承而来的「**C风格字符串**」。C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法，在字符串最后一个字符跟着一个空字符`'\0'`。

**C标准库String函数：**

在`cstring`头文件中，有一些可以操作C风格字符串的函数：

-   `strlen(p)`  //返回p的长度，**空字符不计算在内**
-   `strcmp(p1, p2)`//比较p1和p2
-   `strcat(p1, p2)` //拼接p1和p2
-   `strcpy(p1, p2)`  //将p2拷贝给p1，返回p1



**比较字符串：**

比较两个 C风格字符串的方法和标准库`string`完全不同：

```cpp
void test01()
{
    //比较string对象
    string s1 = "abc";
    string s2 = "abcd";
    
    //string的比较直接用关系运算符
    if(s1 < s2)
    {
        cout << "s1 < s2" << endl;
    }
    else
    {
        cout << "s1 >= s2" << endl;
    }
    
    //比较C风格字符串
    const char ca1[] = "abc";
    const char ca2[] = "abcd";
    if(ca1 < ca2) //这样比较毫无意义,比较的是两个指针的值, 这两个指针指向不同对象, 结果无意义
    {
        
    }
    
    //需要使用 strcmp函数
    if(strcmp(ca1, ca2) < 0) //与两个string对象的比较一样
         {
         }
}
```

直接比较C风格字符串是比较指针的值，没有意义



**C风格字符串的拷贝和连接：**

连接C风格字符串需要提供一个存放结果字符串的数组，该数组必须足够大，且容易引发错误。

所以建议使用标准库的`string`。

#### 3.5.5 与旧代码的接口

-   可以使用C风格字符串初始化和赋值string对象
-   不能将string对象赋值给`char *`
-   string对象的成员函数`c_str()`可以返回C风格字符串（一个`const char*`）

```cpp
void test01()
{
    //允许使用C风格字符串来初始化string类
    string s("hello, world!");
    s = "hello!"; //允许使用C风格字符串给string对象赋值

    //c_str() 是string的一个成员函数, 返回一个C风格字符串, 当然返回值是一个const char*
    const char* cstr = s.c_str();

    //但是修改string对象也会修改对应的c_str()返回值
    //输出hello
    for(auto i = cstr; *i != '\0'; i++)
    {
        cout << *i << " ";
    }
    cout << endl;
    s = "abc";
    //输出 abc, 所以最好把结果拷贝
    for(auto i = cstr; *i != '\0'; i++)
    {
        cout << *i << " ";
    }
}
```



**使用数组初始化vector：**

```cpp
//使用数组给vector初始化
void test02()
{
    int arr[] = {1, 2, 3, 4, 5};
    
    //不能直接用数组
    // vector<int> v(arr); //错误
    
    //需要指定区间
    //区间可以自定义
    vector<int> v0(begin(arr), end(arr));
    vector<int> v(arr, arr + 5);
}
```

注意只能用数组初始化`vector`，不能用数组给`vector`赋值，更不能用`vector`给数组赋值和初始化。

### 3.6 多维数组

严格来说，C++中没有多维数组，通常所说的「多维数组」本质上是「数组的数组」。

**多维数组的下标引用：**

可以使用下标运算来访问多维数组，如果表达式的下标运算符比数组的维度小，则表达式的结果是一个内层数组；如果表达式的下标运算符和数组的维度相同，则结果是该位置的元素。

```cpp
void test01()
{
    //多维数组的初始化有很多
    int ia[3][4] = {};

    //ia[1]是一个数组,但是数组不能给数组赋值, 所以不能用int a[4] = ia[1],需要使用引用
    int (&a)[4] = ia[1];

    //当然 指针也可以, 如果使用auto 关键字，会自动转为指针类型
    int *b = ia[1];
}
```



**使用范围for语句处理多维数组：**

「范围for语句」是C++11的新标准新增内容，使用`auto`关键字来简化指针或者引用。

```cpp
void test02()
{
    int ia[3][4] = {};
    int count = 0;

    for(int i = 0; i < 3; i++)
        for(int j = 0; j < 4; j++)
            ia[i][j] = count++;
        
    //注意除了最内层循环外, 其他所有的循环控制变量都应该用引用类型    
    for(auto &row : ia)
        for(auto col : row)
        {
            cout << col << " ";
            col = 1;
            cout << col << " "; //能修改到col
        }

    cout << endl;
}
```

除了最内层循环外, 其他所有的循环控制变量都应该用引用类型，如果不使用引用类型，`auto`会推断出`int *`类型，那么内层的循环就不合法了（不能对`int *`）进行循环遍历。



**指针和多维数组：**

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针，所以「多维数组名」指向的是「第一个内层数组的指针」。

```cpp
   int ia[3][4] = {};
 //c指向一个数组，这个数组有4个元素
    int (*c)[4] = ia;
    //用指针访问数组， 
    for(int (*i)[4] = ia; i != ia + 3; i++)
    {
        //i解引用才是一个数组，数组名则是指向首元素的指针
        for(int * j = *i; j != *i + 4; j++)
        {
            cout << *j << " " << endl;
        }
    }
```

使用`auto`关键字可以省略具体类型



>   尽量使用标准库提供的类型，再考虑使用数组或指针。



## 4. 表达式

>   前言：
>
>   在看这一章之前已经用的够多了，但是有的概念不是很熟悉。

### 4.1 基础

#### 4.1.1 基本概念

**一元运算符和二元运算符**

-   函数调用也是一种特殊的运算符，它对运算对象的个数没有限制
-   一些符号既能作为一元运算符也能用作二元运算符，例如`*`可以是解引用，也可以是乘号



**运算对象转换**

很多时候二元运算符的两个运算对象即使类型不同也没有关系，只要它们能被转换成同一种类型即可，小整数类型（bool、char、short等）通常会被**提升**(promoted)成为较大的整数类型。



**重载运算符**

「重载运算符」（overloaded operator）只能改变运算符的运算对象类型和返回值的类型；但是对运算对象的个数、运算符的优先级和结合律是无法修改的。



**左值和右值**

C++的表达式要不然是「右值」(rvalue)，要不然就是「左值」（lvalue）。在C语言中，左值可以位于赋值语句的左侧，右值则不能。

但是在C++中，二者的区别就没有这么简单了：

-   一个左值表达式的求值结果是「一个对象」或者「一个函数」，然而以「常量」为代表的某些左值实际上不能作为赋值语句的左侧运算对象。
-   此外，虽然某些表达式的求值结果是「对象」，但它们是右值而非左值，具体来说：
    -   当一个对象被用作右值的时候，用的是对象的「值」（内容）
    -   当对象被用作左值的时候，用的是对象的「身份」（在内存中的位置）

不同的运算符对运算对象的要求也不同，有的需要左值运算对象，有的需要右值运算对象；返回值也有差异，有的得到左值结果，有的得到右值结果。**一个重要的原则是：**

-   在需要右值的地方可以用左值来代替，当时不能把右值当成左值（也就是位置）使用。
-   当一个左值被当成右值使用时，实际使用的是它的内容（值）。



常见的用到左值的运算符：

-   赋值运算符需要一个（非常量）左值作为其左侧对象，得到的结果也仍然是一个左值
-   取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，**这个指针是一个右值**
    -   也就是说，不能用`&p = x`的语句，除非是定义引用，单独的`&p`不能作为左值，这很好理解。
-   内置解引用运算符、下标运算符、迭代器解引用运算符、`string`和`vector`的下标运算符的求值结果都是左值
-   内置类型的迭代器的递增递减运算符作用于左值运算对象，其「前置版本」所得的结果也是左值



使用关键字`decltype`的时候，左值和右值也有所不同：

-   如果表达式的求值结果是左值，`decltype`**作用于该表达式（不是变量）得到一个引用类型**。例如：`int *p`，因为解引用运算符生成左值，所以`decltype(*p)`的结果是`int &`。
-   另一方面，因为取地址运算符生成的是右值，所以`decltype(&p)`的结果是`int **`，这是一个「指向指针的指针」。



#### 4.1.2 优先级与结合律

略

#### 4.1.3 求值顺序

**优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值**。在大多数情况下，不会明确指定求值的顺序。例如下面的表达式：

```cpp
int i = f1() + f2();
```

很显然，`f1`和`f2`的调用一定在执行 `+`之前，**但是我们无法知道`f1`在`f2`之前调用还是`f2`在`f1`之前调用。**

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。再例如，`<<`运算符没有明确规定何时以及如何对「运算对象」求值，因此下面的输出表达式是「未定义」的：

```cpp
int i = 0;
cout << i << " " << ++i << endl;
```

对于不同的编译器可能输出不同的结果, `1 1` 或者`0 1`都是有可能的，甚至还会出现意想不到的结果。



对于`f() + g() * h() + j()`这样的表达式而言，有：

-   优先级规定， `g()`的返回值和`h()`的返回值相乘
-   结合律规定，`f()`的返回值先与`g()`和`h()`的乘积相加，所得结果再与`j()`的返回值相加。
-   **但是，对于这些函数的调用没有明确规定！**

如果上面四个函数是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则这是一条错误的表达式，将产生未定义的行为。



>   C++ 11标准规定，在两个序列点（sequence point）之间，一个对象的值可以被读取好几次，但只能被写入一次。并且读取的几次只能被用于确定新的值，例如：
>
>   i = i++; // 错误！i 的值被写入了两次
>
>   k = (i++) + i; // 错误，加号右边的 i 被读取不是为了确定新值
>
>   i = i + 5; // 正确，右边的 i 被读取是为了确定新值



**同时有四种运算符明确规定了运算对象的求值顺序：**

-   逻辑与`&&`运算符
-   逻辑或`||`运算符
-   条件`? :`运算符
-   逗号`,`运算符



**处理复合表达式的准则：**

1.   不清楚的时候用`()`强制改变表达式的组合关系
2.   如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象
    -   但是第二条有个例外，就是例如`*++iter`，递增运算符改变`iter`的值，`iter`（已经改变）又是解引用的运算对象，此时求值的顺序不会成为问题。很显然不可能先解引用再`++`。
    -   这种情况称为：**当「改变运算对象的子表达式」本身就是另外一个「子表达式」的运算对象时，规则2无效。**具体来说，`++iter`本身就是`*++iter`的运算对象。



### 4.2 算术运算符       

有`+, -, *, /, %`，其中`+, -`又有一元的版本。

-   算术运算符的运算对象和求值结果都是右值

-   在表达式求值之前，小整数类型的运算对象被提升为`int`类型

-   bool类型不要参与运算

    ```cpp
    bool b = true;
    bool b2 = -b;// b2也是true，因为ture转换为int是1， 加一元负号变为-1
    //但是只要不是0，就都是true
    ```

-   溢出的结果是不可预知的，属于未定义行为

-   C++11新标准规定商向0取整

-   `-21 / -8 =2`; `-21 / -8 = -5`



### 4.3 逻辑和关系运算符

有`!, < ,<=, >, >=, ==, !=, && ,||`，其中`!, &&, ||`是逻辑运算符，其他是关系运算符。‘

-   关系运算符作用于「算术类型」或「指针类型」，逻辑运算符作用域「任何能转换成bool值的类型」。
-   逻辑和关系运算符的结果都是bool类型，值为0的运算类型为假，否则为真
-   逻辑和关系运算符的结果都是右值

**逻辑与和逻辑或运算符**

也就是`&&`和`||`，这两种运算符都先确定左侧的运算对象，如果有必要再计算右侧的运算对象，这种策略称之为「短路求值」（short-circuit evaluation）：

-   对于逻辑与`&&`运算符，当且仅当左侧运算对象为真时才计算右侧运算对象
-   对于逻辑或`||`运算符，当且仅当左侧对象为假时才计算右侧运算对象



**关系运算符**

关系运算符比较对象的大小关系，并返回bool值，关系运算符都满足左结合律。

几个关系运算符连写需要注意：

```cpp
void test01()
{
    int i = 1, j = 2, k = 3;
    //不是比较ijk的大小，而是先计算 i < j的结果得到一个bool值，再把这个bool值与k比较
    if(i < j < k)
    {
        
    }
}
```

当bool值转换成其他算术类型时，false转换为0，true转换为1.

>   进行比较运算时，除非比较的对象是bool类型，否则不要使用bool字面值true和false作为运算对象



### 4.4 赋值运算符

-   赋值运算符的「左侧运算对象」必须是一个「可修改的左值」
-   赋值运算的结果是它的「左侧运算对象」，并且是一个左值
-   **赋值运算满足的是右结合律**，这一点与其他二元运算符不同
-   赋值运算符的优先级很低，通常在条件语句中需要加括号

```cpp

//赋值运算的左侧对象必须是一个可修改的左值
void test01()
{
    int i = 0, j = 0, k = 0;//这是初始化， 不是赋值
    const int ci = i; //这是初始化， 不是赋值

    //下面的语句都是非法的
    // 1024 = k;// 字面值是右值
    // i + j = k; //算术表达式是右值
    // ci = k; //ci是常量左值
    
    //C++11新标准允许使用花括号的初始列表作为赋值语句的右侧运算对象
    //这种不允许窄化转换
    // k = {3.13};//窄化转换，错误
}

//赋值运算满足右结合律
void test02()
{
    int ival, jval;
    ival = jval = 0; //先计算jval = 0, 返回jval（左侧运算对象），再计算ival = jval
}

void test03()
{
    int i;
    //先计算getv() < 0, 把这个bool值赋给i
    if(i = getv() < 0)
    {}
    //按照括号计算
    if((i = getv()) < 0)
    {}

    //赋值语句返回的是左侧操作对象
    if(i = 0) //假
    {
        cout << "i = 0" << endl;
    }
    if(i = 1) //真
    {
        cout << "i = 1" << endl;
    }
}

```



使用`i += j`只会运算一次，使用`i = i + j`会运算两次，第二次是赋值运算，其中`i + j`是`i = i + j`的子表达式，满足处理复合表达式。



### 4.5 递增和递减运算符

递增运算符`++`和递减运算符`--`为对象的+1和-1操作提供了一种简洁的书写方式。这两个运算符还可以用于迭代器，因为很多迭代器本身不支持算术运算，但是支持递增和递减。

**前置`++`和后置`++`：**

-   前置`++`首先将运算对象+1，然后将「改变后的对象」作为求值结果，
-   后置`++`也会将运算对象+1，但是求值结果是「运算对象改变之前那个值的副本」
-   这两种运算符必须作用域「左值运算对象」
-   前置`++`将对象本身作为「左值」返回
-   后置`++`将对象原始值的副本作为「右值」返回。
-   尽量用前置`++`



**在一条语句中混用解引用和递增运算符：**

```cpp
void test01()
{
    vector<int> v = {1, 2, 3, 4, 5};
    auto pbeg = v.begin();
    //打印整个vector
    while(pbeg != v.end())
        //后置++的优先级高于解引用运算符
        cout << *pbeg++ << " ";
    cout << endl;
}
```

上述代码中，`*pbeg++`不太容易理解：

-   首先，后置++运算符的优先级高于解引用运算符，所以执行顺序为
-   首先*(pbeg++)，pbeg的值增加1，返回pbeg的「原始值的副本」
-   解引用pbeg未自增的副本，也就是解引用pbeg的原始值
-   结果就是输出pbeg指向的值，pbeg向后移动一个元素

>   上述的代码非常常见，需要熟练掌握。

如果上述代码使用`*++pbeg`，则第一个元素无法输出，并且会越界。



**运算对象可以按任意顺序求值**

还是运算符的「运算对象」的「求值顺序」问题。当一个子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很重要了。

由于递增运算符和递减运算符会改变运算对象的值，所以需要注意这一点：

假设`beg`是一个string类的迭代器

```cpp
*beg = toupper(*beg++);
```

上述代码中`beg++`改变了`beg`的值，同时赋值运算符`=`左侧的运算对象`*beg`又使用了`beg`，同时这两个子表达式又不存在包含关系（一个子表达式是另一个子表达式的运算对象），这条语句就是未定义的，编译器有几种处理思路：

-   先求左侧的值：`*beg = toupper(*beg)`
-   先求右侧的值：`*(beg +1) = toupper(*beg)`，这样写是因为后置++返回原始值的副本，而beg本身是被修改了
-   也可以用别的方式处理

### 4.6 成员访问运算符

点运算符`.`和箭头运算符`->`，分别用于对象和指针。

解引用的运算符低于点运算符：

```cpp
*p.size(); //运行p的size成员，然后返回解引用size的结果
(*p).size(); //等价于p->size()
```

-   箭头运算符作用于一个指针类型的运算对象，结果是一个左值
-   点运算符分成两种情况：
    -   如果成员所属的对象是左值，那么结果是左值
    -   如果成员所属的对象是右值，那么结果是右值

### 4.7 条件运算符`? :`

条件运算符其实就是把简单的`if-else`语句嵌入到当个表达式中，当条件运算符的两个表达式都是左值或者「能转换成同一种左值类型时」，运算的结果是左值，否则是右值。

条件运算符的优先级非常低，在输出表达式中使用条件运算符需要特别注意这一点。



### 4.8 位运算符

-   一般来说，如果运算的对象是“小整型”，则它的值会被自动提升
-   强烈建议仅将位运算符用于无符号类型
-   「移位运算符」的右侧运算对象不能为负，而且必须严格小于结果的位数，否则就是未定义的行为。
-   移位运算符满足左结合律



### 4.9 `sizeof`运算符

-   `char`的结果为1
-   对引用类型执行sizeof运算得到被引用对象所占空间的大小
-   对指针执行sizeof得到指针本身所占空间的大小（一般为8）
-   对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效，可以无效
-   对数组执行sizeof等价于对数组中所有元素执行一次sizeof并求和，sizeof运算不会把数组当作指针来处理
-   对`string`和`vector`对象执行sizeof，结果是固定的，因为string的大小是在堆区动态变化的，不同环境这个结果可能不同，我的环境测试`sizeof(string)`为8：

```cpp
void test01()
{
    int arr[5] = {0};
    //4
    cout << sizeof(int) << endl;
    //8
    cout << sizeof(int *) << endl;
    //8
    cout << sizeof(string *) << endl;
    //20, sizeof不会把数组名转换成指针来处理j
    cout << sizeof(arr) << endl;
    //4
    cout << sizeof(*arr) << endl;
    string a = "abcdefg";
    //8
    cout << sizeof(string) << endl;
    //8
    cout << sizeof(a) << endl;
}

```



### 4.10 逗号运算符

-   `,`规定了运算对象的求值顺序是从左到右
-   逗号运算符的真正结果是右侧表达式的值，如果右侧运算对象是左值，那么最终的结果也是左值



### 4.11 类型转换

#### 4.11.1 隐式类型转换

在下面这些情况下，编译器会发生隐式类型转换：

-   在大多数表达式中，  比`int`类型小的整数类型会首先提升为较大的整数类型
-   在条件中，非`bool`类型转换成`bool`类型
-   初始化过程中，初始值转换成变量的类型，在赋值语句中， 右侧运算对象转换成左侧运算对象的类型
-   如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型
-   函数调用时也会发生类型转换

#### 4.11.2 其他隐式类型转换

**数组转换成指针：**

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针，但是有几个例外：

-   数组被作为`decltype`关键字的参数

-   数组作为取地址符`&`、`sizeof`和`typeid`等运算符的运算对象时

-   使用引用来初始化数组

    ```cpp
    int arr[10] = {0};
    //使用引用初始化数组, arr是数组而不是指向数组首元素的指针
    int (&r)[10] = arr;
    ```

**指针的转换：**

-   常量整数值`0`或者字面值`nullptr`能转换成任意指针
-   指向任意非常量的指针能转换成`void *`
-   指向任意对象的指针能转换成`const void*`
-   在有继承关系的类型间还有另一种指针转换的方式

**转换成常量：**

允许将指向非常量类型的指针转换成指向相应的常量类型指针，对于引用也适用。

```cpp
int i;
const int &j = i;
const int *p = &i;
int &r = j, *q = p; //错误，常量不能转换成非常量
```

**类类型定义的转换：**

例如

```cpp
while(cin >> s)
```

`cin`自动转换成bool类型。



#### 4.11.3 显式转换

一个命名的强制类型转换具有如下形式：

```cpp
[cast_name]<type> (expression)
```

-   `cast_name`有四种
    -   `static_cast`
    -   `dynamic_cast`
    -   `reinterpret_cast`
    -   `const_cast`
-   `type`是转换后的类型，如果`type`是引用类型，则结果是左值
-   `expression`是要转换的值

**static_cast**

任何具有明确定义的类型转换，只要不包括底层`const`，都可以使用`static_cast`。

当需要把一个较大的算术运算赋值给较小的类型时，`static_cast`非常有用。此时，强制类型转换告诉读者和编辑器：**我们知道并不在乎潜在的精度损失。**

使用`static_cast`可以找回存在`void*`指针中的值：

```cpp
void *p = &d;
double *dp = static_cast<double*>(p);
```

强制转换的结果与原始地址值相等，因此我们必须保证转换后所得的类型就是指针所指的类型。

**const_cast**

一句话概括：

-   `const_cast`只能改变运算对象的底层`const`

>   这个问题其实比想象中复杂，**const_cast绝对不是为了改变const变量的值而设计的！**在函数重载的上下文中长使用`const_cast`。

```cpp
//const_cast
void test01()
{
    const int a = 24;
    const int* p = &a;

    //同时const_cast只能修改对象的底层const, 修改其他的是错误的
    int *m = const_cast<int*>(p);
    //通过 *m修改是未定义的行为
    *m = 12;

    //出现了很神奇的事情:
    //这三个地址相同, 但是结果不同 p和m是指针,指向的区域的值为12, 但是a是24

    cout << "*m = " << *m << ", *m的地址: " << m << endl;
    cout << "a = " << a << ", a的地址: " << &a << endl;
    cout << "*p = " << *p << ", p = " << p << endl;

    //static_const不能修改底层const
    // const char*p2 = static_cast<const char*>(p); //错误
}
```

如果对象是一个常量，在使用`const_cast`执行写操作时会产生未定义的后果，强制类型转换不会修改地址。



**reinterpret_cast**

`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。

例如：

```cpp
void test02()
{
    int *ip;
    char *pc = reinterpret_cast<char*>(ip);
    string s(pc); //错误,pc所指的真实对象是一个int而非char
}
```

虽然使用`reinterpret_cast`使得编译器认为`pc`是一个`char*`，但是它实际指向的仍然是`int`，使用`pc`初始化`string`会报错。

>   `reinterpret_cast`本质上依赖于机器，想要安全使用`reinterpret_cast`必须对涉及的类型和编译器实现转换的过程都非常了解。

**旧式的强制类型转换：**

早期版本的C++中，显式进行强制类型转换有两种形式：

```cpp
type (expr); //函数形式的强制类型转换
(type) expr;// C语言风格的强制类型转换
```

根据所涉及的类型不同，旧式的强制类型转换分别具有与`const_cast`、`static_cast`或`reinterpret_cast`相似的行为：

-   当替换成`cosnt_cast`和`static_cast`也合法，则其行为与这两种类型转换一致

-   如果替换后不合法，则旧式强制类型转换执行与`reinterpret_cast`类似的功能：

    ```cpp
    int *ip;
    char *pc = (char *)ip; //效果与reinterpret_cast一样
    ```

    

## 5. 语句

>   前言👋：
>
>   其实这一块的内容比前面更简单，但是`try`语句和异常处理一般了解较少。

### 5.1 简单语句

C++中大多数语句都以分号结尾。空语句就是一个`;`。空间语句可以使用在任何地方，但是不要这样做。

复合语句就是用`{}`括起来的语句。

### 5.2 语句作用域

定义在控制结构中的变量只能在相应语句的内部可见，例如if、switch、while和for。

### 5.3 条件语句

这里主要讲讲`switch`语句。可以把几个case写在一行里，强调这些case代表的是某个范围的值：

```cpp
switch(ch)
{
    case 'a': case 'b': case 'c' :
        ++x;
        break;
}
```



### 5.4 迭代语句

需要注意的有**范围for语句**：

```cpp
for (declaration : expression)
    statement
```

`expression`表示的必须是一个序列，它们的共同特点是能返回迭代器的`begin`和`end`成员



### 5.5 跳转语句

`break`负责终止离他最近的`while`、`do while`、`for`或`switch`语句，并从这些语句的第一条语句开始执行。

`continue`负责终止`while`、`do while`或`for`循环的当前迭代，并立即开始下一次迭代。

`goto`的作用是从`goto`语句无条件跳转到「同一函数内」的另一条语句：

```cpp
goto label;


XXX
label : xx;
```

例如

```
end : return;
```

这是一条带标签的语句，可以用goto

```cpp
goto end;
```



### 5.6 `try`语句块和异常处理

异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括「失去数据库连接」以及「遇到意外输入」等。处理异常可能是设计所有系统最难的部分。

当程序的某部分中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。例如，如果程序的问题是输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，则会发出报警信息。

异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持。在C++中，异常处理包括：

-   `throw`表达式：异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题。称之为`throw`「引发」(raise)了异常
-   `try`语句块：异常处理部分使用`try`语句块处理异常。`try`语句块以关键字`try`开始，并以一个或多个「`catch`子句」"处理"异常，所以它们也被称为「异常处理代码」(exception handler)
-   一套**异常类**：用于在`throw`表达式和相关`catch`子句之间传递异常的具体信息



#### 5.6.1 `throw`表达式

`throw`表达式在关键字`throw`后加一个表达式：

```cpp
int test01()
{
    Sales_item item1("a"), item2("b");
    //业务逻辑代码和用户交互的代码未分离
    if(item1.isbn == item2.isbn)
    {
        return 0;
    }
    else
    {
        cout << "isbn必须相同" << endl;
        return -1;
    }
}

int test02()
{
    Sales_item item1("a"), item2("b");
    //如果isbn不一样则抛出异常
    if(item1.isbn != item2.isbn)
    {
        throw runtime_error("isbn必须相同");
    }
    return 0;
}

```

在`test02`中，如果isbn不一样就抛出一个异常，该异常是类型`runtime_error`的对象，抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。

`runtime_error`是标准库异常类型的一种，定义在`stdexcept`头文件中。我们必须初始化`runtime_error`的对象，方法是给它提供一个`string`对象或者一个C风格的字符串。



#### 5.6.2 `try`语句块

`try`语句块的通用语法格式是：

```cpp
try {
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
```

`try`语句一开始是关键字`try`，随后紧跟一个块，这个块就像大多数时候那样是花括号括起来的语句。

跟在`try`块之后的是一个或多个`catch`子句，`catch`子句包括三个部分：`catch`、括号内一个（可能没有命名的）对象的声明（称为「**异常声明**」），以及一个块。当选中了某个`catch`子句处理异常之后，执行与之对应的块。`catch`一旦完成，程序跳转到`try`语句的最后一个`catch`子句之后的语句继续执行。

**编写处理代码：**

程序本来要执行的任务写在`try`语句块中。



**函数在寻找处理代码的过程中退出：**

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个`try`语句块。例如，一个`try`语句块可能调用了另一个`try`语句块的函数，新的`try`语句又可能继续调用其他`try`。

寻找处理代码的过程与函数的调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数，如果没有找到匹配的`catch`语句，终止该函数，并在调用该函数的函数中继续寻找，直到「找到」或者「最终仍然没有找到任何匹配的`catch`」。如果是第二种情况，程序跳转到名为`terminate`的标准库函数。该函数的行为与系统有关，一般情况下会导致程序非正常退出。

对于那些没有任何`try`语句块定义的异常，也按照类似的方法处理。

#### 5.6.3 标准异常

C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以用在自己编写的程序中，它们分别定义在4个头文件中：

-   `exception`头文件定义了最常用的异常类。它只报告异常的发生，不提供任何额外信息。
-   `stdexcept`头文件定义了几种常用的异常类
-   `new`头文件定义了`bad_alloc`异常类
-   `type_info`定义了`bad_cast`异常类

异常类型只定义了一个`what`的成员函数，没有参数，返回值是一个指向C风格字符串的`const char*`。



## 6. 函数

>   相对于上一章的语句，第六章函数，虽然平时用的非常多，大部分知识也都掌握，但是还是有需要查漏补缺的地方，例如函数指针。

### 6.1 函数基础

**函数定义：**

-   返回类型
-   函数名
-   参数列表
-   函数体



**函数调用主要完成两项工作：**

-   用实参初始化函数对应的形参
-   将控制权转移给被调用函数，return则正好相反



**实参和形参：**

实参是形参的初始值。尽管实参与形参存在对应关系，但是没有规定实参的求值顺序。



**形参列表：**

-   可以为空，但是不能省略

-   显式定义空形参列表：

    `void f1(void) {}`



**函数的返回类型：**

-   函数的返回类型不能是数组或函数类型
-   但是可以是指向数组或者函数的指针



#### 6.1.1 局部对象

在C++中，名字有作用域，对象有「**生命周期**」(lifetime)。这两个概念非常重要！

-   名字的作用域是程序文本的一部分，名字在其中可见
-   对象的生命周期是程序执行过程中该对象存在的一段时间

「形参」和「函数体内定义的变量」统称为 「**局部变量**」(local variable)。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。



**自动对象：**

对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为「**自动对象**」(automatic object)。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。

>   ❓：那么为什么还要`free`和`delete`?



**局部静态变量：**

某些时候，有必要使局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成`static`类型从而获得这样的对象。「**局部静态变量**」（local static variable）在程序执行路径第一次经过对象定义语句时初始化，并且知道程序终止时才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

```cpp
//一个统计自己被调用了多少次的函数
size_t count_calls()
{
    //调用结束后， 这个值仍然有效
    static size_t ctr = 0;
    return ++ctr;
}

void test01()
{
    //输出1到10
    for(size_t i = 0; i != 10; ++i)
    {
       cout << count_calls()  << endl;
    }

}
```

如果局部静态变量没有显示的初始值，它将被执行初始化，内置数据类型的局部静态变量初始化为0。



#### 6.1.2 函数声明

函数的名字也必须在使用之前声明。函数智能定义一次，但是能被声明多次。

函数的声明不包含函数体，所以可以不写形参的名字，但是写上形参列表还是有好处的。

函数声明也被称为「**函数原型**」（function prototype）



**在头文件中进行函数声明：**



#### 6.1.3 分离式编译



### 6.2 参数传递

形参的类型决定了形参于实参的交互形式：

-   如果形参时引用类型，称之为「它对应的实参被**引用传递**」(passed by reference)或者「函数被**传引用调用**」(called by reference)。同时形参绑定到对应的实参上，引用形参是对应实参的别名。
-   如果实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。这样的「实参被**值传递**」(passed by value)或者「函数被**传值调用**」。

#### 6.2.1 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时对变量的改动不会影响初始值。函数对形参的所有操作都不会影响实参。

**指针形参：**

指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针，但是指向相同的对象，所以我们可以通过指针修改所指对象的值。

>   Tips：
>
>   建议C++中使用引用替代指针。

#### 6.2.2 传引用参数

引用形参的行为与普通医用类似，引用行参绑定「初始化它的对象」。引用形参是实参的一个别名。



**使用引用避免拷贝：**

拷贝大的类类型对象或者容器对线比较低效，甚至有的类类型（例如IO类型）不支持拷贝操作。当某些类型不支持拷贝操作时，函数**只能通过引用形参访问该类型的对象**。

当函数无需修改引用形参的值时最好使用「常量引用」。



**使用引用形参返回额外信息**

例如一个查找函数`find_char`，它返回一个`string`对象某个字符的第一次出现位置，同时我们还想返回字符出现的次数，有两种方法：

-   定义一个新的数据类型，包含位置和数量两个成员
-   给函数传入一个额外的引用实参



#### 6.2.3 `const`形参和实参

当形参是`const`时，必须注意顶层`const`和底层`const`：

-   当用实参初始化形参时，会忽略掉顶层`const`。形参的顶层`const`会被忽略，传入「常量对象」或者「非常量对象」都是可以的。

需要注意一点：

```cpp
void test(const int i) {}
void test(int i){}
```

上面的代码时错误的，不能用是否有顶层`const`来重载函数。



**指针或引用形参与`const`：**

形参的初始化过程和变量的初始化过程时一样的：

-   可以用「非常量」初始化一个「底层`const`对象」，但是反过来不行

-   同时一个「普通的引用」（非底层`const`引用）必须用「同类型的**对象**」初始化

    言下之意，不能用下面的表达式初始化：

    -   字面值
    -   求值结果为`int`的表达式
    -   需要转换的对象
    -   `const int`类型的对象

-   类似的，如果想调用指针版本的也只能使用`int *`



**尽量使用常量引用：**

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误：

-   这么做给人一种误导：即函数可以修改它的实参的值。
-   此外，使用「引用」而非「常量引用」也会极大地限制函数能接受的实参类型。

这种错误绝对不是像看起来那么简单，它可能会造成出人意料的后果：

-   例如`find_char("Hello")`，不能用字面值初始化普通引用

-   还有一个更难察觉的问题：例如：其他函数（正确地）将它们的形参定义成常量引用，那么不能使用这个参数来初始化普通引用：

    ```cpp
    bool find_char(string &s)
    bool test(const string &s)
    {
        //错误，使用常量初始化非常量
    	return find_char(s); 
    }
    ```

上面的代码有两种解决方法：

1.   将`find_char`的参数定义为`const string&`
2.   在`test`中定义一个`string`类型的变量，令其为`s`的副本，然后把这个变量传入`find_char`



#### 6.2.4 数组形参

数组的两个特殊性质对我们定义了使用「作用在数组上的函数」有影响：

-   不允许拷贝数组，导致**不能以值传递的方式**使用数组参数
-   使用数组时（通常）会将其转换成指针，导致传递数组时，实际上传递的是「指向数组首元素的指针」



有三种传递数组的形式：

```cpp
//这三种方式是等价的
void print(const int *);
void print(const int[]);
void print(const int[10]); //这里的维度只是我们期望数组含有多少元素，实际不一定
```

每个函数的唯一形参都是`cosnt int*`类型的，所以传入数组名时，等价于传指向数组首元素的指针。另外，传入任意`int *`类型都是可以的，例如`int i  = 1	`，可以传入`&i`



**管理指针形参：**

数组是以指针形式传递给函数的，所以函数并不知道数组的大小，有三种方法：

**1. 使用标记指定数组长度：**

例如处理C风格字符串，可以遇到空字符时停止，但是对于类似于`int`这样所有取值都是合法值的数据无效。

**2.使用标准库规范：**

传递首指针和尾后指针

```cpp
void print(cosnt int *beg, const int *end)
```

可以使用标准库的`begin()`和`end()`函数

**3. 显式传递一个表示数组大小的形参：**

```cpp
void print(const int ia[], size_t size)
```



**数组形参和`const`:**

当函数不需要对数组元素执行写操作的时候，数组形参应该是指向`const`的指针。



**数组引用形参：**

C++允许将变量定义为数组的引用，所以形参也可以是数组的引用，此时引用形参绑定到数组上：

```cpp
void print(int (&arr)[10])
```

但是这种方法有局限性：

 引用必须有数组的维度，所以实参也必须是大小为10的数组。



**传递多维数组：**

C++中没有真正的多维数组：

```cpp
void print(int (*i)[10]);
void print(int i[][10]);
```

上面的代码两个声明是等价的。实际上形参是「一个指向含有10个整数数组的指针」。



#### 6.2.5 `main`：处理命令行选项

可以使用命令行给`main`函数传递参数：

```cpp
int main(int argc, char *argv[])
{
    
}
```

或者：

```cpp
int main(int argc, char **argv)
{
    
}
```

第一个形参`argc`表示`argv`数组中字符串的数量，`argv[0]`保存程序的名字，`argv[1]`开始才是可选的实参。

可以用命令：

```bash
prog -d -o ofile data0
```

-   `prog`：可以执行文件，包含了main函数



#### 6.2.6 含有可变形参的函数

有时候我们无法提前预知应该向函数传递几个实参。例如，我们想要编写代码输出程序产生的错误信息，此时最好用同一个函数实现该项功能，以便对所有错误的处理能够整齐。然而，信息的种类不同，所以调用错误输出函数时传递的实参也各不相同。

为了编写能处理不同数量实参的函数，C++新标准提供了两种主要的方法：

1.   如果所有实参的类型相同，可以传递一个名为`initializer_list`的标准库类型
2.   如果实参的类型不同，可以使用可变参数模版

除此之外，C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的形参。



**`initializer_list`形参：**

如果函数的实参数量未知但是全部实参类型相同，可以用`initializer_list`的形参，它定义在同名头文件中。

```cpp
//可以传递可变数量的实参
void error_msg(initializer_list<string> li)
{
    for (auto beg = li.begin(); beg != li.end(); ++beg)
    {
        cout << *beg << " ";
    }
}


void test01()
{
    string msg = "error";
    //必须把序列放在花括号中
    error_msg({"hello", "world", msg });
    error_msg({msg, "world"});
}
```

同时，含有`initializer_list`形参的函数还可以拥有其他形参：

```cpp
void error_msg(int n, initializer_list<string> li)
{
    
}

void test02()
{
    error_msg(5, {"hello", "world"});
}
```

记得使用花括号把`initializer_list`的实参括起来。



**省略符形参：**

省略符形参是C++程序访问某些特殊的C代码而设置的，它只能出现在形参列表的最后一个位置：

```cpp
void foo(int i, ...);
void foo(...);
```

在第一种声明中，最后的`,`是可以省略的。



### 6.3 返回类型和`return`语句



#### 6.3.1 无返回值函数



#### 6.3.2 有返回值函数



**值是如何被返回的：**

返回一个值的方式和初始化一个变量或者形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

如果返回值，那么返回的是一个拷贝，或者一个未命名的临时变量（例如：`return a + b`）。

如果返回引用，则是引用对象的一个别名。



**不要返回局部对象的引用或指针：**

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向「不再有效的内存区域」。

```cpp

//严重错误：这个函数试图返回局部对象的引用
const string &foo()
{
    string ret;
    if(!ret.empty())
        return ret; //错误： 返回局部对象的引用
    else
        return "Empty"; //错误： "Empty"是一个局部临时量
}
```

上面两条`return`语句都将返回未定义的值，使用`foo`函数会引发未定义的行为。上面这两条语句都指向了不可再用的内存空间。

>   Tips：
>
>   要想确保返回值的安全，可以先思考：引用所引的是在「函数之前」已经存在的哪个对象？
>
>   指针同理



**返回类类型的函数和调用运算符：**

链式编程

**引用返回左值：**

只有调用一个「返回引用」的函数得到左值，其余得到右值，我们可以为返回类型是「非常量引用」的函数的结果赋值。



**列表初始化返回值：**

C++11新标准规定，函数可以返回花括号包围的值的列表：

例如返回`vector<int>`:

```cpp
return {1, 3, 5};
```

花括号的内容由类本身定义初始值如何使用。



**主函数`main`的返回值：**

`main`的返回值是`int`类型，如果没有写`return`，编译器会隐式插入`return 0`。

返回0表示执行成功，其他值表示执行失败，非0值的具体含义是机器决定的，为了使返回值与机器无关，`cstdlib`头文件定义了两个「预处理变量」：`EXIT_SUCCESS`和`EXIT_FAILURE`，分别表示执行失败和成功。



#### 6.3.3 返回数组指针

数组不能被拷贝，所以函数不能返回数组。但是函数可以返回数组的指针或者引用。

但是需要注意点：函数的形参列表也跟在函数名后且「形参列表应该先于数组的维度」

```cpp
int (*func(int i))[10]
{

}
```

把变量名替换成了函数名，同时数组的维度放在了最后。可以按照下面的顺序来逐层理解该声明：

-   `func(int i)`表示调用`func`函数时需要一个int类型的实参
-   `(*func(int i))`表示我们可以对函数的执行结果进行解引用操作
-   `(*func(int i))[10]`表示解引用操作得到一个维度是10的数组
-   `int (*func(int i))[10]`表示这个数组是int数组



**使用尾置返回类型：**

在C++11新标准中还有一种简化的方法，称为「**尾置返回类型**」(trailing return type)。任何函数的定义都可以用尾置返回类型，使用方法如下：

```cpp

auto func(int i) -> int (*)[10]
{
    return nullptr;
}

```



**使用`decltype`：**

还有一种情况，如果我们知道函数返回的指针指向哪个数组，我们可以使用`decltype`声明返回类型：

```cpp
int odd[] = {1, 3, 5, 7};
int even[] = {2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPttr(int i)
{
    return (i % 2) ? &odd : &even; //返回一个指向int数组的指针
}
//返回引用
decltype(odd) &arrPttr2(int i)
{
    return (i % 2) ? odd : even; //返回一个指向int数组的引用
}
```

`decltype`不会把数组转换成指针，所以需要加一个`*`



### 6.4 函数重载

如果「同一作用域」内的几个函数「名字相同」但「形参列表」不同，称为「**函数重载**」(overloaded)。`main`函数不能重载。

**定义重载：**

-   只有返回值不同不构成重载

**判断两个形参是否相同：**

有时候两个形参列表看起来不一样，但实际上是相同的：

```cpp
bool lookup(const Account &acct);
bool lookup(const Account&);//省略了形参的名字
```



```cpp
typedef Phone Telno;
bool lookup(const Phone&);
bool lookup(const Telno&);// Telno和Phone类型相同
```



**重载和`const`形参：**

顶层`const`不影响传入函数的对象，一个拥有顶层`const`的形参无法和另一个没有顶层`const`形参区分开来，下面两组函数参数的区别都是顶层`const`：

```cpp
bool lookup(Phone);
bool lookup(const Phone);

bool lookup(Phone *);
bool lookup(Phone *const);
```

上面两组声明之间是等价的。



但是，底层`const`可以实现函数重载：

```cpp
bool lookup(Account &);
bool lookup(const Account &);//这两个是不同的函数

bool lookup(Account *);
bool lookup(const Account *);//不同的函数
```

在上面的例子中，编译器可以通过实参是否是常量来推断应该使用哪个函数。因为`const`不能转换成其他类型，所以只能吧`const`对象传递给`const`形参。但是对于「非常量对象」或者「指向非常量对象的指针」，编译器会优先使用非常量版本。



**`const_cast`和重载：**

`const_cast`在重载函数的情况下最有用。举个例子：

```cpp
//比较两个string对象的长度,返回较短那个的引用
const string &shorterString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是`const string`的引用。当我们对两个非常量的`string`实参调用这个函数时，返回的结果仍然是`const string`的引用，但是我们需要的结果是和实参一样的普通引用，使用`const_cast`可以做到这一点：

```cpp

string &shorterString(string & s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string &>(r);
}
```



**调用重载的函数：**

调用重载函数有三种可能的结果：

-   编译器找到一个与实参**最佳匹配**（best match）的函数，并生成调用该函数的代码
-   找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**（no match）的错误信息
-   有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时编译器发出**二义性调用**（ambiguous call）错误。



#### 6.4.1 重载与作用域

>   需要注意⚠️：将函数声明置于局部作用域内不是一个好的选择。



如果我们在内层作用域中声明名字（函数名、变量名等），它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名：

```cpp
string read();
void print(const string&);
void print(double );
void fooBar(int ival)
{
    bool read = false;//新作用域,这个read变量隐藏了外层的read函数
    // string s = read();//错误, read是一个bool变量,不是函数
    void print(int ); //新作用域,隐藏了之前所有的print
    print(3.13); //调用的是void print(int)
    // print("Value"); //错误,不能转换
}
```

需要注意的是，内层作用域的名字会导致编译器忽略外层作用域所有同名实体。在C++中，名字查找发生在类型检查之前。



### 6.5 特殊用途的语言特性



#### 6.5.1 默认实参

-   一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。
-   一个函数可以被声明多次，后述的后续声明能为之前那些没有默认值的形参添加默认实参，而且该形参右侧所有形参都必须有默认值
-   局部变量不能作为默认实参。

#### 6.5.2 内联函数和`constexpr`函数

调用函数一般比求等价表达式的值要慢一些。

**内联函数：**

在函数前加`inline`关键字，回像编译器发出一个请求，但是编译器可以忽略这个请求。一般内联机制适用于规模较小、流程直接、频繁调用的函数。



**`constexpr`函数：**

`constexpr`函数是指能用于常量表达式的函数。定义`constexpr`函数的方法与其他函数类似，不过需要遵循几项约定：

1.   函数的返回类型以及所有形参的类型都是字面值类型
2.   函数中必须有且只有一条`return`语句



内联函数和`constexpr`函数通常定义在头文件中。

#### 6.5.3 调试帮助

C++程序可以包含一些用于调试的代码，但是这些代码只在开发程序中使用。当应用程序编写完成准备发布的时候，需要先屏蔽调试代码。这种方法需要用到两项预处理功能：assert和NDEBUG。

**`assert`预处理宏：**

`assert`是一种「预处理宏」。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。

```cpp
assert(expr);
```

首先对`expr`求值，如果表达式为0，`assert`输出信息并终止程序执行。如果表达式为真（非0），`assert`什么也不做。

`assert`宏常用于检查「不能发生」的条件。



**NDEBUG预处理变量：**



### 6.6 函数匹配



**确定候选函数和可行函数：**

函数匹配的第一步是选定本次调用相对应的重载函数集，集合中的函数称为「**候选函数**」（candidate function）。候选函数具备两个特征：

1.   与被调用的函数同名
2.   其声明在调用点可见

第二步是从候选函数中选出能被这组实参调用的函数，称为「**可行函数**」。可行函数也有两个特征：

1.   其形参数量与本次调用提供的实参数量相等（如果函数含有默认实参，可能形参数量会大于提供的实参数量）
2.   每个实参的类型与对应的形参类型相同，或者能转换成形参的类型



**寻找最佳匹配（如果有的话）：**

基本思想是：实参类型与形参类型越接近，它们匹配的越好。如果有且只有一个函数满足下列条件，则匹配成功：

-   该函数的每个实参的匹配都不劣于其他可行函数需要的匹配
-   至少有一个实参的匹配优于其他可行函数提供的匹配



举个例子：

有下面两个函数：

```cpp
f(int, int);
f(double, double);
```

如果用`f(3, 3.6)`来调用f函数，编译器将最终因为调用具有二义性而拒绝请求，上面两个可行函数谁也不能说服另一个。

>   在实际应用中，尽量避免强制类型转换。



#### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：

1.   精确匹配，包括：
     -   实参类型和形参类型相同
     -   实参从数组类型或函数类型转换成对应的指针类型
     -   向实参添加顶层`const`或者从实参中删除顶层`const`
2.   通过`const`转换实现的匹配（添加底层`const`）
3.   通过类型提升实现匹配
4.   通过算术类型转换实现的匹配
5.   通过类类型转换实现的匹配



**函数匹配和`const`实参：**

```cpp
Record lookup(Account &);
Record lookup(const Account&);
const Account a;
Account b;
lookup(a);//调用lookup(const Account&)
lookup(b);//调用lookup(Account &)
```

第二个调用`lookup(b)`显然两个函数都是可行的，但是常量版本不需要类型转换，显然更精确。指针类型的形参也类似。顶层`const`不能作为函数重载。



### 6.7 函数指针

函数指针指向的是函数而非对象。函数的类型由它的「返回类型」和「形参类型」共同决定，与函数名无关。

```cpp
bool lengthCompare(const string&, const string&);
```

该函数的类型是`bool(const string&, const string &)`。要想声明一个可以指向该函数的指针，只需要使用指针替换函数名即可：

```cpp
bool (*pf)(const string&, const string&);//pf指向一个函数，pf未初始化
```

我们从声明的名字`pf`开始观察，`pf`前有一个`*`，所以`pf`是一个指针；右侧是形参列表，表示`pf`指向的是一个函数，左侧的`bool`代表返回值类型。



>   `*pf`两侧的`()`括号必不可少，如果不写这对括号，`pf`是一个返回值为`bool *`的函数
>
>   ```cpp
>   bool *pf(const string&, const string&);
>   ```



**使用函数指针：**

当我们把函数名作为一个值使用时，该函数自动转换成指针。例如，将`lengthCompare`的地址赋值给`pf`：

```cpp
pf = lengthCompare;
pf = &lengthCompare; //与上面等价，&符号是可选的
```



我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：

```cpp
bool b1 = pf("hello", "goodbye"); //调用lengthCompare函数
bool b2 = (*pf)("hello", "goodbye");// 等价调用
bool b3 = length("hello", "goodbye"); //等价调用
```

在指向不同类型的指针之间不存在转换规则。但我们可以为函数指针赋一个`nullptr`或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。



**重载函数的指针：**

与数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，但是实际上却是当作指针使用：

```cpp

//第三个形参是函数类型, 它会自动转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string&));

//等价声明: 显式将形参定义为指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string&, const string&));

//可以直接把函数作为实参使用, 它会自动转换成指针
void test()
{
    useBigger(s1, s2, lengthCompare);
}
```



直接使用函数指针类型十分繁琐。类型别名和`decltype`能简化函数指针的使用

```cpp
void test02()
{
    //Func和Func2是等价的类型,都是函数类型
    typedef bool Func(const string &, const string &);
    typedef decltype(lengthCompare) Func2;


    //FuncP和FuncP2是指向函数的指针
    typedef bool (*FuncP)(const string&, const string&);
    typedef decltype(lengthCompare) *FuncP2;//等价类型

    //需要注意的是,decltype关键字并不会返回指针类型, 需要在结果前加上*

    //useBigger的等价声明,下面两条语句是一样的
    //第一条语句中编译器会自动将Func转换成指针
    void useBigger(const string&, const string&, Func);
    void useBigger(const string&, const string&, FuncP2);

}
```

需要注意，函数类型和函数指针类型是不同的，但是在函数的形参列表中，编译器会自动将函数类型转换成指针。



**返回指向函数的指针：**

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，必须把返回类型写成指针形式，编译器不会自动将函数返回类型当作对应的指针类型处理。想声明一个返回函数指针的函数，最简单的方法是使用类型别名：

```cpp
using F = int(int*, int); //F是函数类型，不是指针
using PF = int(*)(int *, int); //PF事指针类型
```

返回类型不会自动转换成指针，我们必须显式将返回类型指定为指针：

```cpp
PF f1(int); //正确
F f1(int); //错误，不能直接返回函数
F *f1(int); //正确，显式指定返回值为指针
```



还可以用下面的方式直接声明`f1`：

```cpp
int (*f1(int))(int *, int);
```

由内到外阅读这条声明语句，`f1`有形参列表，所以`f1`是一个函数，`f1`前面有`*`，所以`f1`是一个指针，指针类型也有参数列表，所以指针指向函数，该函数的返回类型是`int`。

`(int)`是f1的形参列表，`(int *, int)`才是返回指针指向的函数的形参列表。

尾置返回类型更加直观：

```cpp
auto f1(int) -> int(*)(int *, int);// 效果同上
```



**将`auto`和`decltype`用于函数指针类型：**

`decltype`作用于某个函数时，它返回函数类型而非指针类型。因此需要显式加上`*`以表明我们需要返回指针，而非函数本身。



## 7. 类

### 7.1 定义抽象数据类型

#### 7.1.2 定义成员函数

成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。定义在类的内部的函数是隐式的`inline`函数。



**`this`指针：**

当我们在调用成员函数时，实际上是在替某个对象调用它。成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址来初始化`this`。例如：

```cpp
total.isbn();
```

实际上，编译器会把`total`的地址传递给隐式形参`this`：

```cpp
//伪代码
Sales_data::isbn(&total);
```

`total`是`Sales_data`类型。



任何对类成员的直接访问都被看作`this`的隐式调用，任何自定义名为`this`的参数或者变量的行为都是非法的，我们可以直接在成员函数体内使用`this`，但是没有什么必要。

由于`this`的指向不能修改，所以`this`是一个常量指针。



**`const`成员函数：**

有的成员函数在参数列表之后有一个`const`关键字：

```cpp
string isbn() const 
{
    return bookNo;
}
```

这个`const`是修改隐式`this`指针的类型。默认情况下，`this`的类型是「指向类类型非常量版本的常量指针」，例如对于类`Sales_data`，`this`的类型是`Sales_data * const`，也就是说指针有顶层`const`。**在默认情况下，我们不能把`this`绑定到一个常量对象上，这也就导致我们不能在常量对象上调用普通的成员函数。**

我们在成员函数参数列表后加一个`const`关键字，这种成员函数被称为「常量成员函数」，这样的函数不能可以读取调用它的对象的数据成员，但是不能写入新值。

>   常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。



**类作用域和成员函数：**

编译器分两步处理类：

-   首先编译成员的声明
-   再编译成员函数体（如果有的话）

所以，成员函数体可以随意使用类中的其他成员，而无需在意这些成员的出现次序。



#### 7.1.4 构造函数

构造函数（constructor）用来初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数也有一个参数列表和函数体，同时也能重载。

构造函数不能被声明成`const`，当我们创建一个`const`对象时，知道构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在`const`对象的构造过程中可以向其写值。



**合成的默认构造函数：**

只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数，编译器自动创建的也叫「合成的默认构造函数」（synthesized default constructor）。这个合成的默认构造函数按照如下规则来初始化类的数据成员：

-   如果存在类内的初始值，用它来初始化成员
-   否则，默认初始化该成员



合成的默认构造函数只能用于非常简单的类，对于一个普通的类，必须定义它自己的默认构造函数，原因有三：

1.   编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认构造函数。
2.   对于某些类来说，合成的默认构造函数可能执行错误的操作，如果定义在块中的内置类型或复合类型（数组和指针）的对象被默认初始化，则它们的值是未定义的
3.   有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员，这个成员的类型没有默认构造函数。



C++11有如下语法，可以要求编译器生成默认构造函数：

```cpp
Sales_data() = default;
```

如果`=default`在类内部，则默认构造函数是内联的；如果在外部则不是。

还可以使用「构造函数初始列表」来初始化成员变量。

当某个数据成员被构造函数初始化列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。通常情况下，构造函数使用类内初始化是一个不错的选择，如果编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。



#### 7.1.5 拷贝、赋值和析构

对象在几种情况下会被拷贝：

-   初始化变量
-   以值传递或返回一个对象等

使用`=`赋值运算符会发生对象的赋值操作。

如果我们不主动定义这些操作，编译器会自动合成它们，但是某些类不能依赖合成的版本。



### 7.2 访问控制与封装

-   `class`和`struct`关键字唯一的区别是默认访问权限不同，前者是private的，后者是public的。



#### 7.2.1 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的「友元」(friend)。如果类香把一个函数作为它的友元，只需要**增加***一条以`friend`关键字开始的函数声明语句即可，这条声明叫做友元声明，友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，但是一般来说最好在类定义的开始或者结束前的位置集中声明友元。

**友元的声明：**

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次普通声明（有的编译器可能不需要，但是最好还是提供一个独立的函数声明）。

### 7.3 类的其他特性

#### 7.3.1 类成员再探

**定义类型成员：**

类可以自定义某种类型再类中的别名，用来定义类型的成员必须先定义后使用，因此类型成员通常出现在类开始的地方：

```cpp
class Screen
{
public:
    //这两条语句是等价的
    typedef std::string::size_type pos;
    using pos = std::string::size_type;
};
```



**成员函数：**

可以使用`=default`告诉编译器为我们合成默认的构造函数，

函数体写在类内会隐式内联：定义在类内部的成员函数是自动`inline`的，定义在类外部的成员函数可以显式使用`inline`修饰函数（这个`inline`写在类内和类外都可以）。同时在声明（类内）和定义（类外）的地方使用`inline`是合法的，但是最好在类外定义的地方说明`inline`，这样更容易理解。



**可变数据成员：`mutable`关键字**

在某些特殊时候，我们希望在一个`const`成员函数内修改一个数据成员，这时我们可以在变量的声明中加入`mutable`关键字，一个「可变数据成员」（mutable data member）永远不会是`const`，即使它是`const`对象的成员，所以它可以被`const`成员函数修改。

```cpp
class A
{
public: 
    void some_member() const;

private:
    mutable size_t access_ctr; //在const对象内也能修改
};

void A::some_member() const
{
    ++access_ctr;
}

void test01()
{
    const A a{};
    a.some_member();
}
```



**类数据成员的初始值：**

在C++11标准中，最好的方式就是把这个默认值的声明成一个类内初始值，当我们提供一个类内初始值的时候，必须用`=`或者`{}`表示。



#### 7.3.2 返回`*this`的成员函数

如果返回值是引用，那么就是返回一个左值，这些函数返回的是对象本身而不是副本，可以链式编程。

如果返回类型不是引用，那么返回的是`*this`的副本，而不是原来的对象了。

**从`const`成员函数返回`*this`：**

一个`const`成员函数如果以引用的形式返回`*this`，那么它的返回类型将是常量引用，也就不能再继续调用非`const`的成员函数。

**基于`const`的重载：**

根据成员函数是否是`const`的，可以作为重载的条件。当一个成员调用另一个成员时，`this`指针在其中隐式地传递。当常量对象调用`display`返回的是常量，当非常量对象调用`display`返回的是非常量。同时如果修改`display`的逻辑，只需要修改`do_display`即可，而不用修改多个地方。

```cpp
class Screen 
{
public:
    //根据对象是否是const重载了display函数
    
    //非常量版本的display会将*this转换为常量版本传入do_display
    Screen &display(ostream &os)
    {
        do_display(os);
        return *this;
    }

    const Screen &display(ostream &os) const
    {
        do_display(os);
        return *this;
    }

private:
    void do_display(ostream &os) const
    {
        os<< "Test" << endl;
    }
};
```



#### 7.3.3 类的声明

我们也可以只声明类而不定义它：

```cpp
class Screen;
```

这种声明有时被称为「前向声明」(forward declaration)，它向程序中引入了名字`Screen`并且指明它是一种类型。对于`Screen`而言，在它声明之后定义之前是一个「**不完全类型**」(incomplete type)，此时我们只知道`Screen`是一个类类型，但是不清楚它到底包含哪些成员。

**不完全成员的使用场景：**

-   可以定义指向这种类型的指针或者引用
-   可以声明（但不能定义）以不完全类型作为参数或者返回值类型的函数



我们创建一个类的对象前这个类必须被定义过，否则编译器不知道需要多少空间，所以一个类的成员类型不能是该类自己，但是一个类的名字出现，就被认为是声明过了，所以可以类允许包含指向它自身的引用或者指针。



#### 7.3.4 友元再探

友元函数可以定义在类的内部，这样的函数是隐式内联的。

**类之间的友元关系：**

如果一个类指定了友元类，则友元类的成员函数可以访问到此类「包括非公有成员在内」的所有成员  。

友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。



**成员函数作为友元：**

要想令某个成员函数作为友元，我们必须仔细组织程序的结构来满足声明和定义的彼此依赖关系。

```cpp
class Y;

class X
{
public:
    void visit();
private:
    Y *p;
};

class Y
{
public:
    friend void X::visit();
private:
    X x;
};

void X::visit()
{
    cout << sizeof(p->x) <<endl;
}
```



**函数重载与友元：**

如果一个类想把一组重载函数声明为它的友元，它必须把这组函数中每一个分别声明。



**友元声明和作用域：**

```cpp
struct Z
{
    friend void  f()
    {
    //    友元函数可以定义在类的内部
    }
    Z() { f(); } //错误, f还没有被声明
    void g();
    void h();
};
void Z::g()
{
    return f(); //错误f还没有被声明
}

void f(); //声明f
void Z::h()
{
    return f(); //正确,现在f的声明在作用域中
}
```

可以直接在类内部定义友元函数，但是**还是必须在类外提供相应的声明从而使得函数可见**。

友元声明的作用是影响访问权限，它本身并非普通意义上的声明。



### 7.4 类的作用域

类有：数据成员、 函数成员、类型成员(typedef)

 **作用域和定义在类外部的成员：**

>   这里的概念就是我觉得最抽象的所谓作用域相关的内容了。

**一个类就是一个作用域**，在类的外部，成员的名字被隐藏起来了，所以我们在类的外部定义成员函数时必须同时提供类名和函数名。

一旦遇到了类名，定义的剩余部分（参数列表和函数体）就在类的作用域之内了，无需在它们前再写`类名::`了。



但是，函数的返回类型通常出现在函数名之前，返回类型中使用的名字都位于类的作用域之外。**此时返回类型必须指明它时哪个类的类型成员。**



#### 7.4.1 名字查找与类的作用域

>   这一章节解决了一个长期困扰我的一个问题 ：为什么C++有时候需要先声明再使用，而有时候不用？

**名字查找**(name lookup)，也就是寻找与所用名字最匹配的声明的过程，一般比较简单直接：

-   首先在名字所在的块中寻找其声明语句，**只考虑在名字使用之前出现的声明**
-   如果没找到，继续查找外层作用域
-   如果最终没有找到匹配的声明，则程序报错



但是对于定义在类内部的成员函数来说，不需要考虑类中定义的顺序。因为类的定义分为两步：

-   首先编译成员的声明
-   直到类全部可见后才编译函数体

>   编译器处理完类中的全部声明后才会处理成员函数的定义。



**用于类成员声明的名字查找：**

这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。



**类型名要特殊处理：**

在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型， 则类不能再**之后**重新定义该名字。

```cpp
typedef double Money;
string bal;
class Account
{

public:
    Money balance() //使用外层作用域的Money
    {
        return bal;
    }

private:
    typedef double Money; //错误, 不能重新定义Money
    Money bal;
};

```

在一些编译器中能顺利通过这种代码。

**所以类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后**。

>   这里有一个问题，《C++ Primer 5th》把typedef称为定义，但是https://learn.microsoft.com/zh-cn/cpp/cpp/declarations-and-definitions-cpp?view=msvc-170，也就是微软的官方文档把typedef称为声明。
>
>   「typedef绝对是declare（声明）而不是define」，查阅一些资料，这个问题是存在争议的，两者都有。
>
>   如果把typedef称为声明，那么上面的论述就似乎有点问题了，因为编译器会先编译成员的声明。



**成员定义中的普通块作用域的名字查找：**



### 7.5 构造函数再探

#### 7.5.1 构造函数初始值列表

使用构造函数初始化列表类似于「初始化操作」，而在构造函数内赋值类似于「先定义、再赋值」。



**构造函数的初始值有时必不可少：**

如果成员是`const`或者引用的话，则必须被初始化

```cpp
class ConstRef
{
public:
    // ConstRef(int i1)
    // {
    //     i = i1;
    //     ci = i1;//错误, 不能给const 赋值
    //     ri = i; //错误,ri没被初始化
    // }

    ConstRef(int i1) : i(i1), ci(i1), ri(i) {}
    
private:
    int i;
    const int ci;
    int &ri;
};
```

所以最好使用初始值列表，并养成构造函数初始值的习惯。



**成员初始化的顺序：**

成员初始化的顺序 与它们在类中定义的顺序一致，当用一个成员初始化另一个成员时，可能出现问题：

```cpp
class X
{
    int i;
    int j;
public:
    
    X(int val) : j(val), i(j) {} //未定义的: i会在j之前被初始化
    
};
```

试图用未定义的j来初始化i。所以尽量避免用成员初始化其他成员。



**默认实参和构造函数：**

如果提供了默认实参，则相当于多提供了一个默认构造函数：

```cpp
class Y
{
    int i;
public:
    Y(int i = 1) : i(i) {}//相当于提供了两个构造函数
};
Y y{};//调用默认构造函数
```



#### 7.5.2 委托构造函数 

C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的「**委托构造函数**」(delegating constructor)。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，可以把一部分或者全部的构造任务委托给其他构造函数：

```cpp

class Z
{
private:
    int i;
    int j;
    int k;
public:
    Z(int i, int j, int k) : i(i), j(j), k(k)
    {}
    Z() : Z(1, 2, 3) {}//全部委托
    Z(int i) : Z(i, 2, 3) {}
};
```



#### 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认构造函数在下面的情况发生

-   当我们在块作用域内不使用任何初始值定一个非静态变量或者数组时
-   当一个类**本身含有类类型的成员**且使用合成的默认构造函数时
-   当类类型成员没有在构造函数初始值列表中显式地初始化时



值初始化在以下情况发生：

-   在数组初始化过程中如果我们提供的初始值少于数组的大小时
-   当我们不使用初始值定义一个局部静态变量时
-   当我们通过书写一个形如`T()`的表达式显式地请求值初始化时。



#### 7.5.4 隐式的类类型转换

如果构造函数只接受**一个实参**，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为「**转换构造函数**」。

>    一个实参这个规则在C++11中已经被打破了，现在多个实参也可以。

例如`Sales_data`类中，接受 string 的构造函数和接受 istream 的构造函数，那么在需要`Sales_data`的地方，我们可以使用 string 和 istream 替代，假设有函数`combine(Sales_data &s)`，我们可以传入一个string对象：

```cpp
string s = "9-9-9";
combine(s);//这里string类型会转换为Sales_data对象，这是一个临时对象
```



**只允许一步类类型转换：**

下面代码时错误的：

```cpp
combine("9-9-9");
```

这里需要两步转换：字符串-> string -> Sales_data，所以错误，我们可以显式的把`9-9-9`先转换成`string`或`Sales_data`对象：

```cpp
combine(string("9-9-9"));//正确，第一步显式，第二步隐式
combine(Sales_data("9-9-9"));//正确，第一步隐式，第二步显式
```

>    多说一句，对于多个参数的转换，需要把它们用`{}`包起来

**类类型转换不是总是有效：**

意思就是：看你需不需要这种编译器自作聪明的转换，因为这种情况大都是生成匿名对象，普通的引用不能接受匿名对象，常量引用才可以接受匿名对象，当然也可以值传递，这行代码结束后就不能再访问这个对象了。



**`explicit`关键字**

如果在构造函数前使用`explicit`关键字，则不允许隐式类类型转换。



**标准库的使用：**

-   单个参数的`const char*`的string的构造函数不是`explicit`的
-   vector接受一个容量参数的构造函数是`explicit`的

```cpp
class complex
{
private:
    double x;
    double y;
public:
    complex(double x, double y) : x(x), y(y)
    {}

    complex(double x) : x(x), y(0)
    {}
    complex operator+(const complex &a)
    {
        return complex(x + a.x, y + a.y);
    }

};

void needComplex(const complex &a)
{

}

void test02()
{
    complex a(1, 2);
    complex c = a + 1.0;
    needComplex(1.0);
    needComplex(complex(1,2));
    needComplex({1.0, 20.0});
}
```



#### 7.5.5 聚合类

**聚合类**（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化方法。当一个类满足如下条件时，我们说它是聚合的：

-   所有的成员都是public的
-   没有定义任何构造函数
-   没有类内初始值
-   没有基类，也没有虚函数

```cpp
struct Data
{
    int ival;
    string s;
};

void test01()
{
    //可以直接使用花括号来初始化聚合类的数据成员
    //顺序要与声明的一直
    Data val = {0, "Anna"};
}
```

缺点：

-   要求类的所有成员都是public的
-   容易出错
-   添加或者删除一个成员之后，所有的初始化语句也要更新



#### 7.5.6 字面值常量类

`constexpr`函数的参数和返回值必须是「字面值类型」，除了算数类型、指针和引用外，某些类也是字面值类型。字面值类型的类可能含有`constexpr`函数成员。这样的成员必须符合`constexpr`函数的所有要求，它们是隐式`const`的。



数据成员都是字面值类型的「聚合类」是「字面值常量类」。如果一个类不是聚合类，但是符合下述要求，则也是一个字面值常量类：

-   数据成员都必须是字面值类型
-   类必须至少有一个`constexpr`构造函数
-   如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数
-   类必须使用析构函数的默认定义，该成员负责销毁类的对象。



**constexpr构造函数：**

constexpr构造函数可以声明为`=default`。

constexpr要求函数唯一的可执行语句就是返回语句，但是构造函数又不能有返回语句，所以constexpr构造函数一般是空的，但是必须用初始化列表初始化数据成员，同时初始值必须使用`constexpr`构造函数 或者 是一条常量表达式。

constexpr构造函数用于生成 constexpr对象以及 constexpr函数的参数或返回类型。



### 7.6类的静态成员

**声明静态成员：**

我们可以用`static`声明静态成员。类的静态成员与对象无关，对象中不会包含任何与静态数据成员有关的数据。

静态成员函数也不包含`this`指针，静态成员函数不能声明为`const`的（因为const是用来修饰this指针），同时也不能使用this指针。



**定义静态成员：**

静态成员也可以再类外定义，但是不能重复`static`关键字，这个关键字只能出现在类内部。

静态数据成员与「全局变量」类似，一旦被定义，就存在于程序的整个生命周期内。



**静态成员的类内初始化：**

通常情况下，类的静态成员应该在「类外」初始化。但是我们可以为静态成员提供`const`整数类型的类内初始值，不过要求静态成员必须是「字面值常量类型的constexpr」。

即使一个常量静态数据成员在类内被初始化了，通常情况下也应该在类的外部定义一下该成员。

```cpp
class Account
{
public:
    static double rate()
    {
        return 30.8;
    }
    static void rete(double);

private:
    //字面值常量类型的constexpr必须给定初始值,进行类内初始化
    static constexpr int period = 30;
    //非常量的静态值不能类内初始化
    static int s_a;
    //const的常量可以不初始化, 也可以初始化
    static const int s_b;
    static const int s_c = 30;
    double a[period];
};

//类外都不用加static关键字
//如果再类的内部提供了初始值, 则成员在类外的定义不能再指定一个初始值了
constexpr  int Account::period;
//类内未初始化的常量可以在类外初始化
int Account::s_a = 30;
const int Account::s_b = 3;
const int Account::s_c;

```



**静态成员可以是不完全类型：**

类的数据成员不可以是「不完全类型」，只能是不完全类型的引用或者指针，但是静态成员可以是不完全类型。也就是说，一个类的静态成员的类型可以是该类本身

```cpp

//一个类的静态成员的类型 可以是该类本身

class Bar
{
private:
    static Bar mem1;//正确,静态成员和指针可以是不完全类型
    Bar *mem2;
    Bar mem3; //错误, 数据成员必须是完全类型
};
```

同时静态数据成员可以作为默认实参，但是非静态数据成员不能作为默认实参（很简单，因为它与对象有关）



## 8. IO库

>   虽然I/O库在C++的使用非常非常多，但是想要具体理解还是有些抽象的。

我们需要知道程序中常出现的关于I/O的设施：

-   `istream`：输入流类型，提供输入操作
-   `ostream`：输出流类型，提供输出操作
-   `cin`：一个`istream`对象，从标准输入读取数据
-   `cout`：一个`ostream`对象，向标准输出写入数据
-   `cerr`：一个`ostream`对象，通常用于输出程序错误消息，写入到标准错误
-   `>>`运算符：用来从一个`istream`对象读取输入数据
-   `<<`运算符，用来向一个`ostream`对象写入输出数据
-   `getline`函数，从一个给定的`istream`读取一行数据，存入一个给定的`string`对象中



>   什么是标准输入和标准输出？
>
>   当命令解释程序（即shell）运行一个程序的时候，它将打开三个文件，对应当文件描述符分别为0，1，2，依次表示标准输入、标准输出、标准错误。事实上，0，1，2在Linux中对应的是同一个文件：`/dev/pts/0`，pts代表远程终端，tty代表本地终端。
>
>   所以如果不重定向，标准输出其实就是打印到终端上，如果重定向到文件中，就输出到了文件中。
>
>   标准输入则是键盘向终端的输入。
>
>   也叫控制台IO。



### 8.1 IO类

我们已经使用过的IO类型和对象都是关联到用户的控制台窗口的，但是这还不够，如果像读写命名文件或者使用IO操作处理`string`中的字符串。除此之外，还可能需要处理宽字符。



标准库有三个IO的头文件：

-   `iostream`头文件包含类：
    -   `istream`：从流读取数据
    -   `ostream`：向流中写入数据
    -   `iostream`：读写流
-   `fstream`：头文件中包含类：
    -   `ifstream`：从文件读取数据
    -   `ofstream`：向文件写入数据
    -   `fstream`：读写文件
-   `sstream`头文件中包含类
    -   `istringstream`：从`string`读取数据
    -   `ostringstream`：向`string`写入数据
    -   `stringstream`：读写`string`

同时，为了支持使用宽字符的语言，标准库还定义了一组类型和对象来处理`wchar_t`类型的数据，宽字符版本的类型和函数的名字以`w`开头，例如`wistream`，它们和普通版本的类在同一个头文件中。



**IO类型间的关系**

设备类型和字符大小都不会影响IO操作：

-   可以用`>>`读取控制台、磁盘文件或者`string`的数据。
-   读取的字符可以用`char`对象或`wchar_t`对象存储。



IO类存在下面的继承关系，可以看到`ifstream`和`istringstream`都继承了`istream`。所以，这些类型的对象都可以像`cin`一样被使用。

![doc](https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/doc.svg)



#### 8.1.1 IO对象没有拷贝和赋值

IO对象是不能被拷贝的，所以「流类型」不能设置为行参或返回类型，进行IO操作的函数通常以「引用方式」传递流和返回流。读写一个IO对象回改变其状态，所以传递和返回的引用不能是`const`的。



#### 8.1.2 条件状态

IO操作回发生错误，这是无可避免的，一些错误是可以恢复的，但是一些操作是不能恢复的。

下表列出了IO类所定义的一些「函数」和「标志」，可以帮助我们访问和操作流的「条件状态」（condition state）：

`strm`代表IO类型，`s`代表对象

| 函数或标志          | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| `strm::iostate`     | `strm`是一种「IO类型」，`iostate`提供了表达条件状态的完整功能，本质是`unsigned int`，会定义一个变量`__rdstate_` |
| `strm::badbit`      | 常量`0x1`，用来指出流已崩溃                                  |
| `strm::failbit`     | 常量`0x2`，用来指出一个IO操作失败了                          |
| `strm::eofbit`      | 常量`0x4`，用来指出流到达了文件结尾                          |
| `strm::goodbit`     | 常量`0x0`，用来指出流没有处于错误状态                        |
| `s.eof()`           | 检查是否设置了`eof`位，具体操作是`(__rdstate_ & eofbit) != 0` |
| `s.fail()`          | 检查是否设置了`failbit`或`badbit`位，具体操作是`(__rdstate_ & (failbit | badbit)) != 0` |
| `s.bad()`           | 检查是否设置了`badbit`位，操作类似                           |
| `s.clear(flags)`    | 将流`s`中对应的条件状态复位（那一位设置为0），没有参数默认清楚所有错误状态 |
| `s.setstate(flags)` | 将流`s`对应条件状态复位                                      |
| `s.rdstate()`       | 返回`s`的当前状态，返回值为`strm::iostate`                   |



>   关于上表的`strm`是什么，一开始我也比较困惑，书中是这么写的：「在表8.2（IO库状态）中第一行，“strm::iostate strm 是一种IO类型，在表（8.1）（p278）中已列出。」
>
>   查阅网上发现有人有同样的问题：
>
>   https://juejin.cn/post/7157246183516160036，但他说的有点离谱了。。。
>
>   其实这个很简单，`strm`就是IO类型`istrem`,`ostream`....等等的一种，任何一种IO类型都定义了一个`iostate`类型。
>
>   例如：
>
>   ```cpp
>   iostream::iostate
>   ```
>
>   其实他就是一个`unsigned int`。



一个流一旦发生错误，之后所有的操作都会失败，只有当一个流处于无错误状态时，我们才可以对其进行读写数据，确定一个流对象状态的最简单的方法是**将它当作一个条件来使用**：

```cpp
while(cin >> word)
{
    ...
}
```

`while`循环检查`>>`表达式返回的流的状态，如果输入操作成功，流保持有效状态，则条件为真。



**查询和管理流的状态**

```cpp
void test04()
{
    auto old_state = cin.rdstate(); //记录cin当前状态
    cin.clear();//使cin有效
    
    int x;
    cin >> x;
    //...操作cin
    cin.setstate(old_state); //将cin置为原来状态
    
    //复位failbit和badbit,其他不变
    cin.clear(cin.rdstate() & ~ios::failbit & ~ios::badbit);
}
```



**8.1.2 练习：**

```cpp
//练习1
istream& func(istream& is)
{
    int v;
    
    //C++逗号运算符, 返回的结果是最后一个表达式的值,所以下面的代码不是is出现错误停止,而是遇到eof停止
    while (is >> v, !is.eof())
    {
        if(is.bad())
        {
            throw runtime_error("IO流错误");
        }
        if(is.fail())
        {
            cerr << "数据错误" << endl;
            is.clear();
            is.ignore(100, '\n');
            continue;
        }
        cout << v << endl;
    }
    is.clear();
    return is;
}

void test05()
{
    func(cin);
}
```

>   ignore函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此 cin.ignore() 就等效于 cin.ignore(1, EOF)， 即跳过一个字符。



#### 8.1.3 管理输出缓冲

每一个「输出流」都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行如下的代码：

```cpp
os << "please" ;
```

文本串可能立刻打印出来，也有可能被操作系统保存在缓冲区中等待打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成「单一的系统级写操作」，因为一次写操作可能比较耗时。

导致缓冲刷新（也就是数据真正写到输出文件）的原因有：

-   程序正常结束，`mian`函数的`return`。
-   缓冲区满。
-   使用操作符`endl`,`flush`,`ends`显式刷新。
-   使用操作符`unitbuf`设置留的内部状态，使得接下来每次`cout`操作都会刷新缓冲区。默认情况下`cerr`是设置`unitbuf`的，也就是说`cerr`的内容都是立即刷新的
-   一个输出流可能被关联到另一个流，在这种情况下，当读写「被关联的流」时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin`和`cerr`都被关联到`cout`。因此，读`cin`或写`cerr`都会导致`cout`的缓冲区被刷新。



**刷新缓冲区**

```cpp
cout << "hi" << endl; //多输出一个换行，然后刷新缓冲区
cout << "hi" << flush; //不附加任何额外字符，刷新缓冲区
cout << "hi" << ends; //多输出一个「空字符」，然后刷新缓冲区

cout << unitbuf; //接下来所有的cout都会立即刷新缓冲区
cout ...
    
cout << nounitbuf; //回到正常的缓冲方式
```



>   需要注意的是，如果程序异常终止，那么不会刷新输出缓冲区，它输出的数据可能留在缓冲区中。
>
>   那么就会出现`cout`语句已经执行，但是终端没有输出，所以在调试程序的时候一定要注意这一点，尽量刷新缓冲区。



**关联输入和输出流**

当一个输出流被关联到一个输入流的时候，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将`cout`和`cin`关联在一起：

```cpp
cin >> v;
```

这会导致`cout`的缓冲区。



**`tie()`函数：**

```cpp
std::basic_ostream<CharT,Traits>* tie() const;

std::basic_ostream<CharT,Traits>* tie( std::basic_ostream<CharT,Traits>* str );
```

`tie()`函数有两个重载：

-   不带参数的版本，返回指向输出流的指针：

    -   如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针
    -   如果本对象未关联到流，则返回空指针
-   带参数的版本，接受一个指向`ostream`的指针，将自己关联到这个`ostream`。
    -   返回值则是本次关联前，该对象关联的输出流



我们可以将一个`istream`对象关联到另一个`ostream`对象，也可以将一个`ostream`对象关联到另一个`ostream`对象。

```cpp
void test06()
{
    cin.tie(&cout); //仅仅只是展示,它们本来就关联在一起

    ostream* old_tie = cin.tie(nullptr);//oldtie指向的是cout
    
    cin.tie(&cerr);// 关联
    cin.tie(old_tie)//复原
}
```



### 8.2 文件输入输出

**fstream的特有操作：**

`fstream`是头文件`fstream`中定义的一个类型

```cpp
fstream fstrm; //创建一个未绑定的文件流
fstream fstrm(s);//创建一个fstream，并打开名为s的文件。s可以是C风格字符串指针或者string类型
fstream fstrm(s, mode);//按指定的方式打开文件，这些构造函数都是explicit的
fstrm.open(s);//打开并绑定名为s的文件。默认的文件mode依赖于fstream的类型
fstrm.close();//关闭与fstrm绑定的文件
fstrm.is_open();//返回一个bool值，文件是否成功打开

```



#### 8.2.1 使用文件流对象

文件流对象可以关联对象与文件，同时还能对文件进行读写。

我们可以用`fstream`代替`iostream&`，对文件进行读写。

如果`open`失败，则会设置流的状态。

```cpp
void test01()
{
    string ifile = "test.txt";
    ifstream in(ifile);//输入文件流打开并绑定 test.txt文件
    if(in.fail())
    //if(!in)也可以
    {
        cerr << "没打开" << endl;
    }
    ofstream out;//输出文件流没有关联到任何文件

    out.open(ifile + ".copy");
}
```



**自动构造和析构**

当一个`fstream`对象被销毁时，`close`会自动调用



**打开一个文件，将文件中的字符按空格分割，存入vector中：**

```cpp
//练习8.4
void test02()
{
    string ifile = "./test.txt";
    ifstream in(ifile);

    if(!in)
    {
        cerr << "文件打开失败" << endl;
        exit(-1);
    }

    vector<string> v;
    string line;
    //按行输出
    // while(getline(in, line))

    //按空格输出
    while(in >> line)
    {
        v.push_back(line);
    }

    in.close();

    //打印
    for(auto s : v)
    {
        cout << s << " ";
    }
    cout << endl;
}
```

>   需要注意的是，如果使用的开发环境是clion，生成的可执行文件在`cmake-build-debug-xxx`目录下，对应的`test.txt`文件也应该在这个目录下，而不是在源代码的目录。



#### 8.2.2 文件模式

文件流都有一个关联的「**文件模式**」(file mode)，用来指出如何使用文件：

| 文件模式 | 描述                                             |
| -------- | ------------------------------------------------ |
| in       | 以读方式打开                                     |
| out      | 以写方式打开                                     |
| app      | append，每次写操作都是添加，也就是定位到文件末尾 |
| ate      | at end，打开文件后立刻定位到文件末尾             |
| trunc    | truncate，截断文件                               |
| binary   | 以二进制方式进行IO                               |



调用`open()`函数或者初始化流都可以指定文件模式，但有如下限制：

-   只可以对`ofstream`或`fstream`对象设置`out`模式
-   只可以对`ifstream`或`fstream`对象设置`in`模式
-   只有当`out`被设定的时候才可以设置`trunc`模式，默认也是`trunc`而不是`app`
-   `trunc`和`app`互相冲突
-   `ate`和`binary`可以用于任何类型的文件流对象，并且可以和任何文件模式组合使用



与`fstream`关联的文件默认以`in`和`out`模式打开。



**以out模式打开文件会丢弃以有数据**

默认是`trunc`模式

**每次调用`open`时都会确定文件模式：**

如果想从文件末尾添加，必须使用`app`模式。



```cpp
void test03()
{
    //打开就会清空test.txt中的内容
    ofstream on("test.txt", ios::app);
    on << "你好" << endl;
    on << "我是fileIO" << endl;
    on.close();
}
```

向文件末尾添加内容。



### 8.3 string流

`sstream`头文件定义了三个类型来支持内存IO，这些类型可以向`string`写入数据，从`string`读取数据，就像`string`是一个IO流一样。



>   那么，为什么要用stringstream？而不是直接使用string呢？



`istringstream`从`string`读取数据，`ostringstream`向`string`写入数据，而头文件`stringstream`读写都包含。它也继承自`iostream`头文件中定义的类型，它还有一些特有的操作：



| stringstream特有的操作 | 作用                                                        |
| ---------------------- | ----------------------------------------------------------- |
| `sstream strm;`        | `strm`是一个未绑定的`stringstream`对象，`sstream`是一个类型 |
| `sstream strm(s);`     | 一个保存s（string类型对象）的拷贝的sstream对象              |
| `strm.str()`           | 返回保存的string对象的拷贝                                  |
| `strm.str(s)`          | 将s拷贝到strm中，返回void                                   |



#### 8.3.1 使用`istringstream`

当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常考虑使用`istringstream`。



**案例：**

假设有一个文件，列出了一些人和他们的电话号码，电话号码可能有多个：

```
jack 13988328888 13888888888
tom 12777777777
jane 12099999999 12388888888 12488888888
```



需要读取数据，并用合适的结构存储。



```cpp
/*  
 *  Description :  使用string流
 *  Created by 旋风冲锋龙卷风 on 2023/01/30 15:08
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <sstream>
#include <vector>
#include <fstream>

using namespace std;

class Person
{
public:
    friend ostream& operator<<(ostream& os, const Person& p);
    string name;
    vector<string> phones;
    Person(const string &name, const vector<string> &phones) : name(name), phones(phones)
    {}

    Person()
    {}

    virtual ~Person()
    {

    }
};

ostream& operator<<(ostream& os, const Person& p)
{
    cout << p.name << " ";
    for(auto s : p.phones)
    {
        cout << s << " " ;
    }
    cout << endl;
    return os;
}

void test01()
{
    vector<Person> people;
    string line, word; //分别保存来自输出的一行单词
    ifstream ifs("phone.txt");
    if(!ifs)
    {
        cerr << "打开失败" << endl;
        exit(-1);
    }

    //getline从输入流读取整行数据到line中
    while(getline(ifs, line))
    {
        Person p;
        //将每行的内容绑定到istringstream对象
        //如果record写在循环外面，每次用str(line)绑定
        //在循环结束后要record.clear(),因为每次读到最后都会触发文件结束信号，需要clear才能继续读入
        istringstream record(line);
        record >> p.name;
        //当读取玩record中的内容后，循环结束
        //读取完string的内容后同样触发"文件结束"信号,下一个输入会失败
        while(record >> word)
        {
            p.phones.push_back(word);
        }
        people.push_back(p);
    }

    for(auto& p : people)
    {
        cout << p << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

如果使用string，不好按照空格分割开来：

分割空格：

```cpp
int main(){  
    string str="i am a boy";  
    istringstream is(str);  
    string s;  
    while(is>>s)  {  
        cout<<s<<endl;  
    }  
} 
```



#### 8.3.2 使用`ostringstream`

当我们逐步构造输出，希望最后一起打印的时候，`ostringstream`是很有用的。例如，对于上面的例子，我们可能想逐个验证电话号码并改变其格式。所有所有的号码都是有效的，输出到一个新的文件，包含改变格式之后的号码；对于无效的号码，我们不会将其输入到新文件中，而是打印错误信息。



所以，我们可以先将输出内容写入到内存中，也就是`ostringstream`：

```cpp
    for(auto& person : people)
    {
        ostringstream formatted, badNums;
        for(const auto& nums : person.phones)
        {
            badNums << " " << nums;
        }
        cout << badNums.str() << endl;
    }
```

上面的代码没有实现判断格式，而是直接全部打印，中间用空格隔开。







>   写在后面：
>
>   从学习编程开始就困扰我多年的IO类，短短十多页有了全新理解，《C++ Primer 》真乃神书也。



## 9. 顺序容器

>   本章的内容与《STL源码剖析》重合，因此记录较少。

读取访问权限冲突，表明迭代器在执行`++`操作时报错，因为已经失效的迭代器不能再进行自增运算了。 在网络上看到有人这样写，但是在我的环境`clang14.0`下，没有迭代器是和地址绑定的，可以进行`++`自增。

 
