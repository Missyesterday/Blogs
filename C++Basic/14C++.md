# 现代C++编程实战

## 开篇

>   C++是一门多范式的通用编程语言。

多范式，是因为 C++ 支持面向过程编程，也支持面向对象编程，也支持泛型编程，新版本还可以说是支持了函数式编程。同时，上面这些不同的范式，都可以在同一项目中组合使用，这就大大增加了开发的灵活性。因此，C++ 适用的领域非常广泛，小到嵌入式，大到分布式服务器，到处可以见到 C++ 的身影。

典型情况是，需要性能的组件用 C++ 来写，整个应用程序融合多种不同的语言。

完成同样的功能，C++ 需要的代码行数一般是 Python 的三倍左右，而性能则可以达到 Python 的十倍以上。



Bjarne 有一个洋葱理论：抽象层次就像一个洋葱，是层层嵌套的。如果想用较低的抽象层次表达较高的概念，就好比一次切过了很多层洋葱，你会把自己的眼泪熏出来的。学习应该自顶向下。



本专栏主要介绍「某个 C++ 的功能为什么存在和应该在什么情况下使用。」



>   ptr念`put`
>
>   std念`斯图的`



## 基础篇

### 01. 堆、栈、RAII：C++里该如何管理资源

#### 1.1 基本概念

**堆**，英文是 heap，在内存管理的语境下，指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则，就会造成内存泄漏。

C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：

-   new 和 delete 操作的区域是 free store
-   malloc 和 free 操作的区域是 heap

但 new 和 delete 通常底层使用 malloc 和 free 来实现，所以 free store 也是 heap。鉴于对其区分的实际意义并不大，所以一般都指「堆」



**栈**，英文是 stack，在内存管理的语境下，指的是「函数调用过程中产生的本地变量和调用数据的区域」。这个栈和数据结构里的栈高度相似，都满足“后进先出”（last-in-first-out 或 LIFO）。

**RAII**，完整的英文是 Resource Acquisition Is Initialization，是 C++ 所特有的资源管理方式。有少量其他语言，如 D、Ada 和 Rust 也采纳了 RAII，但主流的编程语言中， C++ 是唯一一个依赖 RAII 来做资源管理的。



**RAII 依托栈和析构函数**，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法，也能有效地对内存进行管理。RAII 的存在，也是垃圾收集虽然理论上可以在 C++ 使用，但从来没有真正流行过的主要原因。



#### 1.2 堆

 `malloc`失败返回`NULL`，下面的代码会导致队上分配内存

```cpp
auto ptr = new std::vector<int>();
```

动态内存带来的不确定性——内存分配耗时需要多久？失败了怎么办？



C++的内存管理器是什么？C++不会进行垃圾收集。

-   对于连续未使用的内存块，通常内存管理器需要将其合并成一块。
-   垃圾收集操作有很多不同的策略和实现方式



内存碎片，就是

<img src="https://static001.geekbang.org/resource/image/18/5a/1814fb6093744c64ac9d3861fb4d3a5a.png?wh=1042*744" style="zoom:50%;" />



<img src="https://static001.geekbang.org/resource/image/a7/3b/a7b72d6062c5cd798a2de991bffd713b.png?wh=1042*744" style="zoom:50%;" />

如上图所示，图1e未合并的情况就是会出现「内存碎片」。



漏掉`delete`就会「内存泄漏」，看一个例子：

```cpp

void foo()
{
  bar* ptr = new bar();
  …
  delete ptr;
}
```



1.   中间省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。
2.   在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。



#### 1.3 栈

```cpp

void foo(int n)
{
  …
}

void bar(int n)
{
  int a = n + 1;
  foo(a);
}

int main()
{
  …
  bar(42);
  …
}
```

上面代码中栈的变化可以用下图表示：

<img src="https://static001.geekbang.org/resource/image/6e/3b/6ef3d653af7fa6c9728ea4bea348093b.png?wh=1446*710" style="zoom: 40%;" />

在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。

上图每种颜色表示某个函数栈用的栈空间，这个空间称为「栈帧」（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 -fomit-frame-pointer，一般就是指栈帧。

新的函数进入后，**首先做一些必须的保存工作**，然后会调整栈指针，分配出本地变量所需的空间，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。



栈的优点：

1.   分配/释放 简单
2.   不会出现内存碎片

对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。



**在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）**，下面的代码演示了栈展开：

```cpp

#include <stdio.h>

class Obj {
public:
  Obj() { puts("Obj()"); }
  ~Obj() { puts("~Obj()"); }
};

void foo(int n)
{
  Obj obj;
  if (n == 42)
    throw "life, the universe and everything";
}

int main()
{
  try {
    foo(41);
    foo(42);
  }
  catch (const char* s) {
    puts(s);
  }
}
```

执行结果：

```
Obj()
~Obj()
Obj()
~Obj()
life, the universe and everything
```

也就是说：「不管是否发生了异常，obj中的析构函数都会得到执行」。

C++中所有的变量缺省都是：值语义，如果不使用 * 和 & 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。

>   值语义就是一个对象被系统标准的复制方式复制后，与被复制的对象之间毫无关系，可以彼此独立改变互不影响。

除此之外，C++还有引用语义，在大部分其他语言里，访问成员只用 .，但在作用上实际等价于 C++ 的 ->。





#### 1.4 RAII

C++其实是支持将对象存储在栈上面，但是很多情况下，对象不应该存储在栈上，比如：

-   对象很大
-   对象的大小在编译时不能确定
-   对象是函数的返回值，但由于特殊原因，不能使用对象的值返回



delete空指针是合法的。

new 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 bad_alloc），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 new 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。delete 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。



在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：

-   关闭文件（fstream 的析构就会这么做）
-   释放同步锁
-   释放其他重要的系统资源

在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：关闭文件（fstream 的析构就会这么做）释放同步锁释放其他重要的系统资源。

>   就是在值语义的情况下，派生类对象赋值给基类对象，派生类独有独有的数据会丢失。但是在指针、引用情况下，由于多态性，可以将派生类对象的指针赋值给基类指针，而不会导致对象切片。
>
>   把指向堆内存的指针包裹到一个局部对象中，该对象的析构函数在析构时会 delete 自己的指针变量，这样可以通过栈展开保证new出来的内存被释放，不会遗漏。