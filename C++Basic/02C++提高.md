# 02 C++提高编程

主要针对 C++**泛型编程**和**STL**技术，探讨C++更为深层的使用。

## 1. 模版

### 1.1 模版的概念

模版就是建立**通用的道具**，大大**提高复用性**。

1.   模版不能直接用，它只是一个框架
2.   模版也有一定的使用范围，并不是真正万能的

### 1.2 函数模版

-   除了面向对象编程之外，C++另一种编程思想称之为**「泛型编程」**，主要利用的技术就是模版
-   C++提供两种模版机制：**「函数模版」**和**「类模版」**。

#### 1.2.1 函数模版语法

**函数模版的作用**：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个**虚拟的类型**来代表。

**语法：**

```cpp
template<typename T>
函数声明或定义
```

**解释：**

`template` : 一个关键子，声明创建模版

`typename` ：也是关键字，表明其后面的符号是一种数据类型，可以用`class`代替

T：通用数据类型，名称可以替换，通常为大写字母，约定俗成用大写`T`

**举例：**

```cpp
/*  
 *  Description : 函数模版
 *  Created by 旋风冲锋龙卷风 on 2022/11/13 23:17
 *  个人博客 : http://letsgofun.cn/
 */


#include <iostream>

using namespace std;

//有如下场景
//两个整型交换
void swapInt(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

//交换两个浮点型的函数
void swapDouble(double &a, double & b)
{
    double tmp = a;
    a = b;
    b = tmp;
}

//函数模版
//声明一个模版，告诉编译器后面紧跟着代码的T不要报错，T是一个通用数据类型
template<typename T>
void mySwap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

void test01()
{
    int a = 10;
    int b = 20;
    swapInt(a, b);
    cout << a << " " << b << endl;

    double c = 1.1;
    double d = 2.2;
    swapDouble(c, d);
    cout << c << " " << d << endl;

}

//利用函数模版来实现交换
void test02()
{
    //有2种方式使用函数模版
    //1. 自动类型推导
    int a = 10;
    int b = 20;
    mySwap(a, b);
    cout << a << " " << b << endl;

    //2. 显式指定类型,指定上面形参T的类型
    mySwap<int>(a, b);
    cout << a << " " << b << endl;
}


int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

函数模版的意义是所谓`类型参数化`，将某个数据的类型作为参数传递给函数。

两种使用方式：自动推到和显式指定

#### 1.2.2 函数模版注意事项

**注意事项：**

-   自动类型推到，必须导出一致的数据类型`T`才可以使用
-   模版必须要确定`T`的数据类型，才可以使用

**示例：**

```cpp
/*  
 *  Description : 函数模版的注意事项
 *  Created by 旋风冲锋龙卷风 on 2022/11/13 23:43
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//1.自动类型推导必须推导出一致的数据类型T才可以使用
//2.模版必须确定T的数据类型才可以使用

//typename可以替换为class，二者没有区别
template<class T>
void mySwap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

void test01()
{
    int a = 10;
    int b = 20;
    char c = 'a';
    mySwap(a, b);
    cout << a << " " << b << endl;

    //推导不出一致的数据类型
    //mySwap(a, c);


}

//模版必须确定T的数据类型才可以使用
template<class T>
//这种情况就只能使用显式指定类型，自动推导不了
void func()
{
    cout << "func的调用" << endl;
}

void test02()
{
    func<int>();
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

**总结：**

-   使用模版时必须确定出通用数据类型`T`，并且能够推导出一致的类型

#### 1.2.3 函数模版案例

**案例描述：**

-   利用函数模版封装一个排序的函数，可以对**不同的数据类型数组**进行排序
-   从小到大的选择排序
-   分别利用char数组和int数组进行测试

**示例：**

```cpp
/*  
 *  Description : 函数模版写一个排序算法
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 00:13
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

template<class T>
void mySwap(T &a, T &b)
{
    T tmp = a;
    a = b;
    b = tmp;
}

template<class T>
void mySort(T arr[], int len)
{
    for(int i = 0; i < len; i++)
    {
        int min = i; //找第i个最小值的下标
        for (int j = i + 1; j < len; j++)
        {
            if(arr[min] > arr[j])
            {
                min = j;
            }
        }
        if(min != i)
        {
            mySwap(arr[i], arr[min]);
        }
    }
}

//打印数组的模版
template<class T>
void printArr(T arr[], int len)
{
    for(int i = 0; i < len; i++)
    {
        cout << arr[i] << " ";
    }
    cout << endl;
}

void test01()
{
    //测试char数组
    char charArr[] = "badcfe";
    int len = sizeof(charArr) / sizeof(char) - 1;
    cout << len << endl;
    mySort(charArr, len);
    printArr(charArr, len);

}

void test02()
{
    int intArr[] = {3, 4, 5, 1, 3, 2};
    int len = sizeof(intArr) / sizeof(int);
    mySort(intArr, len);
    printArr(intArr, len);

}

void test03()
{

    //字符数组有一个结尾符号
    char testArr[] = "";
    cout << sizeof(testArr) / sizeof(char) << endl;

    //但是其他类型没有
    int intArr[] = {};
    cout << sizeof(intArr) / sizeof(int) << endl;
}

int main()
{
    test03();
    return EXIT_SUCCESS;
}
```

#### 1.2.4 普通函数与函数模版的区别

-   普通函数调用时可以发生自动类型转换（隐式类型转换）
-   函数模版调用时，如果利用自动类型推导，不会发生隐式类型转换
-   如果利用显式指定类型的方式，可以发生隐式类型转换

**示例：**

```cpp
/*  
 *  Description : 普通函数和函数模版的区别
 *  1.普通函数调用时可以发生隐式类型转换
 *  2.函数模版利用自动类型推导,不可以发生隐式类型转换
 *  3.函数模版用显式类型,可以发生隐式类型转换
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 00:28
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//普通函数
int myAdd01(int a, int b)
{
    return a + b;
}

//函数模版
template<class T>
T myAdd02(T a, T b)
{
    return a + b;
}

void test01()
{
    int a = 1;
    int b = 99;
    //'c'的ASCII码就是99
    char c = 'c';
    //真1假0
    bool d = true;
    cout << myAdd01(a, d) << endl;
}

void test02()
{
    int a = 1;
    int b = 99;
    char c = 'c';

    cout << myAdd02(a, b) << endl;

    //如果推导不出相同的数据类型,但是又想使用自动类型推导,必须使用显式指定类型的方式来调用函数模版
    cout << myAdd02<int>(a, c) << endl;
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   建议使用显式指定类型的方式调用函数模版



#### 1.2.5 普通函数与函数模版的调用规则

**调用规则如下：**

1.   如果函数模版和普通函数都可以实现，优先调用普通函数
2.   可以通过空模版参数列表来强制调用函数模版
3.   函数模版也可以发生重载
4.   如果函数模版可以产生更好的匹配，优先调用函数模版
     -   普通函数的隐式类型转换的优先级  <  函数模版的匹配的优先级

**示例：**

```cpp
/*  
 *  Description : 普通函数与函数模版的调用规则
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 00:40
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void myPrint(int a, int b)
{
    cout << "调用的是普通函数" << endl;
}

template<class T>
void myPrint(T a, T b)
{
    cout << "调用的是函数模版" << endl;
}

template<class T>
void myPrint(T a, T b, T c)
{
    cout << "调用的重载函数模版" << endl;
}

void test01()
{
    int a = 10;
    int b = 20;
    //调用的是普通函数
    myPrint(a, b);

    //通过空模版参数列表
    //调用的是函数模版
    myPrint<>(a, b);

    //调用重载函数模版
    myPrint(a, b, 1);

    //如果函数模版产生更好的匹配,优先调用函数模版
    //普通函数的隐式类型转换的优先级  <  函数模版的匹配的优先级
    char c1 = 'a';
    char c2 = 'b';
    myPrint(c1, c2);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   总结，提供了函数模版后，最好不要提供普通函数了，容易产生二义性

#### 1.2.6 模版的局限性

**局限性：**

-   模版的通用性并不是万能的

**例如：**

```cpp
template<class T>
void f(T a, T b)
{
    a = b;
}
```

上述代码中如果传入的`a`和`b`是数组，则无法实现。

**再例如：**

```cpp
template<class T>
void f(T a, T b)
{
    if(a > b)
    {
        ...
    }
}
```

在上述代码中，如果`T`的数据类型传入的是类似`Person`这样的自定义数据类型，也无法正常运行。

因此C++为了解决这种问题，提供模版的重载，可以为这些特定的类型提供**具体化模版**。

**示例：**

```cpp
/*  
 *  Description : 模版的局限性,对于某些特定数据类型,需要用具体化的方式实现
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 01:15
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//自定义数据类型
class Person
{
public:
    Person(const string &name, int age) : name(name), age(age)
    {}
    //重载==运算符
    bool operator==(Person &p)
    {
        if(name == p.name && age == p.age)
        {
            return true;
        }
        return false;
    }
    string name;
    int age;
};

//对比两个数是否相等
template<class T>
bool myCompare(T &a, T &b)
{
    if(a == b)
    {
        return true;
    }
    else
    {
        return false;
    }
}

//利用具体化的Person的版本来实现代码，具体化会优先调用
//也就是特殊情况特殊处理
template<> bool myCompare(Person &p1, Person &p2)
{
    cout << "调用重载" << endl;
    if(p1.name == p2.name && p1.age == p2.age)
    {
        return true;
    }
    return false;
}

void test01()
{
    int a = 10;
    int b = 20;

    bool ret = myCompare(a, b);
    //0假1真
    cout << ret << endl;
}

void test02()
{
    Person p1("Tom", 10);
    Person p2("Tom", 10);
    //1. 重载== 符号可以解决
    //2. 具体化模版也可以解决
    cout << myCompare(p1, p2) << endl;
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   总结：
>
>   1.   模版并不是万能的，利用具体化的模版，可以解决自定义类型的通用化
>   2.   学习模版不是为了写模版，而是在STL中能够运用系统提供的模版

### 1.3 类模版

#### 1.3.1 类模版语法

**类模版作用：**

-   建立一个通用类，类中的成员 数据类型可以不具体制定，利用一个**虚拟的类型**来实现

**语法：**

```cpp
template<class T>
    类
```

**举例：**

```cpp
/*  
 *  Description : 类模版
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 01:27
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>

using namespace std;

template<class NameType, class AgeType>
class Person
{
public:
    Person(NameType mName, AgeType mAge) : m_name(mName), m_age(mAge)
    {}
    void show()
    {
        cout << m_name << " " << m_age << endl;
    }

public:
    NameType m_name;
    AgeType m_age;
};

void test01()
{
    //<>内的为模版参数列表,就是把类型也作为参数
    Person<string, int> p1("张三", 18);
    p1.show();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 1.3.2 类模版和函数模版的区别

1.   类模版没有自动类型推导的使用方式，只能使用显式类型指定的方式
2.   类模版在参数列表中可以有默认参数

**示例：**

```cpp
/*  
 *  Description : 类模版和函数模版的区别
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 01:33
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

//类模版的默认参数列表，可以不用写全
template<class NameType = string, class AgeType = int>
class Person
{
public:
    Person(NameType mName, AgeType mAge) : m_name(mName), m_age(mAge)
    {}
    void showPerson()
    {
        cout << m_name << " " << m_age << endl;
    }
public:
    NameType m_name;
    AgeType m_age;
};

void test01()
{
    //1.类模版不能使用自动类型推导,只能用<>显式指定类型
    Person<string, int> p1("张三", 19);
    p1.showPerson();
}

void test02()
{
    Person<> p("张三", 18);
    p.showPerson();
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 1.3.3 类模版中成员函数创建时机

类模版中成员函数和普通类中成员函数的创建时机是有区别的：

-   普通类中的成员函数一开始就创建
-   类模版中的成员函数在调用的时候才创建

**示例：**

```cpp
/*  
 *  Description : 类模版中成员函数和普通类中成员函数的创建时机是有区别的
 *  类模版中成员函数在调用时才创建
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 01:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Person1
{
public:
    void showPerson1()
    {
        cout << "Person1 show" << endl;
    }
};
class Person2
{
public:
    void showPerson2()
    {
        cout << "Person2 show" << endl;
    }
};

template<class T>
class MyClass
{
public:
    T obj;
    //类模版中的成员函数
    //下面的代码是可以编程成功的
    void func1()
    {
        obj.showPerson1();
    }
    void func2()
    {
        obj.showPerson2();
    }
};

void test01()
{
    //类模版中成员函数是在调用的时候才创建
    MyClass<Person1> m;
    m.func1();

    MyClass<Person2> m2;
    m2.func2();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 1.3.4 类模版对象做函数参数

**类模版实例化出的对象，向函数传参的方式：**

1.   指定传入类型：直接显示对象的数据类型
2.   参数模版化：将对象中的参数变为模版进行传递
3.   整个类模版化：将这个对象类型模版化进行传递

**示例：**

```cpp
/*  
 *  Description :  类模版对象做函数参数:
 *                 1. 指定传入类型
 *                 2.参数模版化
 *                 3.整个类模版化
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 13:53
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

template<class T1, class T2>
class Person
{
public:
    Person(T1 name, T2 age) : m_age(age), m_name(name)
    {}

    void showPerson()
    {
        cout << m_name << " " << m_age << endl;
    }

    T1 m_name;
    T2 m_age;
};

//1.指定函数类型
void printPerson1(Person<string, int>&p)
{
    p.showPerson();
}

//参数模版化
template<class T1, class T2>
void printPerson2(Person<T1, T2> &p)
{
    p.showPerson();
    cout << "T1的数据类型为: " << typeid(T1).name() << endl;
    cout << "T2的数据类型为: " << typeid(T2).name() << endl;
}

//整个类模版化
template<class T>
void printPerson3(T &t)
{
    t.showPerson();
    cout << "T的数据类型为: " << typeid(T).name() << endl;
}


void test01()
{
    Person<string, int> p1("张三", 18);
    printPerson1(p1);
}

void test02()
{
    Person<string, int> p2("李四", 19);
    printPerson2(p2);
}

void test03()
{
    Person<string, int> p3("王五", 20);
    printPerson3(p3);
}

int main()
{
    test03();
    return EXIT_SUCCESS;
}
```



>   在实际开发中，第一种方法指定传入类型最常见，后两种都是函数模版配合使用类模版，较为复杂。



#### 1.3.5 类模版与继承



**当类模版碰到继承时，需要注意：**

1.   当子类继承的父类是一个类模版时，子类在声明的时候，要指定出父类中`T`的类型
2.   如果不指定，编译器无法给子类分配内存
3.   如果想灵活指定父类中`T`的类型，子类也需要变为类模版



**示例：**

```cpp
/*  
 *  Description : 类模版与继承
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 14:17
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

template<class T>
class Base
{
    T m;
};

//必须要知道父类中T的类型,才能继承给子类
class Son : public Base<int>
{

};

void test01()
{
    Son s1;
}

//如果想灵活指定父类中T类型,子类也需要变成类模版
template<class T1, class T2>
class Son2 : public Base<T2>
{
public:
    Son2()
    {
        cout << "T1的类型为: " << typeid(T1).name() << endl;
        cout << "T2的类型为: " << typeid(T2).name() << endl;
    }
    T1 obj;
};

void test02()
{
    Son2<int, char> s2;
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



>   如果父类是类模版，子类需要指定父类的类型，也可以用模版代替。



#### 1.3.6 类模版成员函数类外实现



**示例：**

```cpp
/*  
 *  Description : 类模版中成员函数的类外实现
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 14:27
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

template<class T1, class T2>
class Person
{
public:
    //成员函数的类内实现,但是很多时候成员函数都是类外实现
    Person(T1 name, T2 age);
    //{}

    void showPerson();
    //{
    //    cout << "姓名: " << this->m_Name << " ,年龄: " << this->m_Age << endl;
    //}

    T1 m_Name;
    T2 m_Age;
};

//构造函数类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
    this->m_Age = age;
    this->m_Name = name;
}

//成员函数的类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
    cout << "姓名: " << this->m_Name << " ,年龄: " << this->m_Age << endl;
}

void test01()
{
    Person<string, int> p("张三",19);
    p.showPerson();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   需要加上类模版参数列表



#### 1.3.7 类模版分文件编写

**问题：**

-   类模版中成员函数的创建时机是在调用阶段，导致分文件编写时链接不到

**解决：**

-   方法1：直接包含`.cpp`源文件
-   方法2：将声明和实现写到同一个文件中，并更改后缀为`.hpp`，`.hpp`是约定的名称，并不是强制



**示例：**

```cpp
/*  
 *  Description : 类模版分文件编写
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 14:42
 *  个人博客 : http://letsgofun.cn/
 */
//


//这里使用`.h`文件会出错,这与类模版成员函数的创建时机有关
//#include "Person.cpp"
//但是直接包含.cpp文件不合适,不符合一般习惯
//还可以将.cpp和.h的内容写到一起,改为.hpp文件,.hpp约定俗称为类模版的文件
#include "Person.hpp"

void test01()
{
    Person<string, int> p("张三", 19);
    p.showPerson();
}


int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

**.hpp文件：**

```cpp

#include <iostream>
using namespace std;
template<class T1, class T2>
class Person
{
public:
    Person(T1 name, T2 age);
    void showPerson();
    T1 m_Name;
    T2 m_Age;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
    this->m_Name = name;
    this->m_Age = age;
}

template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
    cout << "姓名: " << this->m_Name << ", 年龄: " << this->m_Age << endl;
}

```

>   建议采用第二种方法



#### 1.3.8 类模版与友元

全局函数类内实现：直接在类内声明友元即可

全局函数类外实现：需要提前让编译器知道全区函数的存在



**示例：**

```cpp
/*  
 *  Description : 
 *  Created by 旋风冲锋龙卷风 on 2022/11/14 23:25
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//提前让编译器知道Person的存在
template<class T1, class T2>
class Person;
//全局函数类外实现
template<class T1, class T2>
void printPerson2(Person<T1, T2> p)
{
    cout << "类外实现的内容" << p.m_Name << " " << p.m_Age << endl;
}

//通过全局函数打印Person信息
template<class T1, class T2>
class Person
{
    //全局函数 类内实现(友元函数才能类内实现)
    friend void printPerson(Person<T1,T2> p)
    {
        cout << p.m_Name << " " << p.m_Age << endl;
    }

    //全局函数类外实现
    //加一个空模版参数列表
    //如果全局函数是类外实现，需要让编译器提前知道这个函数的存在
    friend void printPerson2<>(Person<T1, T2> p);
public:
    Person(T1 name, T2 age) : m_Name(name), m_Age(age)
    {}

private:
    T1 m_Name;
    T2 m_Age;
};


//全局函数在类内实现
void test01()
{
    Person<string, int> p("张三", 18);
    printPerson(p);
}

void test02()
{
    Person<string, int> p("Jack", 20);
    printPerson2(p);
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   全局友元函数类外实现较为复杂。建议全局友元函数配合类内实现比较简单，而且编译器可以直接识别

#### 1.3.9 类模版案例

**案例描述：**实现一个通用的数组类，要求如下：

1.   可以对内置数据类型以及自定义数据类型进行存储
2.   将数组中的数据存储到堆区
3.   构造函数中可以传入数组的容量
4.   提供对应的拷贝构造函数以及`operator=`防止浅拷贝问题
5.   提供尾插法和尾删法对数组中的数据进行增删
6.   可以通过下标的方式访问数组中的元素
7.   可以获取数组中当前元素的个数和数组的容量



**示例：**

**`myArray.hpp`：**

```cpp
//通用数组类
#pragma once
#include <iostream>
using namespace std;

template<class T>
class MyArray
{
public:
    MyArray(int capacity) : m_Capacity(capacity)
    {
        //cout << "MyArray的有参构造调用" << endl;
        this->m_Size = 0;
        this->pAddress = new T[this->m_Capacity];
    }

    ~MyArray()
    {
        //cout << "MyArray的析构调用" << endl;
        if(NULL != this->pAddress)
        {
            delete[] this->pAddress;
            this->pAddress = NULL;
        }
    }

    MyArray(const MyArray& arr)
    {
        //cout << "MyArray的拷贝构造调用" << endl;
        this->m_Size = arr.m_Size;
        this->m_Capacity = arr.m_Capacity;
        //深拷贝
        this->pAddress = new T[arr.m_Capacity];
        //拷贝arr中的数据
        for(int i = 0; i < this->m_Size; i++)
        {
            this->pAddress[i] = arr.pAddress[i];
        }
    }

    //=重载防止浅拷贝问题
    MyArray& operator=(const MyArray & arr)
    {
        //cout << "MyArray的=调用" << endl;
        //先判断原来堆区是否有数据，如果有，先释放
       if(NULL != this->pAddress)
       {
           delete[] this->pAddress;
           this->pAddress = NULL;
           this->m_Capacity = 0;
           this->m_Size = 0;
       }
       //深拷贝
       this->m_Capacity = arr.m_Capacity;
       this->m_Size = arr.m_Size;
       this->pAddress = new T[arr.m_Capacity];
       for(int i = 0; i < this->m_Size; i++)
       {
           this->pAddress[i] = arr.pAddress[i];
       }
       return *this;
    }

    //尾插法
    void push_back(const T &value)
    {
        //判断容量是否==大小
        if(this->m_Capacity == this->m_Size)
        {
            cout << "容量不足" << endl;
            return;
        }
        this->pAddress[m_Size++] = value;
        return;
    }

    //尾删法
    void pop_back()
    {
        //判断为0
        if(0 == this->m_Size)
        {
            cout << "容量为0" << endl;
            return;
        }
        //逻辑删除即可
        this->m_Size--;
    }

    //通过下标的方式访问元素,为了使得arr[i]作为左值存在，必须使用&引用返回
    T& operator[](int index)
    {
        return this->pAddress[index];
    }

    int getMCapacity() const
    {
        return m_Capacity;
    }

    int getMSize() const
    {
        return m_Size;
    }

private:
    //指针指向堆区开辟的真实数组地址
    T * pAddress;
    //维护数组的容量
    int m_Capacity;
    //数组的大小
    int m_Size;
};
```



## 2. STL初识

>   C++ = C语言 + 面向对象 + 模版编程 + STL

C++严格意义上来说，包含了四个子集，而非独立的编程语言。

### 2.1 STL的诞生

-   长久以来，希望建立一个可重复利用的东西
-   C++的**面向对象**和**泛型编程**思想，目的就是**复用性的提升**
-   大多数情况下，数据结构和算法都未能有一套标准，导致重复造轮子
-   为了建立数据结构和算法的一套标准，诞生了**STL**



### 2.2 STL基本概念

-   STL(Standard Template Library, **标准模版库**)
-   STL从广义上分为：**容器(container) 算法(algorithm) 迭代器(iterator)**
-   **容器**和**算法**之间通过**迭代器**进行无缝衔接
-   STL几乎所有的代码都采用了模版类或者模版函数

### 2.3 STL六大组件

STL大体分类六大组件：分别是**容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器**



-   容器：各种数据结构，如`vector, list, deque, set, map`等，用来存放数据
-   算法：各种常用的算法，如`sort, find, copy, for_each`等
-   迭代器：扮演了容器和算法之间的胶合剂
-   仿函数：行为类似函数，可作为算法的某种策略
-   适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
-   空间适配器：负责空间的配置与管理



### 2.4 STL中容器、算法、迭代器

**容器：**放东西（数据）用的

STL**容器**就是将运用**最为广泛的一些数据结构**实现出来，例如：数组、链表、树、栈、队列、集合、映射表等。这些容器分为：**序列式容器**和**关联式容器**：

-   序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置
-   关联式容器：二叉树结构，各元素之间没有严格物理上的顺序关系



**算法(Algorithms)：**问题的解法，用有限的步骤，解决逻辑或数学上的问题。

算法又分为**质变算法**和**非质变算法**：

-   质变算法：是指运算过程中会更改区间内的元素的内容，例如拷贝、替换、删除等
-   非质变算法：是指运算过程中不会更改区间内元素的内容，例如查找、计数、遍历、寻找极值等



**迭代器：**容器和算法之间的粘合剂

提供一种方法，使之能够依序寻访某个容器中所含的各个元素，而又无需暴露该容器的内部表示方式。算法需要迭代器才能访问容器中的元素。每个容器都有自己专属的迭代器。迭代器的使用非常类似于指针，初学阶段可以理解迭代器为指针。迭代器种类：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221115153407903.png" alt="image-20221115153407903" style="zoom:67%;" />

常用的容器中迭代器类为双向迭代器和随机访问迭代器



### 2.5 容器算法迭代器初识

#### 2.5.1 `vector`存放内置数据类型

-   容器：`vector`
-   算法：`for_each`
-   迭代器：`vector<int>:iterator`



**示例：**

```cpp
/*  
 *  Description : vector存放内置数据类型
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 15:37
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << endl;
}

void test01()
{
    vector<int> v;
    //向容器中插入数据
    for (int i = 0; i < 5; ++i)
    {
        v.push_back(i);
    }
    //通过迭代器遍历容器中的数据
    //起始迭代器,指向容器中第一个元素
    vector<int>::iterator itBegin = v.begin();
    //结束迭代器,指向容器中最后一个的元素的下一个位置
    //也就是说迭代器是包头不包尾的
    vector<int>::iterator itEnd = v.end();

    //第一种遍历方式
    while(itBegin != itEnd)
    {
        cout << *itBegin  << " ";
        itBegin++;
    }
    cout << endl;

    //第二种遍历方式
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    //第三种遍历方式
    //利用STL中提供的遍历算法 for_each(start, end, 回调函数)
    //回调函数不用加括号
    for_each(v.begin(), v.end(), myPrint);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 2.5.2 `vector`存放自定义数据类型



**示例：**

```cpp
/*  
 *  Description : vector容器存放自定义数据类型
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 15:54
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Person
{
public:
    string name;
    int age;

    Person(const string &name, int age) : name(name), age(age)
    {}
};

void test01()
{
    vector<Person> v;
    Person p1("Jack1",10);
    Person p2("Jack2",11);
    Person p3("Jack3",12);
    Person p4("Jack4",13);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    for(vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        //it是<>内的指针类型
        cout << (*it).name << " " << (*it).age << endl;
        //也可以通过->访问成员属性
        cout << it->name << " " << it->age << endl;
    }
}

//存放自定义数据类型的指针
void test02()
{
    vector<Person*> v;
    Person p1("Jack1",10);
    Person p2("Jack2",11);
    Person p3("Jack3",12);
    Person p4("Jack4",13);

    v.push_back(&p1);
    v.push_back(&p2);
    v.push_back(&p3);
    v.push_back(&p4);
    for(vector<Person*>::iterator it = v.begin(); it != v.end(); it++)
    {
        //it是<>内的指针类型
        cout << (*(*it)).name << endl;
        //也可以通过->访问成员属性
        cout << (*it)->age << endl;
    }
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 2.5.3 容器嵌套容器



**示例：**

```cpp
/*  
 *  Description : vector中嵌套vector,类似于二维数组
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 16:04
 *  个人博客 : http://letsgofun.cn/
 */
//


#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void test01()
{
    vector<vector<int>> v;

    //创建小容器
    vector<int> v1;
    vector<int> v2;
    vector<int> v3;
    vector<int> v4;
    //向小容器中添加数据
    for(int i = 0; i < 4; i++)
    {
        v1.push_back(i + 10);
        v2.push_back(i + 20);
        v3.push_back(i + 30);
        v4.push_back(i + 40);
    }
    //将小容器添加到大容器中
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);
    //遍历
    for(vector<vector<int>>::iterator it = v.begin(); it != v.end(); it++)
    {
        //*it是vector<int>的容器
        for(vector<int>::iterator it2 = (*it).begin(); it2 != (*it).end(); it2++)
        {
            cout << *it2 << " ";
        }
        cout << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



## 3. STL常用容器

### 3.1 `string`容器

#### 3.1.1 `string`基本概念

**本质：** `string`是一个C++风格的字符串，而`string`本质上是一个类

**`string`和`char *`的区别：**

-   `char *`是一个指针
-   `string`是一个类，类内部封装了`char *`，管理这个字符串，是一个`char *`类型的容器。

**特点：**

-   `string`类内部封装了很多成员方法，例如：`find, copy, delete, replace, insert`
-   `string`管理`char *`所分配的内存，不用担心复制越界和取值越界等，由内部类进行负责



#### 3.1.2 `string`构造函数

**构造函数原型为：**

-   `string();`  //创建一个空的字符串，例如：`string str;`
-   `string(const char *s)`  //使用字符串s初始化
-   `string(const string &s)` //使用一个`string`对象初始化另一个`string`对象
-   `string(int n, char c)` //使用n个字符c初始化

**示例：**

```cpp
/*  
 *  Description : string的构造函数
 *  -   `string();`  //创建一个空的字符串，例如：`string str;`
-   `string(const char *s)`  //使用字符串s初始化
-   `string(const string &s)` //使用一个`string`对象初始化另一个`string`对象
-   `string(int n, char c)` //使用n个字符c初始化
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 16:23
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

void test01()
{
    //默认构造
    string s1;
    const char * str = "hello world";
    string s2(str);
    cout << s2 << endl;
    string s3(s2);
    cout << s3 << endl;
    string s4(100, 'g');
    cout << s4 << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.1.3 `string`赋值操作

**赋值函数原型：**

-   `string& operator=(const char *s);` //char *类型字符串 赋值给当前字符串
-   `string& operator=(const string &s);` //把string s赋值给当前字符串
-   `string& operator=(char c);` //把字符c赋值给当前字符串
-   `string& assign(const char *s);`//把字符串s赋值给当前字符串
-   `string& assign(const char *s, int n);`//把字符串s的前n个字符赋给当前字符串
-   `string& assign(const string & s);`//把字符串s赋值给当前字符串
-   `string& assign(int n, char c);` //用n个字符c赋给当前字符串
-   `string &assign(const string & s, int n);` //从s的第n个位置开始赋值给当前字符串



**示例：**

```cpp
/*  
 *  Description : string的赋值操作
 *  = 和 assign
-   `string& operator=(const char *s);` //char *类型字符串 赋值给当前字符串
-   `string& operator=(const string &s);` //把string s赋值给当前字符串
-   `string& operator=(char c);` //把字符c赋值给当前字符串
-   `string& assign(const char *s);`//把字符串s赋值给当前字符串
-   `string& assign(const char *s, int n);`//把字符串s的前n个字符赋给当前字符串
-   `string& assign(const string & s);`//把字符串s赋值给当前字符串
-   `string& assign(int n, char c);` //用n个字符c赋给当前字符串


 *  Created by 旋风冲锋龙卷风 on 2022/11/15 16:31
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

void test01()
{
    const char * s1 = "abcdefg";
    cout << s1 << endl;
    string s2 = "abc";
    cout << s2 << endl;
    string s3;
    s3.assign(4, 's');
    cout << s3 << endl;
    string s4 = s3;
    cout << s4 << endl;
    string s5;
    s5 = 'a';
    cout << s5 << endl;
    string s6;
    s6.assign(s3);
    cout << s6 << endl;
    string s7;
    s7.assign(s1);
    cout << s7 << endl;
    string s8;
    s8.assign("abcdefg", 3);
    cout << s8 << endl;
    string s9;
    //注意与s8.assign("abcdefg", 3);的区别,前者是赋值前3个字符,这个是赋值从第3个开始的数据(从0开始计算,包括3自身)
    s9.assign(s7, 3);
    cout << s9 << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   用=赋值较多



#### 3.1.4 `string`字符串拼接

**函数原型：**

-   `string& operator+=(const char* str);` //重载+=操作符
-   `string& operator+=(const char c);` //重载+=操作符
-   `string& operator+=(const string &s);` //重载+=操作符
-   `string& append(const char * s);` //把字符串s附加到当前字符串结尾
-   `string& append(cosnt char *s, int n);` //把字符串s的前n个字符连接到当前字符串结尾
-   `string& append(const string &s;` //把字符串s连接到当前字符串结尾
-   `string& append(const string &s, int pos, int n);`//把字符串s中从pos开始的n个字符连接到字符串结尾，如果n缺省，则是从pos复制到末尾

>    一个中文占3个char，也就是24位。记住几个就行。

**示例：**

```cpp
/*  
 *  Description : 字符串拼接
-   `string& operator+=(const char* str);` //重载+=操作符
-   `string& operator+=(const char c);` //重载+=操作符
-   `string& operator+=(const string &s);` //重载+=操作符
-   `string& append(const char * s);` //把字符串s附加到当前字符串结尾
-   `string& append(cosnt char *s, int n);` //把字符串s的前n个字符连接到当前字符串结尾
-   `string& append(const string &s;` //把字符串s连接到当前字符串结尾
-   `string& append(const string &s, int pos, int n);`//把字符串s中从pos开始的n个字符连接到字符串结尾
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 16:50
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

void test01()
{
    string str1 = "我";
    str1 += "是谁";
    cout << str1 <<endl;
    str1 += "?";
    cout << str1 <<endl;

    string str2 = "Jack";
    str1 += str2;
    cout << str1 << endl;

    const char * str3 = ",爱玩";
    str1.append(str3);
    cout << str1 << endl;

    str1.append("游戏");
    cout << str1 << endl;

    //中文字符占三个
    str1.append("特别是LOLLOL", 12);
    cout << str1 << endl;

    string str4 = "And DNF AND DNF And DNF";
    str1.append(str4, 7, 8);
    cout << str1 << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.1.5 `string`的查找和替换

-   查找：查找指定字符串是否存在
-   替换：在指定位置替换字符串

**函数原型：**

-   `int find(const string& str, int pos = 0) const;` //从pos开始查找str第一次出现的位置
-   `int find(const char* s, int pos = 0) const;`  //从pos开始查找s第一次出现的位置
-   `int find(const char* s, int pos, int n) const; ` //从pos查找s的前n个字符第一次位置
-   `int find(const char c, int pos = 0) const` //查找字符c第一次出现位置
-   `int rfind() const;`//同上，只不过从右往左查找
-   `string& replace(int pos, int n, const string& str);` //替换从pos开始的n个字符位字符串str
-   `string& replace(int pos, int n, const  char *s);` //替换从pos开始的n个字符位字符串s

>   加在函数定义后的`const`代表不能修改`this`指针的指向内存地址的内容，也就是不能修改成员属性。默认都是从0开始。返回-1代表未找到。



**示例：**

```cpp
/*  
 *  Description : string 的查找和替换
-   `int find(const string& str, int pos = 0) const;` //从pos开始查找str第一次出现的位置
-   `int find(const char* s, int pos = 0) const;`  //从pos开始查找s第一次出现的位置
-   `int find(const char* s, int pos, int n) const; ` //从pos查找s的前n个字符第一次位置
-   `int find(const char c, int pos = 0) const` //查找字符c第一次出现位置
-   `int rfind() const;`//同上，只不过从后往前
-   `string& replace(int pos, int n, const string& str);` //替换从pos开始的n个字符位字符串str
-   `string& replace(int pos, int n, const  char *s);` //替换从pos开始的n个字符位字符串s
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 17:15
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

void test01()
{
    string str1 = "abcdefgabcdefg";
    int pos = str1.find("de");
    //不能直接cout 函数,如果没找到,会返回很长的一个错误数据,需要用int去接收
    //cout << str1.find("zz") <<endl;
    cout << pos <<endl;
    if (pos == -1)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "pos = " << pos << endl;
    }

    //rfind()是从后往前找
    pos = str1.rfind("de");
    if (pos == -1)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "pos = " << pos << endl;
    }
}

//替换
void test02()
{
    string str1 = "abcdefg";

    //从1号位置起3个字符替换成1111,而不是替换1111的前三个
    str1.replace(1, 3, "1111");
    cout << str1 << endl;
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 3.1.6 `string`字符串比较

**比较方式：**

-   字符串比较是按字符的ASCII码进行对比
-   `=` 返回 0
-   `<` 返回 -1
-   `> ` 返回 1



**函数原型：**

-   `int compare(const string &s) const;` //与字符串s进行比较
-   `int compare(const char *s) const;`  //与字符串s进行比较



**示例：**

```cpp
/*  
 *  Description :  字符串比较的操作
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 17:31
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    string str1 = "hello";
    string str2 = "hello";
    const char * str3 = "hello";
    if(str1.compare(str2) == 0)
    {
        cout << "相等" << endl;
    }
    else if(str1.compare(str2) > 0)
    {
        cout << "str1更大" << endl;
    }
    else if(str1.compare(str2) < 0)
    {
        cout << "str1更小" << endl;
    }

    if(str1.compare(str3) == 0)
    {
        cout << "==" << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   一般用于判断两个字符串是否相等



#### 3.1.7 `string`字符存取

`string`中单个字符存取有两种方式：

1.   `char& operator[](int n);`   //通过`[]`方式取字符
2.   `char& at(int n);`  //通过`at()`函数取字符



**示例：**

```cpp
/*  
 *  Description : string字符存取
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 17:38
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    string str = "hello";
    //通过[]访问单个字符
    cout << str[1] << endl;
    //通过at函数访问单个自渡
    for(int i = 0; i < str.size(); i++)
    {
        cout << str.at(i) << " ";
    }
    cout << endl;
    //修改单个字符
    str[1] = 'x';
    str.at(2) = 'y';
    cout << str << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.1.8 `string`插入和删除

**函数原型：**

-   `string& insert(int pos, const char* s);`   //插入字符串
-   `string& insert(int pos, const string & str);`//插入字符串
-   `string& insert(int pos, int n, int c);`  //在pos位置插入n个字符c
-   `string& erase(int pos, int n = npos);` //删除从pos开始的n个字符



**示例：**

```cpp

#include <iostream>

using namespace std;

void test01()
{
    string str = "hello";
    str.insert(1,"xy");
    cout << str << endl;

    str.erase(1,2);
    cout << str << endl;

    str.insert(1, 3, 'c');
    cout << str << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.1.9 `string`子串

**功能：**

-   从字符串中获取想要的子串

**函数原型：**

-   `string substr(int pos = 0, int n = npos) const;`  //返回从pos开始的n个字符组成的字符串



**示例：**

```cpp
/*  
 *  Description : string的子串
 *  Created by 旋风冲锋龙卷风 on 2022/11/15 18:50
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    string str = "abcdef";

    string subStr = str.substr(1, 3);
    cout << subStr << endl;
    
    //从2号位置开始到末尾
    subStr = str.substr(2);
    cout << subStr << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   求子串功能在实际开发中的使用非常灵活



### 3.2 `vector`容器

#### 3.2.1 `vector`基本概念

**功能：**

-   `vector`数据结构和**数组非常相似**，也被称为**单端数组**



**`vector`与普通数组的区别：**

-   数组是静态空间，而`vector`可以**可以动态扩展**



**动态扩展：**

-   并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间。

![image-20221117153441518](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221117153441518.png)

-   `vector`容器的迭代器是支持随机访问的迭代器

#### 3.2.2 `vector`构造函数



**功能描述**

-   创建`vector`容器



**函数原型：**

-   `vector<T> v;`  //采用模版实现类
-   `vector(v.begin(), v.end());` //将vbegin和vend区间（左闭右开）内的元素拷贝给本身
-   `vector(n, elem); `  //n个elem
-   `vector(const vector &v);`//拷贝构造



**示例：**

```cpp
/*  
 *  Description :  vector容器的构造
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 15:36
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

//打印容器的接口
void printVector( vector<int> &v)
{
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    //默认构造,无参构造
    vector<int> v1;

    for(int i = 0; i < 10; i++)
    {
        v1.push_back(i);
    }
    printVector(v1);

    //通过区间方式进行构造
    vector<int> v2(v1.begin(),  v1.end());
    printVector(v2);

    //n个elem
    vector<int> v3(10, 3);
    printVector(v3);

    //拷贝构造
    vector<int> v4(v3);
    v4.pop_back();
    printVector(v4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   默认构造其实就够了，后面再进行赋值



#### 3.2.3 `vector`赋值操作



**函数原型：**

-   `vector& operator=(const vector &vec);`  //重载等号赋值操作
-   `assign(beg, end);` //将[beg, end)区间中的数据拷贝给本身
-   `assign(n, elem);` //将n个elem赋值给自身



**示例：**

```cpp
/*  
 *  Description : vector的赋值操作
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 15:47
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

//打印容器的接口
void printVector( vector<int> &v)
{
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    vector<int> v1;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
    }
    printVector(v1);

    //operator=
    vector<int> v2;
    v2 = v1;
    printVector(v2);

    // assign(beg, end)
    vector<int> v3;
    v3.assign(v2.begin(),  v2.end());
    printVector(v1);

    //assign(n, elem)
    vector<int> v4;
    v4.assign(10, 1);
    printVector(v4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   vector赋值比较简单，用operator=最简单，assign也可以



#### 3.2.4 `vector`容量和大小

`capacity`永远大于等于`size()`

**函数原型：**

-   `empty();` //判断容器是否为空
-   `capacity();`//容器的容量
-   `size();` //容器中元素的个数
-   `resize(int n);`  //重新指定容器的长度为n，如果容器变长，则以默认值0填充新位置；如果容器变短，则超出的部分删除
-   `resize(int n, elem);`  //同上，但是指定默认值为elem



**示例：**

```cpp
/*  
 *  Description : 对容器的容量和大小操作
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 15:58
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

//打印容器的接口
void printVector( vector<int> &v)
{
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
    cout << "容量为: " << v.capacity() << ", 大小为: " << v.size() << ", sizeof(v) = " << sizeof(v) << endl;

}

void test01()
{
    vector<int> v1;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
    }
    printVector(v1);
    if(v1.empty())
    {
        cout << "v1为空" << endl;
    }
    else
    {
        cout << "v1不为空" << endl;
    }
    v1.resize(19);
    printVector(v1);
    
    //用自定义的2代替变长的部分
    v1.resize(30,2);
    printVector(v1);

    //如果指定的部分比原来短,超出的部分会删除
    v1.resize(10);
    printVector(v1);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.2.5 `vector`插入和删除



**函数原型：**

-   `push_back(elem)` //尾部插入elem
-   `pop_back()` //尾部删除
-   `insert(const_iterator pos, elem)` //在迭代器指向的pos插入一个elem
-   `insert(const_iterator pos, int n, int elem)`//在迭代器指向的pos插入n个elem
-   `insert(const_iterator pos)`  //删除迭代器指向的元素
-   `erease(const_iterator start, const_iterator end)`  //删除迭代器从start到end之间的元素
-   `clear()`//删除容器中所有元素

**示例：**

```cpp
/*  
 *  Description : vector容器的删除和插入
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 16:14
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>

using namespace std;

//打印容器的接口
void printVector( vector<int> &v)
{
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    vector<int> v1;
    v1.push_back(1);
    v1.push_back(2);
    v1.push_back(3);
    v1.push_back(4);
    v1.push_back(5);
    printVector(v1);

    //  尾删
    v1.pop_back();
    printVector(v1);

    //插入,第一个参数是迭代器
    v1.insert(v1.begin(), 100);
    printVector(v1);

    //在迭代器位置插入n个10
    v1.insert(v1.begin(), 2 ,10);
    printVector(v1);

    //删除第一个元素,参数也是迭代器
    v1.erase(v1.begin());
    printVector(v1);

    //删除一个区间,下面的代码类似与清空
    v1.erase(v1.begin(),v1.end());
    printVector(v1);
    
    v1.clear();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   这几个接口都很重要



#### 3.2.6 `vector`数据存取



**函数原型：**

-   `at(int index)` //返回索引index所指的数据，有边界检查
-   `operator[]` //重载了[]操作符，与数组取下标使用相同，但是没有边界检查
-   `front()` //返回容器中第一个数据元素
-   `back()` //返回容器中最后一个数据元素



**示例： **

```cpp
/*  
 *  Description : vector中的数据存取
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 16:24
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

void test01()
{
    vector<int> v1;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
    }

    //通过[]和成员函数at()都可以访问
    for(int i = 0; i < v1.size(); i++)
    {
        cout << v1[i] << " ";
        cout << v1.at(i) << " ";
    }

    //获取第一个元素和最后一个元素
    cout << "第一个元素为: " << v1.front() << ", 最后一个元素为: " << v1.back() << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.2.7 `vector`交换容器



**函数原型：**

-   `swap(vec)` //将vec与自身容器互换



**示例：**

```cpp
/*  
 *  Description : swap互换接口
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 16:32
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

void printVector(vector<int> &v)
{
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

//1. 基本使用
void test01()
{
    vector<int> v1, v2;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
        v2.push_back(9 - i);
    }

    //交换前
    cout << "交换前: " << endl;
    printVector(v1);
    printVector(v2);

    //交换
    v1.swap(v2);

    //交换后
    cout << "交换后: " << endl;
    printVector(v1);
    printVector(v2);
}

//巧用swap收缩内存空间
void test02()
{
    vector<int> v;
    for(int  i = 0; i < 100000; i++)
    {
        v.push_back(i);
    }
    //v的容量为: 131072, v的大小为: 100000
    cout << "v的容量为: " << v.capacity() << ", v的大小为: " << v.size() << endl;

    //重新指定v的大小为3
    v.resize(3);
    //v的容量为: 131072, v的大小为: 3
    //也就是说resize缩小大小不会缩小v的容量
    cout << "v的容量为: " << v.capacity() << ", v的大小为: " << v.size() << endl;

    //我们可以用swap()收缩内存
    // vector<int>(v)是一个匿名对象,会按照v的大小来初始化这个匿名对象
    //swap(v)就相当于v和匿名对象进行交换,v指向匿名对象,匿名对象指向之前的v,匿名对象执行完当前行就回收
    vector<int>(v).swap(v);
    //v的容量为: 3, v的大小为: 3
    cout << "v的容量为: " << v.capacity() << ", v的大小为: " << v.size() << endl;
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



>   通过匿名对象和swap()收缩内存



#### 3.2.8 `vector`预留空间

**功能描述：**

-   减少`vector`在动态扩容时的扩展次数



**函数原型：**

-   `reserve(int len)` //容器预留len元素长度，预留位置不初始化，元素也不可访问



**示例：**

```cpp
/*  
 *  Description : 预留空间 reserve(int len)
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 16:56
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

void test01()
{
    vector<int> v1;
    //插入100000个数据需要扩容多少次
    int num = 0;
    int *p = NULL;
    for (int i = 0; i< 100000; i++)
    {
        v1.push_back(i);

        //当指针不指向首地址时,指针指向首地址,相当于开辟了一次内存
        //num记录开辟的次数
        if(p != &v1[0])
        {
            p = &v1[0];
            num++;
        }
    }
    //18次
    cout << num << endl;

    vector<int> v2;
    //利用reserve预留空间
    v2.reserve(100000);
    num = 0;
    for (int i = 0; i< 100000; i++)
    {
        v2.push_back(i);

        //当指针不指向首地址时,指针指向首地址,相当于开辟了一次内存
        //num记录开辟的次数
        if(p != &v2[0])
        {
            p = &v2[0];
            num++;
        }
    }
    //只扩容1次,相当于第一次就分配好了100000个int的空间
    cout << num << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 3.3 `deque`容器

#### 3.3.1 `deque`容器基本概念



**功能：**

-   双端数组，可以对两端进行插入和删除



**`deque`和`vector`的区别：**

-   `vector`对于头部的插入删除效率低，时间复杂度为$O(n)$
-   `deque`对于头部插入和删除的时间复杂度为$O(1)$
-   `vector`访问元素的速度比`deque`快，这与二者内部实现有关



<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221117171158381.png" alt="image-20221117171158381" style="zoom: 67%;" />

**`deque`内部工作原理：**

`deque`内部有一个**中控器**，维护每段缓冲区的内容，缓冲区中存放真实数据，

中控器维护的是每个缓冲区的地址，使得使用`deque`时像一片连续的内存空间

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221117171724997.png" alt="image-20221117171724997" style="zoom:67%;" />

所以它的访问数据会比`vector`慢。

-   `deque`容器的迭代器也是支持随机访问的



#### 3.3.2 `deque`的构造函数



**函数原型：**

-   `deque<T> d` //默认构造
-   `deque(beg, end)` //左闭右开
-   `deque(n, elem)` //n个elem
-   `deque(const deque &d)` //拷贝构造



**示例：**

```cpp
/*
 *  Description : deque的构造函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 20:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <deque>
using namespace std;

void printDeque(const deque<int> &d)
{
    for(deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
    {
        //使用const deque就使用const_iterator
        //使用const_iterator就不能修改,也就是不能作为左值
        //*it = 1;//报错
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    deque<int> d1;
    for (int i = 0; i < 10; ++i)
    {
        d1.push_back(i);
    }
    printDeque(d1);

    deque<int> d2(d1.begin(),  d1.end());
    printDeque(d2);

    deque<int> d3(10, 19);
    printDeque(d3);

    deque<int> d4(d3);
    printDeque(d4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.3.3 `deque`赋值操作



**函数原型：**

-   `deque& operator=(const deque &deq)` //重载=操作
-   `assign(beg, end)` //将[beg, end)区间中的数据赋值给本身
-   `assign(n, elem)`//将n个elem赋值给本身



**示例：**

```cpp

/*  
 *  Description : deque的赋值
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 20:54
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <deque>
using namespace std;

void printDeque(const deque<int> &d)
{
    for(deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
    {
        //使用const deque就使用const_iterator
        //使用const_iterator就不能修改,也就是不能作为左值
        //*it = 1;//报错
        cout << (*it) << " ";
    }
    cout << endl;
}

//deque容器赋值操作
void test01()
{
    deque<int> d1;
    for (int i = 0; i < 10; ++i)
    {
        d1.push_back(i);
    }
    printDeque(d1);

    deque<int> d2;
    d2 = d1;
    printDeque(d2);

    deque<int> d3;
    d3.assign(d1.begin(),  d1.end());
    printDeque(d3);

    deque<int> d4;
    d4.assign(10, 100);
    printDeque(d4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.3.4 `deque`大小操作



**函数原型：**

-   `empty()` //判空
-   `size()` //返回容器中元素的个数
-   `resize(num)` //重新制定容器的长度为num。若容器变长，则用默认值填充，若容器变短，则删除超出的部分
-   `resize(num, elem)`//同上，但是填充的默认值修改为elem。
-   `deque`没有容量(capacity)的概念

**示例：**

```cpp
/*  
 *  Description : deque的大小
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 20:59
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <deque>
using namespace std;

void printDeque(const deque<int> &d)
{
    for(deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
    {
        cout << (*it) <<  " ";
    }
    cout << endl;
}

void test01()
{
    deque<int> d1;
    for (int i = 0; i < 10; ++i)
    {
        d1.push_front(i);
    }
    printDeque(d1);

    if(d1.empty())
    {
        cout << "d1为空"  << endl;
    }
    else
    {
        cout << "d1不为空" << endl;
        cout << "d1的大小" << d1.size() << endl;
    }

    //调整大小
    d1.resize(15, 1);
    printDeque(d1);

    d1.resize(4);
    printDeque(d1);

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   deque没有容量的概念



#### 3.3.5 `deque`插入和删除

**函数原型：**

-   两端插入操作
    -   `push_back(elem)` //在容器尾部添加一个数据
    -   `push_front(elem)` //在容器头部插入一个数据
    -   `pop_back()`//删除容器最后一个元素
    -   `pop_front()`//删除容器第一个元素
-   指定位置操作
    -   `insert(pos, elem)` //在pos位置插入一个elem元素的拷贝，返回新数据的位置
    -   `insert(pos, n, elem)` //在pos位置插入n个elem，没有返回值
    -   `insert(pos, beg, end)`//在pos插入[beg, end)区间的元素，无返回值
    -   `clear()` //清空容器中所有数据
    -   `erease(beg, end)` //删除[beg, end)区间的元素，返回下一个数据的位置
    -   `erease(pos)` //删除pos位置的数据，返回下一个数据的位置



**示例：**

```cpp
/*  
 *  Description : deque的插入和删除
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 21:05
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <deque>
using namespace std;

void printDeque(const deque<int> & d)
{
    for(deque<int>::const_iterator it = d.begin(); it != d.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}

void test01()
{
    deque<int> d1;
    d1.push_back(10);
    d1.push_front(20);
    d1.push_back(100);
    d1.push_front(200);
    printDeque(d1);


}

void test02()
{
    deque<int> d1;
    d1.push_back(10);
    d1.push_front(20);
    d1.push_back(100);
    d1.push_front(200);
    printDeque(d1);

    //insert插入
    d1.insert(d1.begin(), 100);
    d1.insert(d1.begin(),2, 1000);
    printDeque(d1);

    //按照区间进行插入
    deque<int> d2;
    d2.push_back(1);
    d2.push_back(2);
    d2.push_back(3);

    //在d1的begin插入 d2的begin到d2的end
    d1.insert(d1.begin(), d2.begin(),  d2.end());
    printDeque(d1);

}

void test03()
{
    deque<int> d1;
    d1.push_back(10);
    d1.push_front(20);
    d1.push_back(100);
    d1.push_front(200);

    //删除第二个元素
    deque<int>::iterator it = d1.begin();
    it++;
    d1.erase(it);
    printDeque(d1);

    //按区间删除
    d1.erase(d1.begin(),  d1.end());
    printDeque(d1);
}
int main()
{
    test03();
    return EXIT_SUCCESS;
}
```



>   插入和删除的位置pos都是迭代器，而不是int类型的下标index



#### 3.3.6 `deque`数据存取

**函数原型：**

-   `at(int idx)` //返回索引idx的数据
-   `[]`//同上
-   `front()`//返回容器第一个元素
-   `back()`//返回容器最后一个元素

#### 3.3.7 `deque`排序



**算法：**

-   `sort(iterator beg, iterator end)` //对beg和end区间内的元素进行排序



**示例：**

```cpp
/*  
 *  Description : deque容器的排序
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 21:27
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <deque>
#include <algorithm>

using namespace std;

void printDeque(const deque<int> &d)
{
    for(deque<int>::const_iterator it = d.begin(); it  != d.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    deque<int> d;
    d.push_back(10);
    d.push_back(20);
    d.push_back(30);
    d.push_front(100);
    d.push_front(200);
    d.push_front(300);
    printDeque(d);

    //排序
    sort(d.begin(),  d.end());
    printDeque(d);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   对于支持随机访问的迭代器的容器，都可以利用`sort`进行排序，例如`vector`。

### 3.4 案例-评委打分

#### 3.4.1 案例描述

有5名选手：ABCDE，10个评委分别给每个选手打分，去掉最高分，去掉最低分，取平均分



#### 3.4.2 实现步骤

1.   创建5名选手，放入`vector`
2.   遍历`vector`，取出每一位选手，进行for循环，把10个评委的打分存到`deque`容器中
3.   `sort`算法对容器中分数进行排序，去掉最高分和最低分
4.   `deque`容器遍历，取平均分

```cpp
/*  
 *  Description : 打分
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 21:36
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>
using namespace std;

class Person
{
private:
    string name;
    int score;
public:
    Person(const string &name, int score) : name(name), score(score)
    {}

    void setName(const string &name)
    {
        Person::name = name;
    }

    void setScore(int score)
    {
        Person::score = score;
    }

    const string &getName() const
    {
        return name;
    }

    int getScore() const
    {
        return score;
    }

    Person(const string &name) : name(name)
    {
        this->score = 0;
    }
};

void rating()
{
    //创建五个选手
    Person p1("A");
    Person p2("B");
    Person p3("C");
    Person p4("D");
    Person p5("E");
    vector<Person> v;
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);

    for(vector<Person>::iterator it = v.begin();  it != v.end(); it++)
    {
        cout << "请输入选手: " << (*it).getName() << "的分数==>";
        //d用来存放10个打分
        deque<int> d;
        for (int i = 0; i < 10; i++)
        {
            int score;
            cin >> score;
            d.push_back(score);
        }
        //排序
        sort(d.begin(), d.end());
        //删除首位,也就是最大和最小元素
        d.pop_back();
        d.pop_front();

        //遍历剩下的8个元素,计算平均值
        int sum = 0;
        for (deque<int>::const_iterator it2 = d.begin(); it2 != d.end(); it2++)
        {
            sum += (*it2);
        }
        (*it).setScore( sum/d.size() );
    }

    //遍历vector
    for(vector<Person>::const_iterator it = v.begin(); it != v.end(); it++)
    {
        cout << "选手: " << (*it).getName() << "的平均分为: "  << (*it).getScore() << endl;
    }

}

int main()
{
    rating();
    return EXIT_SUCCESS;
}
```



### 3.5 `stack`容器

#### 3.5.1 `stack`基本概念

**概念：**

`stack`是一种**先进后出**(Fisrt In Last Out, FILO)的数据结构，它只有一个出口

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221117215752390.png" alt="image-20221117215752390" style="zoom:40%;" />

栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为。

#### 3.5.2 常用接口

**构造函数：**

-   `stack<T> stk` //默认构造函数
-   `stack(const stack &stk)` //拷贝构造函数

**赋值操作：**

-   `stack& operator=(const stack &stk)` //重载=操作符

**数据存取：**

-   `push(elem)` //入栈一个元素
-   `pop()` //弹出一个元素
-   `top()`//返回栈顶元素

**大小操作：**

-   `empty()`//判空
-   `size()`//返回栈的大小

**示例：**

```cpp
/*  
 *  Description : stack的常用接口
 *  Created by 旋风冲锋龙卷风 on 2022/11/17 22:08
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <stack>
using namespace std;

void test01()
{
    stack<int> s;
    for(int i = 0; i < 10; i++)
    {
        s.push(i);
    }

    while(!s.empty())
    {
        //查看栈顶
        cout << s.top() << " ";
        //出栈
        s.pop();
    }
   
    cout << endl;
    cout << s.size() << endl;

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 3.6 `queue`容器

#### 3.6.1 `queue`基本概念

​	`queue`是**先进先出**(First In First Out)的数据结构。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221118215030206.png" alt="image-20221118215030206" style="zoom:67%;" />

队列容器允许从一端新增元素，从另一端移除元素，分别叫入队`push`和出队`pop`

#### 3.6.2 `queue`常用接口

**构造函数：**

-   `queue<T> que`  //模版类，默认构造函数
-   `queue(const queue& q)`// 拷贝构造函数

**赋值操作：**

-   `queue& operator=(const queue& que)`//重载=操作符

**数据存取：**

-   `push(elem)`//入队
-   `pop()`//出队
-   `back()`//返回最后一个元素
-   `front()`//返回第一个元素

**大小操作：**

-   `empty()`//判空
-   `size()` //返回队列的大小

**示例：**

```cpp
/*  
 *  Description : queue的接口
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 21:59
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <queue>
using namespace std;

class Person
{
public:
    Person(const string &mName, const int &mAge) : m_name(mName), m_age(mAge)
    {}

    string m_name;
    int m_age;
};

void test01()
{
    queue<Person> q;

    //准备数据
    Person p1("Jack", 18);
    Person p2("Niko", 19);
    Person p3("Zhc", 20);
    Person p4("Yzz", 21);

    //入队
    q.push(p1);
    q.push(p2);
    q.push(p3);
    q.push(p4);

    while(!q.empty())
    {
        //查看队头元素
        cout << q.front().m_name << " " << q.front().m_age << endl;
        //查看队尾
        cout << q.back().m_name << " " << q.back().m_age << endl;
        q.pop();
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 3.7 `list`容器

#### 3.7.1 `list`基本概念

**功能：**将数据进行链式存储

**链表**(list)是一种物理存储单元上非连续的存储结构，数据元素的逻辑是通过链表中的指针链实现的。

链表由一系列**节点**组成，每个节点有**数据域**和**指针域**。STL中的`list`是一个**双向循环链表**。

-   链表插入删除方便，但是不能随机存取，占用的空间比数组大，指针域也需要空间
-   数组反之

![image-20221118221507024](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221118221507024.png)

**上图有问题，并不循环，STL中的链表是循环的。**

由于链表的存储方式并不是连续的内存空间，所以链表的迭代器只支持前移和后移，属于**双向迭代器**。

`list`的优点：

-   采用动态存储分配，不会造成内存浪费和溢出
-   链表插入删除只需要修改指针，不用移动元素

`list`的缺点

-   不能随机访问，也就不能用`at()`和`[]`重载来存取元素

STL还有一个重要的性质，操作插入和删除操作不会造成原有的`list`迭代器的失效，这在`vector`是不成立的。

>   总结：
>
>   STL中`list`和`vector`是两个最常用的容器，各有优缺点。

#### 3.7.2 `list`构造函数

**函数原型：**

-   `list<T> l`//默认构造
-   `list(beg, end)` //将[beg, end)区间中的元素拷贝给自身
-   `list(n, elem)`//构造函数将n个elem拷贝给自身
-   `list(const list& l)`//拷贝构造函数

**示例：**

```cpp
/*  
 *  Description : list的构造函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 22:23
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>
using namespace std;

void printList(const list<int> &l)
{
    for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    //默认构造
    list<int> l1;
    //添加数据
    for (int i = 0; i < 10; ++i)
    {
        l1.push_back(i);
    }

    printList(l1);

    //区间构造方式
    list<int>l2(l1.begin(), l1.end());
    printList(l2);

    //拷贝构造
    list<int> l3(l2);
    printList(l3);

    //n个elem
    list<int> l4(10, 100);
    printList(l4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   `list`构造方式和其他几个STL容器差不多



#### 3.7.3 `list`赋值和交换

**功能描述：**

-   给`list`容器进行赋值，以及交换`list`容器

**函数原型：**

-   `assign(beg, end)`//将[beg, end) 区间中的数据拷贝赋值给本身
-   `assign(n, elem)`//将n个elem拷贝赋值给本身
-   `list& operator=(const list &list)`//重载等号操作
-   `swap(l)` //将l与自身进行交换

**示例：**

```cpp
/*  
 *  Description : list赋值和交换
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 22:34
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>
using namespace std;

void printList(const list<int>& l)
{
    for(list<int>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

//赋值
void test01()
{
    list<int> l1;
    for (int i = 0; i < 10; ++i)
    {
        l1.push_back(i);
    }
    printList(l1);

    list<int> l2;
    l2 = l1;
    printList(l2);

    cout << "交换前" << endl;
    list<int> l3;
    l3.assign(l2.begin(),  l2.end());
    printList(l3);

    list<int> l4;
    l4.assign(10, 100);
    printList(l4);

    cout << "交换后" << endl;
    l3.swap(l4);
    printList(l3);
    printList(l4);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.7.4 `list`大小操作

**函数原型：**

-   `size()`//返回容器中元素的个数
-   `empty()`//判空
-   `resize(num)` //重新制定容器长度若容器变长，则用默认值填充新位置；若容器变短，则末尾超出部分删除
-   `resize(num, elem)` //同上，但是默认值变为elem

**示例：**

```cpp
/*  
 *  Description : list容器的大小操作
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 22:40
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>


using namespace std;

void printList(const list<int> &l)
{
    for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    list<int> l1;
    for (int i = 0; i < 5; i++)
    {
        l1.push_back(i);
    }
    printList(l1);

    //判空
    if(l1.empty())
    {
        cout << "l1为空" << endl;
    }
    else
    {
        cout << "l1不为空" << endl;
        cout << "l1的元素个数为: " << l1.size() << endl;
    }

    //重新指定大小
    l1.resize(10, 8);
    printList(l1);
    l1.resize(2);
    printList(l1);

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.7.5 `list`插入和删除

**函数原型：**

-   `push_back(elem)` //尾插
-   `pop_back()`//删除容器最后一个元素
-   `push_front(elem)`//在容器开头插入一个元素
-   `pop_front()`//删除容器第一个元素
-   `insert(pos, elem)` //在pos位置插入elem元素的拷贝，返回新数据的位置
-   `insert(pos, n, elem)`//在pos位置插入n个elem数据，没有返回值
-   `insert(pos, beg, end)`// 在pos位置插入[beg, end)区间的数据，无返回值
-   `claer()`//移除容器的所有数据
-   `erease(beg, end)`//删除[beg, end)区间的数据，返回下一个数据的位置
-   `erease(pos)`//删除pos位置的数据，返回下一个数据的位置
-   `remove(elem)`//删除容器中所有与elem值匹配的元素

**示例：**

```cpp
/*  
 *  Description : 
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 22:52
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>
using namespace std;

void printList(const list<int> &l)
{
    for(list<int>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    list<int> l;
    l.push_back(10);
    l.push_back(20);
    l.push_back(10);
    l.push_back(30);

    //头插
    l.push_front(100);
    l.push_front(200);
    l.push_front(300);
    printList(l);

    //尾删
    l.pop_back();
    printList(l);

    //头删
    l.pop_front();
    printList(l);

    //insert插入第二个位置
    l.insert(++l.begin(), 1000);
    printList(l);

    l.erase(++l.begin());
    printList(l);

    //移除所有的10,而非一个
    l.remove(10);
    printList(l);

    //清空
    l.clear();
    printList(l);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   左边是头，右边是尾。
>
>   `remove(elem)`是删除所有匹配的元素

#### 3.7.6 `list`数据存取



**函数原型：**

-   `front()` //返回第一个元素
-   `back()`//返回最后一个元素

>   验证一个迭代器是否支持随机访问
>
>   ```cpp
>   it++;
>   it--;//证明支持双向
>   it = it + 1;//如果不报错，则支持随机访问
>   ```



#### 3.7.7 `list`反转和排序

**函数原型：**

-   `reverse()` //反转链表
-   `sort()`//链表排序

**示例：**

```cpp
/*  
 *  Description : list的反转和排序
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 23:09
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

void printList(const list<int> &l)
{
    for (list<int>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

bool myCompare(int v1, int v2)
{
    //降序 让第一个数大于第二个数
    return v1 > v2;
}

void test01()
{
    list<int> l1;
    l1.push_back(3);
    l1.push_back(1);
    l1.push_back(5);
    l1.push_back(4);
    l1.push_back(2);
    printList(l1);

    //反转
    l1.reverse();
    printList(l1);

    //排序
    //报错,原因是标准的sort()算法必须支持随机访问迭代器的容器
    //sort(l1.begin(), l1.end());

    //不支持随机访问迭代器的容器,会提供成员函数调用
    //默认是从小到大
    l1.sort();
    printList(l1);

    //如果想从大到小降序排序，提供回调函数，没有()!
    l1.sort(myCompare);

    printList(l1);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   需要分清
>
>   -   `list`的`reverse()`反转
>   -   `vector`的`reserve()`预留空间
>
>   标准的sort()算法必须支持随机访问迭代器的容器，不支持随机访问迭代器的容器,会提供成员函数调用。默认升序排序，如果想降序，需要提供回调函数。

#### 3.7.8 排序案例

**描述：**将Person类进行排序，属性有name，age，height。按照年龄进行升序，如果年龄相同则按照身高降序

**示例：**

```cpp
/*  
 *  Description : 将Person类进行排序，属性有name，age，height。按照年龄进行升序，如果年龄相同则按照身高降序
 *  Created by 旋风冲锋龙卷风 on 2022/11/18 23:54
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <list>
using namespace std;

//选择使用list进行排序,因为list的sort可以调用回调函数
class Person
{
public:
    string m_name;
    int m_age;
    int m_height;

    Person(const string &mName, int age, int height) : m_name(mName), m_age(age), m_height(height)
    {}
};

//打印函数
void printList(const list<Person> &l)
{
    for(list<Person>::const_iterator it = l.begin(); it != l.end(); it++)
    {
        cout << "姓名: " << (*it).m_name  << ", 年龄: " << (*it).m_age << ", 身高: " << (*it).m_height << endl;
    }
}

bool myCompare(Person &p1, Person &p2)
{
    if(p1.m_age < p2.m_age)
    {
        return true;
    }
    else if(p1.m_age == p2.m_age)
    {
        return p2.m_height > p2.m_height;
    }
    return false;

}

void mySort()
{
    //准备数据
    Person p1("Jack", 20, 178);
    Person p2("Niko", 20, 169);
    Person p3("Tom", 20, 199);
    Person p4("Jenny", 18, 157);
    Person p5("Jane", 24, 187);
    Person p6("Ashe", 16, 180);

    list<Person> l;
    l.push_back(p1);
    l.push_back(p2);
    l.push_back(p3);
    l.push_back(p4);
    l.push_back(p5);
    l.push_back(p6);

    cout << "排序前: " << endl;
    printList(l);

    l.sort(myCompare);
    cout << endl << "排序后:" << endl;
    printList(l);
}

int main()
{
    mySort();
    return EXIT_SUCCESS;
}
```



### 3.8 `set/mutliset`容器

#### 3.8.1 `set`基本概念

**简介：**

-   所有的元素都会在插入时自动排序

**本质：**

-   `set/multiset`属于**关联式容器**，底层结构用**二叉树**实现。

**`set/multiset`区别：**

-   `set`不允许容器中有重复元素
-   `multiset`允许容器中有重复元素

#### 3.8.2 `set`构造和赋值

**构造：**

-   `set<T> s` //默认构造
-   `set(cosnt set &s)` //拷贝构造

**赋值:**

-   `operator=`// 重载=

**示例：**

```cpp
/*  
 *  Description : set的构造和赋值
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 00:20
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
using namespace std;

void printSet(const set<int> &s)
{
    for(set<int>::const_iterator it = s.begin(); it != s.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    set<int> s1;
    //set插入数据只有insert
    s1.insert(1);
    s1.insert(1);
    s1.insert(0);
    s1.insert(-1);
    //所有的元素在插入的时候会自动被排序
    //同时set容器不允许插入重复值
    printSet(s1);

    set<int> s2(s1);
    printSet(s2);

    set<int> s3;
    s3 = s2;
    printSet(s3);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.8.3 `set`大小和交换

**函数原型：**

-   `size()` //返回容器中的数目（大小）
-   `empty()` //判空
-   `swap(s)` //交换两个容器



#### 3.8.4 `set`插入和删除

**函数原型：**

-   `insert(elem)` //在容器中插入元素
-   `clear()` //清空容器
-   `erase(pos)` //删除pos迭代器所指的元素，返回下一个元素的迭代器
-   `erase(beg, end)` //删除[beg, end)区间内的所有元素，返回下一个元素的迭代器
-   `erase(elem)` //删除容器中值为elem的元素

**示例：**

```cpp
/*  
 *  Description : set插入和删除
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 00:30
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
using namespace std;

void printSet(const set<int> &s)
{
    for (set<int>::const_iterator it = s.begin(); it != s.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

void test01()
{
    set<int> s1;
    s1.insert(10);
    s1.insert(30);
    s1.insert(40);
    s1.insert(20);
    printSet(s1);

    //删除第二个元素
    s1.erase(++s1.begin());
    printSet(s1);

    //删除某个数字
    s1.erase(10);
    printSet(s1);

    //清空,两种方法都可以
    s1.clear();
    //清空
    s1.erase(s1.begin(), s1.end());
    printSet(s1);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.8.5 `set`查找和统计

**函数原型：**

-   `find(key)` //查找key是否存在，如果存在，则返回对应的迭代器，如果不存在，则返回set.end()
-   `count(key)` //统计key的元素个数，对于`set`容器而言，结果只为1或0，对`mutliset`，结果可能大于1



**示例：**

```cpp
/*  
 *  Description : set的查找和统计
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 14:11
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
using namespace std;

void test01()
{
    set<int> s1;
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    //查找
    set<int>::iterator pos = s1.find(10);
    if(pos != s1.end())
    {
        cout << "找到元素" << (*pos) << endl;
    }
    else
    {
        cout << "没找到" << endl;
    }

    //统计元素的个数
    //对于set而言只有1或0两种结果
    int count = s1.count(0);
    cout << count << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   查找`find()`返回的是迭代器



#### 3.8.6 `set`和`multiset`区别



**区别：**

-   `set`不可以插入重复数据，而`multiset`可以
-   `set`插入数据的同时会返回插入结果，表示插入是否成功
-   `multiset`不会检测数据，因此可以插入重复数据



**示例：**

```cpp
/*  
 *  Description : set和multiset的区别
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 15:09
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
using namespace std;

void test01()
{
    set<int> s;
    pair<set<int>::iterator, bool> ret = s.insert(10);
    //第一次插入成功
    if(ret.second)
    {
        cout << "插入成功" << endl;
    }
    else
    {
        cout << "插入失败" << endl;
    }

    //第二次插入失败
    ret =  s.insert(10);
    if(ret.second)
    {
        cout << "插入成功" << endl;
    }
    else
    {
        cout << "插入失败" << endl;
    }

    //mutliset允许插入重复值
    multiset<int> ms;
    ms.insert(10);
    ms.insert(10);

    //打印两个10
    for (multiset<int>::iterator it = ms.begin(); it != ms.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}


int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   总结：
>
>   -   如果不允许插入重复数据可以使用`set`
>   -   如果不允许插入重复数据可以使用`multiset`



#### 3.8.7 `pair`对组创建

**功能描述：**

-   成对出现的数据，利用对组可以返回两个数据



**创建方式：**

-   `pair<T1, T2> p(v1, v2)`
-   `pair<T1, T2> p = make_pair(v1, v2)`



**示例：**

```cpp
/*  
 *  Description : pair对组的创建
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 15:24
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

void test01()
{
    //pair不需要头文件
    pair<string, int> p("Tom", 18);
    cout << p.first << " " << p.second << endl;

    //第二种方式创建对组
    pair<string, int> p2 = make_pair("Jack", 20);
    cout << p2.first << " " << p2.second << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 3.8.8 set容器排序

`set`容器的默认排序规则为从小到大，这个规则是可以改变的，我们可以通过**仿函数**来改变排序规则。



**示例1:**`set`存放内置数据类型

```cpp
/*  
 *  Description :  利用仿函数改变set的排序规则
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 15:32
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
using namespace std;

void printSet(const set<int> &s)
{
    for (set<int>::const_iterator it = s.begin(); it != s.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

class MyCompare
{
public:
    bool operator()(int v1, int v2)
    {
        return v1 > v2;
    }
};

void test01()
{
    set<int> s1;

    s1.insert(10);
    s1.insert(40);
    s1.insert(30);
    s1.insert(20);
    s1.insert(50);

    printSet(s1);

    //指定排序规则为从大到小,在模版参数列表中再添加一个仿函数
    set<int, MyCompare> s2;
    s2.insert(10);
    s2.insert(40);
    s2.insert(30);
    s2.insert(20);
    s2.insert(50);
    for(set<int, MyCompare>::iterator it = s2.begin(); it != s2.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}


int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



**示例2:**`set`存放自定义数据类型

```cpp
/*  
 *  Description :  利用仿函数改变set的排序规则
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 15:32
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <set>
#include <string>
using namespace std;

void printSet(const set<int> &s)
{
    for (set<int>::const_iterator it = s.begin(); it != s.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

class MyCompare
{
public:
    bool operator()(int v1, int v2)
    {
        return v1 > v2;
    }
};

void test01()
{
    set<int> s1;

    s1.insert(10);
    s1.insert(40);
    s1.insert(30);
    s1.insert(20);
    s1.insert(50);

    printSet(s1);

    //指定排序规则为从大到小,在模版参数列表中再添加一个仿函数
    set<int, MyCompare> s2;
    s2.insert(10);
    s2.insert(40);
    s2.insert(30);
    s2.insert(20);
    s2.insert(50);
    for(set<int, MyCompare>::iterator it = s2.begin(); it != s2.end(); it++)
    {
        cout << (*it) << " ";
    }
    cout << endl;
}

class Person
{
public:
    string m_name;
    int m_age;
    Person(const string &mName, int mAge) : m_name(mName), m_age(mAge)
    {}
};

//按照年龄降序
class PersonCompare
{
public:
    bool operator()(const Person &p1, const Person &p2)
    {
        return p1.m_age > p2.m_age;
    }
};

void test02()
{
    //自定义的数据类型需要指定排序规则,利用仿函数
    //排序规则在PersonCompare的重载()中
    set<Person, PersonCompare> s;
    Person p1("Jack", 18);
    Person p2("Tom", 20);
    Person p3("Ashe", 16);
    Person p4("Niko", 25);


    s.insert(p1);
    s.insert(p2);
    s.insert(p3);
    s.insert(p4);

    for(set<Person>::iterator it = s.begin(); it != s.end(); it++)
    {
        cout << (*it).m_name << " " << (*it).m_age << endl;
    }
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



>   对于自定义数据类型，set容器必须指定排序规则



### 3.9 `map/mutlimap`容器

#### 3.9.1 `map`基本概念

**简介：**

-   `map`中所有元素都是`pair`
-   `pair`中第一个元素为`key`，起索引作用，第二个元素为`value`,实际值
-   所有元素都会根据元素的键值自动排序

**本质：**

-   `map/multimap`属于**关联式容器**，底层结构是二叉树

**优点：**

-   可以根据key快速找到value

**`map`和`multimap`的区别：**

-   `map`不允许容器中有重复的`key`元素
-   `multimap`允许容器中有重复的key
-   value都允许重复



#### 3.9.2 `map`构造和赋值

**构造：**

-   `map<T1, T2> mp`//默认构造函数
-   `map(const map &m)`//拷贝构造函数

**赋值：**

-   `map& operator=(const map &m)`//重载=

**示例：**

```cpp
/*  
 *  Description : map的构造和赋值
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 16:41
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <map>
using namespace std;

void printMap(const map<int, int> &m)
{
    for (map<int, int>::const_iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key = " << (*it).first << ", value = " << (*it).second << endl;
    }
    cout << endl;
}

void test01()
{
    //创建map容器
    map<int, int> m;
    m.insert(make_pair(1,10));
    m.insert(pair<int, int>(2, 20));
    m.insert(make_pair(4, 40));
    m.insert(make_pair(3, 30));
    //map会按照key排序
    printMap(m);

    //拷贝构造
    map<int, int> m2(m);
    printMap(m2);

    //赋值
    map<int, int> m3;
    m3 = m2;
    printMap(m3);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   插入`map`要用`pair`:
>
>   -   可以是`pair`的匿名对象
>   -   也可以是`make_pair()`



#### 3.9.3 `map`的大小和交换

**函数原型：**

-   `size()` //返回容器中元素的数目
-   `empty()` //判空
-   `swap(st)` //交换两个容器

**示例：**

```cpp
/*  
 *  Description : map的大小和交换
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 16:52
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <map>
using namespace std;

//size()和empty()接口
void test01()
{
    map<int, int> m;
    m.insert(make_pair(1, 10));
    cout << m.size() << endl;
    //不为空,false 输出0
    cout << m.empty() << endl;
}

void printMap(const map<int, int>& m)
{
    for(map<int, int>::const_iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key = " << it->first << " ,value = " << it->second << endl;
    }
    cout << endl;
}
//map的交换
void test02()
{
    map<int, int> m;
    m.insert(make_pair(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));

    map<int, int> m2;
    m2.insert(pair<int, int>(4, 40));
    m2.insert(pair<int, int>(5, 50));
    m2.insert(pair<int, int>(6, 60));
    m2.insert(pair<int, int>(6, 60));

    cout << "交换前：" << endl;
    printMap(m);
    printMap(m2);
    cout << "交换后:" << endl;
    m.swap(m2);
    printMap(m);
    printMap(m2);
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 3.9.4 `map`插入和删除

**函数原型：**

-   `insert(elem)` //在容器中插入元素
-   `clear()` //清除所有元素
-   `erase(pos)` //删除迭代器pos指向的元素，指向下一个元素的迭代器
-   `erase(beg, end)` //删除左开右闭区间内的元素，返回下一个元素的迭代器
-   `erase(key)`//删除容器中值为key的元素



**示例：**

```cpp
/*  
 *  Description : map插入和删除
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 17:00
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <map>
using namespace std;

void printMap(const map<int, int> &m)
{
    for (map<int, int>::const_iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key = " << it->first << ", value = " << it->second << endl;
    }
    cout << endl;
}

void test01()
{
    map<int, int> m;

    //插入方法
    //1.pair匿名对象
    m.insert(pair<int, int>(1, 10));

    //2.make_pair可以不用写模版的参数
    m.insert(make_pair(2, 20));

    //3.map容器作用域下的值类型(value_type)
    m.insert(map<int, int>::value_type(3, 30));

    //4.重载[]插入
    m[4] = 40;
    //没有key为5的数据,但是能输出
    //使用[]如果没有这个数据,会创建一个数据,值为默认值
    //所以不建议[]插入数据,但是可以利用key访问value
    cout << m[5] << endl;
    //在确定key存在的时候,可以用[]找到value
    cout << m[4] << endl;


    printMap(m);
    //按迭代器删除
    m.erase(m.begin());
    printMap(m);

    //按照key的值删除
    m.erase(3);
    printMap(m);

    //清空,下面两行都可以
    m.erase(m.begin(), m.end());
    m.clear();

    printMap(m);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   共有4种插入方式，`make_pair()`比较好，不用填写模版类型参数



#### 3.9.5 `map`查找和统计

**函数原型：**

-   `find(key)` //查找key是否存在，存在就返回该键元素的迭代器，如果没有则返回`m.end()`
-   `count(key)` //统计key元素的个数，对于`map`而言只有0或1

**示例：**

```cpp
/*  
 *  Description : map的查找和统计
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 17:20
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <map>
using namespace std;

void test01()
{
    map<int, int> m;
    m.insert(make_pair(1, 10));
    m.insert(make_pair(2, 20));
    m.insert(make_pair(3, 30));

    //查找,返回一个迭代器
    map<int, int>::iterator pos = m.find(3);
    if(pos != m.end())
    {
        cout << "找到了, key = " << pos->first << ", value = " << pos->second << endl;
    }
    else
    {
        cout << "没找到" << endl;
    }

    //统计,对于map只有0或1,mutlimap可能大于1
    //不会替换,而是无法插入
    m.insert(make_pair(1, 50));
    cout << m.begin()->second << endl;
    int num = m.count(1);
    cout << "num = " << num << endl;

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   `find`返回迭代器
>
>   `count`返回int类型



#### 3.9.6 `map`容器排序规则

如何自定义`map`容器的排序规则：

答案是：**仿函数**重载`()`操作符



**示例：**

```cpp
/*  
 *  Description : 利用仿函数自定义map排序规则
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 17:27
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <map>
using namespace std;

class MyCompare
{
public:
    bool operator()(const int &v1, const int &v2) const
    {
        return v1 > v2;
    }
};

void test01()
{
    //把自定义的仿函数(实际上是一个类)
    map<int, int, MyCompare> m;

    m.insert(make_pair(1,10));
    m.insert(make_pair(3, 30));
    m.insert(make_pair(2, 20));
    m.insert(make_pair(0, 0));
    m.insert(make_pair(4, 40));

    for(map<int, int, MyCompare>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key = " << it->first << ", value = " << it->second << endl;
    }

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



>   需要注意的是：不能指定value作为排序规则，所有的排序规则都应该是对key类型的排序。也就是仿函数中参数类型是两个key的类型。
>
>   **仿函数要写成const，参数也最好使用const的引用数据类型**



### 3.10 案例-员工分组

#### 3.10.1 案例描述

-   公司招聘了10个员工（ABCDEFGHIJ），10个员工进入公司之后，需要指派员工在哪个部门工作
-   员工信息有：姓名，工资组成；部门分为：策划、美术、研发
-   随机给10名员工分配部门和工资
-   通过`multimap`进行信息的插入 key（部门编号）value（员工）
-   分部门显示员工信息

#### 3.10.2 实现步骤

1.   创建10名员工，放到`vector`中
2.   遍历`vector`容器，取出每个员工，进行随机分组
3.   分组之后，将员工部门编号作为key，具体员工作为value，放入`multimap`中
4.   分部门显示员工信息

**代码：**

```cpp
/*  
 *  Description : 使用STL容器实现员工分组
 *  Created by 旋风冲锋龙卷风 on 2022/11/19 17:52
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <map>
#include <ctime>
using namespace std;

#define cehua 0
#define meishu 1
#define yanfa 2

class Worker
{
public:
    string m_name;
    int m_salary;
};

void createWorker(vector<Worker> &v)
{
    string nameSeed = "ABCDEFGHIJ";
    for(int i = 0; i < 10; i++)
    {
        Worker worker;
        worker.m_name = "员工";
        worker.m_name += nameSeed[i];
        worker.m_salary = rand() % 10000 + 10000; //10000 ~ 19999
        v.push_back(worker);
    }
}

//员工的分组
void setGroup(vector<Worker> &v, multimap<int, Worker> &m)
{
    for(vector<Worker>::iterator it = v.begin(); it != v.end(); it++)
    {
        //产生随机部门的编号
        int deptId = rand() % 3; // 0, 1, 2
        //将员工插入到分组中
        //key:部门编号; value:具体员工
        m.insert(make_pair(deptId, *it));
    }
}

void showWorkerByGroup(multimap<int, Worker> &m)
{
    cout << "策划部门"  << endl;
    //策划的起始位置
    multimap<int, Worker>::iterator pos = m.find(cehua);
    //统计策划的人数
    int count = m.count(cehua);
    for(int i = 0;pos != m.end() && i < count; i++, pos++)
    {
        cout << "姓名: " << pos->second.m_name << ", 工资:" << pos->second.m_salary << endl;

    }
    cout << "美术部门"  << endl;
    //美术的起始位置
    pos = m.find(meishu);
    //统计策划的人数
    count = m.count(meishu);
    for(int i = 0; pos != m.end() && i < count; i++, pos++)
    {
        cout << "姓名: " << pos->second.m_name << ", 工资:" << pos->second.m_salary << endl;

    }
    cout << "研发部门"  << endl;
    //策划的起始位置
    pos = m.find(yanfa);
    //统计策划的人数
    count = m.count(yanfa);
    for(int i = 0; pos != m.end() && i < count; i++, pos++)
    {
        cout << "姓名: " << pos->second.m_name << ", 工资:" << pos->second.m_salary << endl;

    }
}

int main()
{
    //随机数
    srand((unsigned int)time(NULL));
    //1. 创建员工
    vector<Worker> vWorker;
    createWorker(vWorker);

    //2.员工分组
    multimap<int, Worker> mWorker;
    setGroup(vWorker, mWorker);

    //3. 分组显示员工
    showWorkerByGroup(mWorker);
    //测试
    //for(vector<Worker>::iterator it = vWorker.begin(); it != vWorker.end(); it++)
    //{
    //    cout << "姓名: " << it->m_name << ", 工资:" << it->m_salary << endl;
    //}

    return EXIT_SUCCESS;
}
```



## 4. STL函数对象

### 4.1 函数对象

#### 4.1.1 函数对象概念

-   重载**函数调用操作符**`()`的类，其对象常称为**函数对象**
-   **函数对象**使用重载`()`时，行为类似函数调用，也叫做**仿函数**



**本质：**

函数对象（仿函数）是一个**类**，而不是一个函数



#### 4.1.2 函数对象使用

**特点：**

-   函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
-   函数对象超出普通函数的状态，函数对象可以有自己的状态
-   函数对象可以作为参数传递



**示例：**

```cpp
/*  
 *  Description : 函数对象(仿函数)的基本使用
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 19:40
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

//1. 函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
class MyAdd
{
public:
    int operator()(int v1, int v2)
    {
        return v1 + v2;
    }
};

void test01()
{
    MyAdd myAdd;
    cout << myAdd(1, 2) << endl;
}

//2. 函数对象超出普通函数的状态，函数对象可以有自己的状态
class MyPrint
{
public:
    MyPrint()
    {
        this->count = 0;
    }
    void operator()(string test)
    {
        cout << test << endl;
        //每次调用count++
        count++;
    }

    //例如想记录统计函数调用的次数,可以在类内部添加一个属性
    //普通函数需要全局变量
    int count;
};

void test02()
{
    MyPrint myPrint;
    myPrint("hello world");
    myPrint("hello world");
    myPrint("hello world");
    myPrint("hello world");
    cout << "myPrint的调用次数为: " << myPrint.count << endl;
}

//3. 函数对象可以作为参数传递

void doPrint(MyPrint & mp, string test)
{
    //下面两行代码是一样的
    mp.operator()(test);
    mp(test);
}

void  test03()
{
    MyPrint myPrint;
    doPrint(myPrint, "hello CPP");
}

int main()
{
    test03();
    return EXIT_SUCCESS;
}
```



### 4.2 谓词

#### 4.2.1 谓词概念

**概念：**

-   返回bool类型的仿函数称为**谓词**
-   如果`operator()`接受一个参数，则称为一元谓词
-   如果`operator()`接受两个参数，则称为二元谓词



#### 4.2.2 一元谓词

**示例：**

```cpp
/*  
 *  Description : 一元谓词: 仿函数的返回值为bool类型,同时只传入一个参数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 19:54
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class GreaterFive
{
public:
    bool operator()(int val)
    {
        return val > 5;
    }
};

void test01()
{
    vector<int> v;
    for(int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }

    //查找容器中有没有大于5的数字,找到返回第一个满足条件的位置,没找到则为end()
    //GreaterFive() : 匿名函数对象
    vector<int>::iterator pos = find_if(v.begin(), v.end(), GreaterFive());

    if(v.end() == pos)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << *pos << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 4.2.3 二元谓词



**示例：**

```cpp
/*  
 *  Description : 二元谓词,仿函数的返回类型为bool, 同时有两个参数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 20:02
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class MyCompare
{
public:
    bool operator()(int v1, int v2)
    {
        return v1 > v2;
    }
};

void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(4);
    v.push_back(2);
    v.push_back(3);
    v.push_back(5);

    sort(v.begin(), v.end());
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    //使用函数对象来改变排序规则为从大到小
    sort(v.begin(), v.end(), MyCompare());
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 4.3 内建函数对象

#### 4.3.1 内建函数对象意义

**概念：**

-   STL内建了一些函数对象

**分类：**

-   算术仿函数
-   关系仿函数
-   逻辑仿函数

**用法：**

-   这些仿函数所产生的对象，用法和一般函数完全相同
-   使用内建函数对象，需要引入头文件`#include<functional>`



#### 4.3.2 算术仿函数

**功能描述：**

-   实现四则运算
-   其中`negate`是一元运算，其余都是二元运算

**仿函数原型：**

-   `template<class T> T plus<T>` //加法仿函数
-   `template<class T> T minus<T>`//减法仿函数
-   `template<class T> T multiplies<T>`//乘法仿函数
-   `template<class T> T divides<T>` //除法仿函数
-   `template<class T> T modulus<T>` //取模仿函数
-   `template<class T> T negate<T> `//取反仿函数

>   注意使用二元仿函数的时候模版参数列表也只需要一个类型

**示例：**

```cpp
/*  
 *  Description : 内建的算术仿函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 20:16
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <functional>
using namespace std;

//negate 一元仿函数 取反
//plus 二元仿函数 加法
void test01()
{
    negate<int> n;
    //取反
    cout << n(100) << endl;

    plus<int> p;
    cout << p(1, 2) << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 4.3.3 关系仿函数

**功能描述：**

-   实现关系对比

**仿函数原型：**

-   `template<class T> bool equal_to<T>` //等于
-   `template<class T> bool not_equal_to<T>` //不等于
-   `bool greater<T>` //大于
-   `bool greater_equal<T>`//大于等于
-   `bool less<T>`//小于
-   `bool less_equal<T>`//小于等于

>   关系仿函数都是二元谓词

**示例：**

```cpp
/*  
 *  Description : 内建的关系仿函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 20:21
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>
using namespace std;


//greater()

void test01()
{
    vector<int> v;
    v.push_back(10);
    v.push_back(30);
    v.push_back(40);
    v.push_back(20);
    v.push_back(50);

    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    //二元谓词使用内建的关系仿函数
    //sort排序规则用从大到小
    sort(v.begin(), v.end(), greater<int>());
    for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   关系仿函数最常用的就是`greater<>`大于



#### 4.3.4 逻辑仿函数

**功能描述：**

-   实现逻辑运算

**函数原型：**

-   `template<class T> bool logical_and<T>`//逻辑与
-   `template<class T> bool logical_or<T>`//逻辑或
-   `template<class T> bool logical_not<T>`//逻辑非

**示例：**

```cpp
/*  
 *  Description : 内建逻辑仿函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 20:33
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>
using namespace std;

//逻辑非 logical_not
void test01()
{
    vector<bool> v;
    v.push_back(true);
    v.push_back(false);
    v.push_back(false);
    v.push_back(true);
    for(vector<bool>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;

    //利用逻辑非 将容器v搬运到容器v2中,并执行取反操作
    vector<bool> v2;
    //准备空间
    v2.resize(v.size());

    //搬运,同时取反
    transform(v.begin(), v.end(), v2.begin(), logical_not<bool>());
    for(vector<bool>::iterator it = v2.begin(); it != v2.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

**输出结果：**

![image-20221123203849418](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221123203849418.png)

>   注意在搬运`transform`时，需要先开辟空间。



## 5. STL常用算法



**概述：**

-   算法主要是由头文件`<algorithm>` `<functional>` `<numeric>`组成
-   `<algorithm>`是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等等
-   `<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模版函数
-   `<functional>`定义了一些模版类，用以声明函数对象



### 5.1 常用遍历算法

**算法简介：**

-   `for_each` //遍历容器
-   `transform`//搬运容器到另一个容器中



#### 5.1.1 `for_each`

**功能描述：**

-   实现遍历容器

**函数原型：**

-   `for_each(beg, end, _func)`
    -   beg：起始迭代器
    -   end：结束迭代器
    -   _func：「函数名称」或者「函数对象（仿函数）」

**示例：**

```cpp
/*  
 *  Description : for_each函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 20:51
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

//普通函数
void print01(int v)
{
    cout << v << " ";
}

class print02
{
public:
    void operator()(int v)
    {
        cout << v << " ";
    }
};

void test01()
{
    vector<int> v;
    for(int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }

    //普通函数作第三个参数
    for_each(v.begin(),  v.end(), print01);
    cout << endl;

    //仿函数作第三个参数,需要函数对象,这里用的是匿名函数
    for_each(v.begin(),  v.end(), print02());
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   `for_each()`在实际开发中经常使用，需要熟练掌握

#### 5.1.2 `transform`

**功能描述：**

-   将一个容器搬到另一个容器中

**函数原型：**

-   `transform(beg1, end1, beg2, _func)`
    -   beg1：源容器开始迭代器
    -   end1：源容器结束迭代器
    -   beg2：目标容器开始迭代器
    -   _func：函数名称或者函数对象，代表搬运过程中需要进行的操作

**示例：**

```cpp
/*
 *  Description : 常用遍历算法中的transform
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 21:47
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class Transform
{
public:
    int operator()(int v)
    {
        return v + 100;
    }
};

class MyPrint
{
public:
    void operator()(int v)
    {
        cout << v << " ";
    }
};

void test01()
{
    vector<int> v;
    for(int i = 0; i< 10; i++)
    {
        v.push_back(i);
    }

    //目标容器
    vector<int> vTarget;
    //目标容器需要提前开辟空间
    vTarget.resize(v.size());
    transform(v.begin(), v.end(), vTarget.begin(), Transform());

    for_each(vTarget.begin(),  vTarget.end(), MyPrint());
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   创建目标容器后需要提前给目标容器开辟空间：`resize()`

### 5.2 常用查找算法

**常用API：**

-   `find` //查找元素
-   `find_if`//按条件查找元素
-   `adjacent_find`//查找相邻重复元素
-   `binary_search`//二分查找法
-   `count` //统计元素个数
-   `count_if`// 按条件统计元素个数

#### 5.2.1`find`

**功能描述：**

-   查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器`end()`

**函数原型：**

-   `find(beg, end, val)`

    -   按值查找元素，找到返回第一个指定位置迭代器，找不到返回`end()`

    -   beg：开始迭代器

    -   end：结束迭代器

    -   val：查找的元素

        

**示例：**

```cpp
/*  
 *  Description : 常用的查找算法 find
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 21:58
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

//查找内置数据类型
void test01()
{
    vector<int> v;
    for (int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }

    //查找容器中是否有5这个元素
    //不管找到与否,都会返回一个迭代器
    vector<int>::iterator pos = find(v.begin(), v.end(), 5);
    if(v.end() == pos)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "找到" << *pos << endl;
    }
}

class Person
{
public:
    Person(const string &mName, int mAge) : m_name(mName), m_age(mAge)
    {}

    Person()
    {}

    //find底层调用的是==操作符,所以需要在自定义类中重载==操作符
    bool operator==(const Person &p) const
    {
        if(this->m_name == p.m_name && this->m_age == p.m_age)
        {
            return  true;
        }
        return false;
    }

    string m_name;
    int m_age;
};

//查找自定义数据类型
void test02()
{
    vector<Person> v;
    v.push_back(Person("Jack", 18));
    v.push_back(Person("Tom", 19));
    v.push_back(Person("Jane", 20));
    v.push_back(Person("Dive", 21));

    vector<Person>::iterator pos = find(v.begin(), v.end(), Person("Tom", 19));
    if(v.end() == pos)
    {
        cout << "没有找到"  << endl;
    }
    else
    {
        cout << "找到, 姓名: " << pos->m_name << ", 年龄: " << pos->m_age << endl;
    }
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   `find`底层调用的是`==`操作符，所以自定义数据类型使用`find`需要重载`==`操作符
>
>   find的返回值是**迭代器**

#### 5.2.2 `find_if`

-   按条件查找元素

**函数原型：**

-   `find_if(beg, end, _Pred)
    -   按条件查找元素，找到返回第一个满足要求的迭代器，没找到返回结束迭代器位置
    -   beg：开始迭代器
    -   end：结束迭代器
    -   _Pred：谓词(返回值为bool类型的仿函数)

**示例：**

```cpp
/*  
 *  Description : find_if查找算法
 *  Created by 旋风冲锋龙卷风 on 2022/11/23 22:13
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
using namespace std;

//查找内置数据类型
class GreaterFive
{
public:
    bool operator()(int val)
    {
        return val > 5;
    }
};

void test01()
{
    vector<int> v;
    for(int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }

    vector<int>::iterator pos = find_if(v.begin(), v.end(), GreaterFive());
    if(v.end() == pos)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "找到了: " << *pos << endl;
    }
}


//查找自定义数据类型
class Person
{
public:
    Person(const string &mName, int mAge) : m_name(mName), m_age(mAge)
    {}

    string m_name;
    int m_age;
};

class Greater20
{
public:
    bool operator()(Person &person)
    {
        return person.m_age > 20;
    }
};

void test02()
{
    vector<Person> v;
    v.push_back(Person("A", 18));
    v.push_back(Person("B", 19));
    v.push_back(Person("C", 20));
    v.push_back(Person("D", 21));

    //找年龄大于20的
    vector<Person>::iterator pos = find_if(v.begin(), v.end(), Greater20());
    if(v.end() == pos)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "找到, 姓名: " << pos->m_name << ", 年龄: " << pos->m_age << endl;
    }
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 5.2.3 `adjacent_find`

**功能描述：**

-   查找相邻重复元素

**函数原型：**

-   `adjacent_find(beg, end)`
    -   查找相邻重复元素，返回相邻元素的第一个位置的迭代器
    -   beg：开始迭代器
    -   end：结束迭代器

**示例：**

```cpp
/*  
 *  Description : 常用查找算法: adjacent_find
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 10:29
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void test01()
{
    vector<int> v;
    v.push_back(0);
    v.push_back(2);
    v.push_back(0);
    v.push_back(3);
    v.push_back(3);
    v.push_back(4);
    v.push_back(3);
    v.push_back(3);
    v.push_back(0);
    v.push_back(0);
    v.push_back(0);

    vector<int>::iterator pos = adjacent_find(v.begin(), v.end());
    if(v.end() == pos)
    {
        cout << "没找到" << endl;
    }
    else
    {
        cout << "找到了相邻重复元素: " << *pos << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 5.2.4 `binary_search`

**功能描述：**

-   查找指定元素是否存在

**函数原型：**

-   `bool binary_search(beg, end, val)`
    -   查找指定元素，查找到返回`true`，没找到返回`false`
    -   注意：**在无序序列中不可以用**
    -   beg：开始迭代器
    -   end：结束迭代器
    -   val：需要查找的元素

**示例：**

```cpp
/*  
 *  Description : 常用查找算法: binary_search()
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 10:41
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void test01()
{
    vector<int> v;

    //binary_search需要容器内的序列必须有序
    //如果无序,结果未知
    for (int i = 0; i < 10; ++i)
    {
        v.push_back(i);
    }
    bool ret = binary_search(v.begin(), v.end(), 9);
    if(ret)
    {
        cout << "找到了" << endl;
    }
    else
    {
        cout << "没找到" << endl;
    }
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   二分查找的查找效率很高，但是查找的容器中必须为有序序列
>
>   `binary_search`还有一个重载版本，第三个参数可以是一个谓词pred



#### 5.2.5 `count`

**功能描述：**

-   统计元素个数

**函数原型：**

-   `count(beg, end, val)`
    -   统计val的出现次数

**示例：**

```cpp
/*  
 *  Description : 常用查找算法count
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 10:48
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

//统计内置数据类型
void test01()
{
    vector<int> v;

    v.push_back(10);
    v.push_back(40);
    v.push_back(40);
    v.push_back(10);
    v.push_back(40);
    v.push_back(20);

    int num = count(v.begin(),  v.end(), 10);
    cout << num << endl;
}

//统计自定义数据类型
//需要重载==操作符
class Person
{
public:
    string m_name;
    int m_age;

    Person(const string &mName, int mAge) : m_name(mName), m_age(mAge)
    {}
    bool operator==(const Person &p) const
    {
        if(this->m_age == p.m_age)
        {
            return true;
        }
        return false;
    }
};
void test02()
{
    vector<Person> v;
    v.push_back(Person("刘备", 35));
    v.push_back(Person("关羽",34));
    v.push_back(Person("张飞", 33));
    v.push_back(Person("曹操",35));
    v.push_back(Person("诸葛亮", 35));

    //查找容器中与p同岁的人数
    Person p("黄忠", 35);

    int num = count(v.begin(), v.end(), p);
    cout << "与黄忠同岁的人有: " << num  << "人" << endl;
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   `count`底层调用`==`，所以自定义数据类型需要重载`==`操作符。



#### 5.2.6 `count_if`

**功能描述：**

-   按条件统计元素个数

**函数原型：**

-   `count_if(beg, end, pred)`
    -   按条件统计元素出现次数
    -   beg：开始迭代器
    -   end结束迭代器
    -   pred：谓词

**示例：**

```cpp
/*  
 *  Description : 常用查找算法 count_if
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 11:01
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//统计内置数据类型
class Greater20
{
public:
    bool operator()(int val)
    {
        return val > 20;
    }
};
void test01()
{
    vector<int> v;
    v.push_back(10);
    v.push_back(40);
    v.push_back(30);
    v.push_back(20);
    v.push_back(40);
    v.push_back(30);
    v.push_back(10);

    //统计大于20的数的个数
    int num = count_if(v.begin(), v.end(), Greater20());
    cout << "在容器中大于20的元素个数为: " << num << endl;
}

//统计自定义数据类型
class Person
{
public:
    string m_name;
    int m_age;

    Person(const string &mName, int mAge) : m_name(mName), m_age(mAge)
    {}
};

class AgeGreater17
{
public:
    bool operator()(const Person &p) const
    {
        return p.m_age > 17;
    }
};

void test02()
{
    vector<Person> v;
    v.push_back(Person("A", 15));
    v.push_back(Person("B", 16));
    v.push_back(Person("C", 17));
    v.push_back(Person("D", 18));
    v.push_back(Person("E", 19));

    //统计大于17岁的人员个数
    int num = count_if(v.begin(), v.end(), AgeGreater17());
    cout << "大于17岁的共有: " << num << "人"  << endl;
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>   自定义谓词，同时谓词的参数类型应该是容器中的类型，而不是需要比较的类型，例如上面的例子，谓词中参数应该是自定义的`Person`类型，而不是实际比较的`int`类型。



### 5.3 常用排序算法

**算法简介：**

-   `sort`//对容器内元素进行排序
-   `random_shuffle`//洗牌， 指定范围内元素随机调整次序
-   `merge` //容器元素合并，并存储到另一个容器中
-   `revserse`//反转指定范围的元素



#### 5.3.1 `sort`

**功能：**

-   对容器内元素进行排序

**函数原型：**

-   `sort(beg, end, pred)`
    -   在[beg,end)区间按pred的规则排序，默认从小到大
    -   beg：开始迭代器
    -   end：结束迭代器
    -   pred：谓词

**示例：**

```cpp
/*  
 *  Description : sort排序
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 11:17
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << " ";
}

void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(3);
    v.push_back(5);
    v.push_back(4);
    v.push_back(2);

    //利用sort升序排序
    sort(v.begin(), v.end());
    for_each(v.begin(),  v.end(), myPrint);
    cout << endl;

    //利用sort降序排序,使用内建
    sort(v.begin(), v.end(), greater<int>());
    for_each(v.begin(), v.end(), myPrint);
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   `sort`可以搭配内建函数对象例如`greater<T>`等使用，需要注意的是虽然`greater`是小写开头，但是是类的名称，而不是对象。



#### 5.3.2 `random_shuffle`

**功能描述：**

-   指定范围的元素随机调整顺序

**函数原型：**

-   `random_shuffle(beg, end)`
    -   指定范围内的元素随机调整次序
    -   beg：开始迭代器
    -   end：结束迭代器

**示例：**

```cpp
/*  
 *  Description : 常用排序算法: random_shuffle
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 11:30
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

class MyPrint
{
public:
    void operator()(int val) const
    {
        cout << val << " ";
    }
};
void test01()
{
    vector<int> v;
    for (int i = 0; i < 10; ++i)
    {
        v.push_back(i);
    }

    //利用洗牌算法打乱顺序
    random_shuffle(v.begin(), v.end());
    for_each(v.begin(), v.end(), MyPrint());
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   似乎在C++17中被deprecated（弃用）了。
>
>   这个算法比较使用，但是在使用的时候记得加随机数种子。



#### 5.3.3 `merge`

**功能描述：**

-   两个容器元素合并，并存储到另一个容器中

**函数原型：**

-   `merge(beg1, end1, beg2, end2, dest)`
    -   容器元素合并，并存储到另一个容器中
    -   注意：两个容器必须都是**有序的**，合并之后仍然是有序序列
    -   beg1, end1：容器1开始和结束迭代器
    -   beg2, end2：容器2开始和结束迭代器
    -   dest：目标容器开始迭代器

**示例：**

```cpp
/*  
 *  Description : 常用排序算法: merge
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 11:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void myPrint(int v)
{
    cout << v << " ";
}

void test01()
{
    vector<int> v1, v2;
    for(int i = 0; i < 10; i++)
    {
        v1.push_back(2 * i);
        v2.push_back((2 * i) + 1);
    }
    //目标容器
    vector<int> vTarget;
    //使用resize,而非reserve,后者改变的是capacity(容量),避免无意义的扩容;前者改变的是size(大小)
    vTarget.resize(v1.size() + v2.size());
    //合并
    merge(v1.begin(),  v1.end(), v2.begin(),  v2.end(), vTarget.begin());
    for_each(vTarget.begin(),  vTarget.end(), myPrint);
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   目标容器需要提前开辟空间(size而非capacity)，所以使用`resize`而非`reverse`。



#### 5.3.4 `reverse`

**功能：**

-   将容器内元素进行反转

**函数原型：**

-   `reverse(beg, end)`
    -   反转指定范围内的元素

**示例：**

```cpp
/*  
 *  Description : reverse:反转容器
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 12:00
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

void myPrint(int v)
{
    cout << v << " ";
}
void test01()
{
    vector<int> v;
    for (int i = 0; i < 10; ++i)
    {
        v.push_back(i);
    }

    for_each(v.begin(),  v.end(), myPrint);
    cout << endl;
    //反转
    reverse(v.begin(), v.end());
    for_each(v.begin(),  v.end(), myPrint);
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 5.4 常用拷贝和替换算法

**算法简介 ：**

-   `copy`//容器内指定范围元素拷贝到另一个容器中
-   `replace`//将容器内指定范围的旧元素替换为新元素
-   `replace_if`//容器内指定范围满足条件的元素替换为新元素
-   `swap`//互换两个容器的元素



#### 5.4.1 `copy`

**功能描述：**

-   容器内指定范围的元素拷贝到另一容器中

**函数原型：**

-   `copy(beg, end, dest)`
    -   将源容器[beg, end)拷贝到目标容器的迭代器位置dest

**示例：**

```cpp
/*  
 *  Description : 常用拷贝和替换算法: copy
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 15:28
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << " ";
}

void test01()
{
    vector<int> v1;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
    }
    vector<int> v2;

    v2.resize(v1.size());
    copy(v1.begin(), v1.end(), v2.begin());

    for_each(v2.begin(), v2.end(), myPrint);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   一般用`=`赋值比较多

#### 5.4.2 `replace`

**功能描述：**

-   将容器内指定范围的旧元素修改为新元素

**函数原型：**

-   `replace(beg, end, old, new)`
    -   将区间内旧元素替换为新元素

**示例：**

```cpp
/*  
 *  Description : 
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 15:35
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << " ";
}

void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(1);
    for_each(v.begin(), v.end(), myPrint);
    cout << endl;
    replace(v.begin(), v.end(), 1, 3);
    for_each(v.begin(), v.end(), myPrint);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   替换的是区间内所有的old，而非第一个old



#### 5.4.3 `replace_if`

**功能描述：**

-   将区间内满足条件的元素，替换成指定元素

**函数原型：**

-   `replace_if(beg, end, pred, new_value)`
    -   按照谓词的条件来替换为指定新元素

**示例：**

```cpp
/*  
 *  Description : 常用拷贝和替换算法 : replace_if
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 15:45
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << " ";
}

class Greater30
{
public:
    bool operator()(int val)
    {
        return val >= 30;
    }
};

void test01()
{
    vector<int> v;
    v.push_back(10);
    v.push_back(40);
    v.push_back(30);
    v.push_back(30);
    v.push_back(20);
    v.push_back(35);

    for_each(v.begin(), v.end(), myPrint);
    cout << endl;
    //将大于等于30的替换为3000
    replace_if(v.begin(), v.end(), Greater30(), 3000);
    for_each(v.begin(),  v.end(), myPrint);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   利用仿函数可以灵活满足筛选条件

#### 5.4.3 `swap`

**功能描述：**

-   互换两个容器的元素

**函数原型：**

-   `swap(container c1, container c2)`
    -   互换两个容器
    -   注意参数不是迭代器，而是两个同种类型的容器

**示例：**

```cpp
/*  
 *  Description : 常用的拷贝和替换算法 : swap
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 15:52
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class MyPrint
{
public:
    void operator()(int v)
    {
        cout << v << " ";
    }
};

void test01()
{
    vector<int> v1, v2;
    for(int i = 0; i < 10; i++)
    {
        v1.push_back(i);
        v2.push_back(i + 100);
    }
    for_each(v1.begin(), v1.end(), MyPrint());
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint());
    cout << endl;
    cout << "交换后: " << endl;
    swap(v1, v2);

    for_each(v1.begin(), v1.end(), MyPrint());
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint());
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   交换的容器要是同种类型



### 5.5 常用算术生成算法

**注意：**

-   算术生成算法属于小型算法，使用时包含的头文件为`#include<numeric>`

**算法简介：**

-   `accumulate`//计算容器元素累计总和
-   `fill`//向容器中添加元素



#### 5.5.1 `accumulate`

**功能描述：**

-   `accumulate(beg, end, val)`
    -   计算区间内元素累计总和
    -   val代表起始的累加值

**示例：**

```cpp
/*  
 *  Description : 常用算术生成算法 : accumulate
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 16:00
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <numeric>
using namespace std;

void test01()
{
   vector<int> v;
    for (int i = 0; i <= 100; ++i)
    {
        v.push_back(i);
    }
    int sum = accumulate(v.begin(),  v.end(), 0);
    cout << sum << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   可以计算容器内的总和，包含的头文件为`numeric`



#### 5.5.2 `fill`

**功能描述：**

-   向容器中填充指定的元素

**函数原型：**

-   `fill(beg, end, val)`
    -   向容器的区间填充val

**示例：**

```cpp
/*  
 *  Description : 常用算术生成算法 fill
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 16:08
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>
using namespace std;

void myPrint(int val)
{
    cout << val << " ";
}

void test01()
{
    vector<int> v;
    v.resize(10, 1);
    fill(v.begin(), v.end(), 100);
    for_each(v.begin(),  v.end(), myPrint);
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   更大的用途在于resize之后的填充。



### 5.6 常用集合算法

**算法简介：**

-   `set_interaction` //求两个容器的交集
-   `set_union`//求两个容器的并集
-   `set_difference`//求两个容器的差集



#### 5.6.1 `set_intersection`

**功能描述：**

-   求两个容器的交集

**函数原型：**

-   `set_intersection(beg1, end1, beg2, end2, dest)`
    -   求两个容器指定区间内的交集
    -   **注意：两个容器必须是有序序列**
    -   目标容器为dest
    -   **返回交集的最后一个位置！**
        -   因为dest里需要提前开辟空间，不一定全是交集的内容



**示例：**

```cpp
/*  
 *  Description : 集合操作 : set_intersection
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 16:11
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int v)
{
    cout << v << " ";
}

void test01()
{
    vector<int> v1, v2, vTarget;
    for (int i = 0; i < 10; ++i)
    {
        //0-9
        v1.push_back(i);
        //5-14
        v2.push_back(i + 5);
    }
    //目标容器提前开辟空间
    //最特殊的情况就是两个大容器包含了小容器 开辟空间取小容器的值即可
    vTarget.resize(min(v1.size(), v2.size()));

    //获取交集
    vector<int>::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
    //遍历时用返回值的迭代器
    for_each(vTarget.begin(), itEnd, myPrint);
    cout << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   总结：
>
>   -   求交集的两个序列必须有序
>   -   目标容器开辟空间需要**从两个容器的大小取较小的那个**
>   -   `set_intersection`返回值是交集中最后一个元素的位置

#### 5.6.2 `set_union`

**功能描述：**

-   求两个集合的并集

**函数原型：**

-   `set_union(beg1, end1, beg2, end2, dest)`
    -   求两个集合的并集
    -   **注意：两个集合必须是有序序列**
    -   dest：目标容器的起始迭代器
    -   返回值也是并集的最后一个元素位置

**示例：**

```cpp
/*  
 *  Description : 常用集合算法: set_union
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 16:37
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


void myPrint(int v)
{
    cout << v << " ";
}

void test01()
{
    vector<int> v1, v2, vTarget;
    for(int i = 0; i < 10; i++)
    {
        v1.push_back(i);
        v2.push_back(i + 5);
    }
    //目标容器提前开辟空间
    //最大情况为两个容器大小之和
    vTarget.resize(v1.size() + v2.size());
    vector<int>::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
    for_each(vTarget.begin(), itEnd, myPrint);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   总结：
>
>   -   求并集的两个序列必须有序
>   -   目标容器开辟空间需要**两个容器的size之和**
>   -   `set_union`返回值是并集中最后一个元素的位置



#### 5.6.3 `set_difference`

**功能描述：**

-   求两个集合的差集

**函数原型：**

-   `set_difference(beg1, end1, beg2, end2, dest)`
    -   求两个集合的差集
    -   **注意：两个集合必须是有序序列**
    -   dest是目标容器开始位置
    -   返回值是差集的最后一个元素的位置



**示例：**

```cpp
/*  
 *  Description : 常用集合算法: set_difference
 *  Created by 旋风冲锋龙卷风 on 2022/11/24 16:48
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void myPrint(int v)
{
    cout << v << " ";
}

void test01()
{
    vector<int> v1, v2, vT1, vT2;
    for (int i = 0; i < 10; ++i)
    {
        v1.push_back(i);
        v2.push_back(i + 5);
    }

    //给vT1和vT2开辟空间,为两个集合中大的size
    vT1.resize(max(v1.size(), v2.size()));
    vT2.resize(max(v1.size(), v2.size()));
    cout << "v1和v2的差集为:" << endl;
    vector<int>::iterator itEnd = set_difference(v1.begin(),  v1.end(), v2.begin(),  v2.end(), vT1.begin());
    for_each(vT1.begin(), itEnd, myPrint);
    cout << endl;

    cout << "v2和v1的差集为:" << endl;
    vector<int>::iterator itEnd2 = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vT2.begin());
    for_each(vT2.begin(), itEnd2, myPrint);
    cout << endl;
}
int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

>   总结：
>
>   -   求差集的两个序列必须有序
>   -   目标容器开辟空间需要**两个容器size较大的那个**
>   -   `set_difference`返回值是差集中最后一个元素的位置
>   -   算差集时还需要注意先后顺序，例如「v1和v2的差集」与「v2和v1的差集」结果不同

