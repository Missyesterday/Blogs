# 01 C++基础

## 1. C++概述

### 1.1 C++简介

C++是C的超集。C++在C语言的基础上增加了**面向对象编程**和**泛型编程**的支持。C++继承了C语言高效，简介，快速和可移植的传统。

C++融合了三种不同的编程方式：

-   C语言代表的过程性语言
-   C++在C语言基础上添加的类代表的面向对象语言
-   C++模版支持泛型编程

### 1.2 C++起源

起源于贝尔实验室，最初是为了摆脱汇编语言。

### 1.3 可移植性和标准

可移植性有两个方面：

1.   硬件
2.   语言的实现

C++的版本：

1.   C++98
2.   **C++11**：常用
3.   C++14

## 2. C++初识

### 2.1 C++ hello world

一个简单的`HelloWorld.cpp`

```C++
//标准输入输出流
#include <iostream>
using namespace std;//使用命名空间std

int main(){
    //<< 运算符重载
    cout << "hello world" << endl;
    return EXIT_SUCCESS;
}
```

### 2.2 面向对象三大特性

1.   封装

     把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

     类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。

2.   继承

     继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。

     继承的作用：避免公开代码的重复开发，减少代码和数据冗余。

3.   多态

     多态性可以简单地概括为“一个接口，多个方法”，字面意思为多种形态。**程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。**

## 3. C++对C的扩展

### 3.1 双冒号作用域运算符

直接加`::`代表全局作用域

```C++
#include <iostream>

using namespace std;

int atk = 200;
void test01(){
    int atk = 100;
    //双冒号作用域运算符 ::代表全局作用域
    cout << ::atk << endl;
}
int main() {
    test01();
    return EXIT_SUCCESS;
}
```

输出为`200`而不是100。

1.   命名空间下可以放函数、变量、结构体、类

2.   命名空间必须定义在全局作用域下

3.   命名空间可以嵌套命名空间

     ```C++
     namespace A
     {
         void func();
         int m_A = 10;
         struct Person{
     
         };
         class Animal {};
         namespace B
         {
             int m_A = 20;
         }
     }
     void test02()
     {
         cout << "namespace B下的m_A为" << A::B::m_A << endl;
     }
     ```

     输出20

4.   命名空间是开放的，可以在原先的命名空间添加内容

     ```c++
     //4 命名空间是开放的，可以在原先的命名空间添加内容,这个A会和之前的namespace A的合并
     namespace A
     {
         int m_B = 1000;
     }
     ```

5.   无名、匿名命名空间

     ```CPP
     //当写了无名、匿名命名空间，相当于写了 static int m_C; static int m_D;
     //只能在当前文件内使用
     namespace
     {
         int m_C = 0;
         int m_D = 1;
     }
     ```

6.   命名空间可以起别名

     ```cpp
     //6. 命名空间可以起别名
     namespace veryLongName
     {
         int m_A;
     }
     void test04()
     {
         namespace shortName = veryLongName;
         cout << veryLongName::m_A << endl;
         cout << shortName::m_A << endl;
     }
     ```

     

#### 总结

1.   解决命名冲突问题
2.   必须在全局作用域下声明
3.   命名空间下可以放入函数、变量、结构体和类
4.   命名空间可以嵌套命名空间
5.   命名空间是开放的，可以随时加入新成员
6.   匿名命名空间：相当于在变量前增加`static`
7.   命名空间可以起别名
8.   std 是系统标准的命名空间，为了和用户定义的名字不重复，所以它声明在 std 这个命名空间中。另外，这个空间也像一个大包一样，包括了系统所有的支持。

### 3.2 `using`关键字

```cpp
/*  
 *  Description : 
 *  Created by 旋风冲锋龙卷风 on 2022/10/16 02:07
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;
namespace KingGlory
{
    int sun = 10;
}

void test01()
{
    int sun = 20;
    //是用using声明时，要注意避免二义性
    //写了using声明后，下面这行代码说明以后看到的sun是用KingGlory下的
    //但是编译器又有就近原则，产生了二义性

    //using KingGlory::sun;
    cout << sun << endl;
}

namespace LOL
{
    int sun = 30;
}

//using编译指令
void test02()
{
    int sun = 20;
    //using编译指令
    using namespace KingGlory;//只是使用命名空间而已
    cout << sun << endl;
}

void test03()
{
    using namespace KingGlory;
    using namespace LOL;
    //这样又会产生二义性，如果使用using过多，也要避免二义性
    cout << LOL::sun << endl;
}

int main() {
    test03();
    return EXIT_SUCCESS;
}
```

### 3.3 全局变量检测增强

C语言代码：

`c_base.c`:

```c

int a;
int a = 10;
int main() {

    return EXIT_SUCCESS;
}
```

>   C语言可以正常编译

`cpp_extra.cpp`：

```cpp
#include <iostream>

using namespace std;

int a;
int a = 10;
int main() {

    return EXIT_SUCCESS;
}
```

>   CPP中显示重定义
>
>   <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221016022348268.png" alt="image-20221016022348268" style="zoom:40%;" />

### 3.4 函数检测增强

`c.base.c`:

```c
int getRectS(w, h)
{

}
void test02()
{
    getRectS(10,10,10);
}
```

上述C语言代码有3个问题：

1.   函数定义的时候没有明确参数的类型
2.   没有返回值
3.   传入的参数和定义的数量不同

但是可以编译通过。

**这些在C++中都是不可以的！**

### 3.5 类型转换检测增强

`c_base.c`:

```c
//3. 类型转换检测增强
void test03()
{
    //malloc的返回值是void*
    char *p = malloc(sizeof(64));

}
```

`malloc()`函数的返回值是`void*`，在C语言中可以用`char *`去接收它的返回值；但是在C++不行，必须强转：

```cpp
 char *p = malloc(sizeof(64));
```

### 3.6 struct增强

C语言中`struct`不可以增加函数，C++可以；C语言使用`struct`必须加`struct`关键字，C++可以不加。

```c
//4. struct增强
struct Person
{
    int m_Age;
    //void plusAge(); //C语言中struct不可以加函数
};
void test04()
{
    //C中必须加struct关键字
    struct Person p1;
}
```

### 3.7 bool类型增强

C++提供`bool`类型，非0代表true（包括负数），0代表false

```cpp
//5. bool类型增强，C++提供bool类型，只有true(非0)或false(0)
bool flag = true;
void test05()
{
    cout << sizeof(bool) << endl;
    flag = -100;
    cout << flag << endl; //修改成100仍然输出1，非0都输出1
}
```

### 3.8 三目运算符增强

c中：

```C
//6， 三目运算符增强
void test06()
{
    int a = 10;
    int b = 20;
    printf("ret = %d\n", a > b ? a : b);

    //a > b ? a : b = 100;
}
```

C++：

```cpp
//6， 三目运算符增强
void test06()
{
    int a = 10;
    int b = 20;
    cout << "ret = "<< (a > b ?a : b) << endl;
    （a > b ? a : b） = 100;
    cout << "a = "<< a << "b = " << b << endl;
}
```

C语言中三目运算符返回的是值，CPP中返回的是变量！最好加上括号。

若C语言中想模仿C++，可以使用：

```C
*(a > b ? &a : &b) = 100;
```

### 3.9 `const`增强

C中`const`修饰的是伪常量，会分配内存空间，在全局区域

```C
const int m_A = 10; //在全局区域内，受到保护，不能更改
void test07(){
    //m_A = 1;
    const int m_B = 20;//伪常量
    //m_B = 10;
    int *p =(int *) &m_B;
    *p = 5;
    //int arr[m_B] //不能初始化数组  
    printf("*p = %d ,m_B = %d \n", *p, m_B);

}
```

`const`修饰的`m_A`被修改了，与`*p`相同，同时也不能用`int arr[m_B]`初始化数组。而在C++中不能通过指针来修改`const`的值，`*p`和`m_B`的结果不同，同时也可以用常量初始化数组。

>   C语言中，`const`修饰的变量，是伪常量，编译器会分配内存的，C++中，`const`不会分配内存，`const int m_B = 20;`，会直接放在符号表中。
>
>  
>
>   所以改了的值并不是`m_B`，而是临时开辟的内存，保证了`const`修饰的变量不会被修改。

### 3.10 C语言`const`默认是外部链接，C++默认是内部链接

test.c

```c
const int a = 10;
```

extern.c

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main()
{
    extern const int a; //让编译器在外部找外部链接a
    //C语言中const 默认是外部链接
    printf("a = %d \n", a);
    return EXIT_SUCCESS;
}
```

C++无法解析，C++的`const`默认内部链接，作用域仅限内部文件，需要在声明是使用`extern`声明是外部链接。

test.cpp

```cpp
extern const int a = 10;
```

### 3.11 `const`的内存分配情况

对变量取地址，会分配临时内存

extern关键字下的const会分配内存

用普通变量初始化const变量

自定义数据类型会分配内存

```cpp
/*  
 *  Description : 用来演示const的内存分配情况
 *  Creaeted by 旋风冲锋龙卷风 on 2022/10/28 18:40
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

//1. cosnt分配内存，取地址会分配临时内存,只要能用指针修改值的都是分配了临时内存
//2 extern也会给const变量分配内存
void test01()
{
    const int m_A = 10;
    int *p = (int*)&m_A;//会分配临时内存
    *p = 50;
    cout << m_A << endl;
}
//3. 用普通变量初始化const的变量

void test02()
{
    int a = 10;
    const int b = a;//会分配内存！

    int *p = (int *) &b;
    *p = 1000;
    cout << "b = " << b << endl;
}

//4. 自定义数据类型 加上const也会分配内存
struct Person
{
    int m_Age;
    string m_Name; //姓名

};

void test03()
{
    const Person p1{};
    Person * p = (Person*)&p1;
    p->m_Name = "张三";
    (*p).m_Age = 19;

    cout << "姓名" << p1.m_Name << "年龄" << p1.m_Age <<endl;
}

int main() {
    test02();
    return EXIT_SUCCESS;
}

```

只有`const int a = 10`这种方式不会分配内存，而是放到符号表里。

### 3.12 用`const`替换`#define`

1.   define对于编译器没有意义
2.   宏定义对于编译器没有类型检测
3.   define的变量没有作用域，但是可以指定作用域的结束周期:`undefine`

### 3.13 引用Reference

引用的实质就是起别名。

```cpp
int a = 10;
int &b = a;
```

`&`写到左侧，叫引用，写到右侧，取地址。通过上面的语句，`a`和`b`指向同一个空间。修改`a`，`b`会改变，反之亦然。同时使用的时候不需要加`&`符号。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221030014118883.png" alt="image-20221030014118883" style="zoom:40%;" />



reference.cpp

```cpp
/*  
 *  Description : 引用的基本用法
 *  Created by 旋风冲锋龙卷风 on 2022/10/30 01:42
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    int a = 10;
    int &b = a;

    b = 20;

    cout << "a  = " << a << endl;
    cout << "b  = " << b << endl;
}

int main() {
    test01();
    return EXIT_SUCCESS;
}
```

运行结束后`a`和`b`都是20。

引用必须初始化，不能直接`int &a;`。**一旦引用初始化后，就不可以修改了。**

```cpp
void test02()
{
    //引用必须初始化
    int a = 10;
    int &b = a;
    int c = 20;
    b = c;
}
```

其中`b = c`是赋值，而不是修改。

**给数组起别名**

```cpp
void test03()
{
    int arr[10];

    for (int i = 0; i < 10; ++i)
    {
        arr[i] = i;

    }
    //给数组起别名
    int(&pArr)[10] = arr;
    for (int i = 0; i < 10; ++i)
    {
        cout << pArr[i] << endl;
    }

    //第二种方式 起别名
    //一个具有10个元素的int类型数组
    typedef int(ARRAYREF)[10];
    ARRAYREF & pArr2 = arr;
    for (int i = 0; i < 10; ++i)
    {
        cout << pArr2[i] << endl;
    }

```

`pArr`、`pArr2`和`arr`操作的是同一个数组。

### 3.14 参数的传递方式

#### 值传递

```cpp
void mySwap(int a, int b)
// 逻辑上的传递用值传递
{
    int tmp = a;
    a = b;
    b = tmp;
    cout << "mySwap::a = " << a << endl;
    cout << "mySwap::b = " << b << endl;
}
mySwap(a, b);
```



#### 地址传递

```cpp
void mySwap2(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
 mySwap2(&a, &b);
```

#### 引用传递

相当于`int &a = a`

```cpp
//引用传递, &a = a
void mySwap3(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
mySwap3(a, b);
```

引用传递和值传递都能修改值本身。引用传递与值传递类似。学完引用之后就可以不用指针传参了。引用比指针相对简单。**C++主张用引用传递取代地址传递的方式，因为引用语法容易且不易出错。**通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单: 

1.   函数调用时传递的实参不必加`&`符
2.    在被调函数中不必在参数前加`*`符

### 3.15 引用的注意事项

1.   引用必须引用一块合法的内存空间,不能直接引用值

     ```cpp
     int &a = 10;//这是不行的
     ```

2.   不要返回局部变量的引用

     ```cpp
     //引用的注意事项
     int& doWork()
     {
         //局部变量的生命周期仅在函数内
         int a = 10;
         return a;
     }
     
     void test04()
     {
         //2. 不要返回局部变量的引用
         int &ret = doWork();
         //第一次是编译器做了优化
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
     }
     ```

     输出：

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221030210001537.png" alt="image-20221030210001537" style="zoom:40%;" />

     可以看到仅有第一次正确输出。

     **而对于静态变量则可以返回引用**

     ```cpp
     int& doWork2()
     {
         static int a = 10;
         return a;
     }
     void test05()
     {
         int &ret = doWork2();
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
         cout << ret << endl;
     }
     ```

     ![image-20221030210641746](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221030210641746.png)

3.   如果函数的返回值是引用，那么这个函数可以作为左值

     ```cpp
         doWork2() = 1000; // 相当于 a= 1000;
     ```

### 3.16 引用的本质

>   引用的本质在C++的内部实现是一个指针常量，所以它指向的地址是不能更改的，同时也必须初始化。前面说过，引用指向的也是一块地址。

```cpp
int &aRef = a;
aRef = 20;
```

编译器会替换成：

```cpp
int* const aRef = &a;
*aRef = 20;
```

### 3.17 引用的使用场景

#### 指针的引用

有了引用之后，二级指针可以变成一级指针，一级指针直接变成引用，同时可以避免函数内外`p`的含义不同。**引用不产生新的变量，减少形参与实参传递时的开销。**

```cpp
/*  
 *  Description :描述指针的引用
 *  Created by 旋风冲锋龙卷风 on 2022/10/30 22:05
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;
struct Person
{
    int m_Age;
};

//**p:具体的Person对象 *p:对象的指针 p:指针的指针
void allocateMemory(Person **p)
{
    *p = (Person *) malloc(sizeof(Person));

    (*p)->m_Age = 100;
}
void test01()
{
    Person* p = NULL;
    allocateMemory(&p);
    cout << "p的年龄" << (*p).m_Age  << endl;
    cout << "p的年龄" << p->m_Age  << endl;
}

//*&p相当于指针的引用
void allocateMemoryByRef(Person *&p)
{
    p = (Person*) malloc(sizeof(Person));
    p->m_Age = 1000;
}

void test02()
{
    Person* p = NULL;
    allocateMemoryByRef(p);
    cout << "p的年龄:" << p->m_Age << endl;
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



#### 常量的引用

只要申请了内存空间，都可以通过指针绕过编译器检查来修改它。加上const后，临时空间是找不到的。而且可以通过指针绕开修改，**但是不能直接修改。！**所以如果不想修改参数，使用`const int &a`的参数格式。

```cpp
/*  
 *  Description : 常量的引用
 *  Created by 旋风冲锋龙卷风 on 2022/10/30 22:43
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

void test01()
{
    //int &ref = 10;//引用了不合法内存
    const int &ref = 10;//加入了const后,编译器处理方式为: int tmp = 10; const int &ref = tmp;
    int *p = (int *) &ref;
    *p = 1000; //可以修改,防君子不防小人,const是给人看的
    cout << ref << endl;

}
//常量引用的使用场景,用来修饰形参
void showValue(const int &val)
{
    //val += 100;//如果只是想显示内容,而不修改内容,那么就用const来修饰这个形参,能修改,但是不能这样直接修改,需要通过指针绕过
    cout << "val = " << val << endl;
}
void test02()
{
   int a = 10;
   showValue(a);
}
int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

### 3.18 练习

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221104190758798.png" alt="image-20221104190758798"  />

```cpp
/*  
 *  Description : 设计一个圆类
 *  Created by 旋风冲锋龙卷风 on 2022/11/04 19:09
 *  个人博客 : http://letsgofun.cn/
 */
//

#include "Circle.h"
#include <iostream>

using namespace std;
const double PI = 3.14;

class Circle
{
private:

public:

    //在类里的函数被称为成员函数
    //求圆的周长
    double calculateZC()
    {
        return 2 * PI * m_R;
    }

    //设置半径的成员方法,成员函数可以修改成员属性
    void setR(int r)
    {
        m_R = r;
    }
    //半径,成员属性
    int m_R;
};

void test01()
{
    //通过类 来创建一个圆
    Circle c1;
    c1.setR(10);
    cout << "c1的周长为: " << c1.calculateZC() << endl;
}

int main()
{
    //查看CLoin使用的是什么编译器
    cout << __VERSION__ << endl;
    test01();
    return EXIT_SUCCESS;
}
/*  
 *  Description :描述指针的引用
 *  Created by 旋风冲锋龙卷风 on 2022/10/30 22:05
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;
struct Person
{
    int m_Age;
};

//**p:具体的Person对象 *p:对象的指针 p:指针的指针
void allocateMemory(Person **p)
{
    *p = (Person *) malloc(sizeof(Person));

    (*p)->m_Age = 100;
}
void test01()
{
    Person* p = NULL;
    allocateMemory(&p);
    cout << "p的年龄" << (*p).m_Age  << endl;
    cout << "p的年龄" << p->m_Age  << endl;
}

//*&p相当于指针的引用
void allocateMemoryByRef(Person *&p)
{
    p = (Person*) malloc(sizeof(Person));
    p->m_Age = 1000;
}

void test02()
{
    Person* p = NULL;
    allocateMemoryByRef(p);
    cout << "p的年龄:" << p->m_Age << endl;
}
int main()
{
    test02();
    return EXIT_SUCCESS;
}
```



**设计抽象类**

1.   class类名
2.   public 公共权限
3.   成员属性
4.   成员函数
5.   创建对象（实例化）
6.   通过对象来掉用成员函数

>   类和对象的关系
>
>   1.   类是对象的抽象
>   2.   对象是对类的实例

### 3.19 内联函数（inline function）

#### 3.19.1 引出

C++中用来替代C中宏函数的解决方法。

C中存在宏函数，用来定义一些短小常用的函数。宏函数有很多缺陷，同时没有作用域。例如：

```cpp
#include <iostream>

using namespace std;

//宏函数定义一个加法
#define MyAdd(x, y) x + y

void test01()
{
    int ret = MyAdd(1,3) * 3;
    //预期结果与实际不同
    cout << ret << endl; //10
}

#define MyCompare(a, b) a < b ? a : b

void test02()
{
    int a = 10;
    int b = 20;
    //++a < b ? ++a : b
    int ret = MyCompare(++a, b); //12
    cout << ret << endl;
}

```

C中的宏函数是直接替换的，展开的时候很容易出现缺陷。C++引入了内联函数。

#### 3.19.2 内联函数

`inline`关键字用来定义内敛函数。

```cpp
inline void func(int a)
```

**内联函数本身就是一个真正的函数，唯一的区别就是内联函数在适当的时候会像预定义宏一样张开，不需要函数调用的开销，同时它没有上述宏函数的缺陷**

```cpp

inline int myCompare(int a, int b)
{
    return a < b ? a : b;

}
```

#### 3.19.3 内联函数注意事项

1.   内联函数声明和实现如果分开，都要加上`inline`关键字

     ```cpp
     //内联函数声明
     inline void func();
     //内联函数实现,如果在函数实现的时候没有加inline关键字,那么函数依然不算内联函数
     void func(){}
     ```

2.   内联函数是以空间换时间

3.   **类内部定义的成员函数会自动替换成内联函数**

#### 3.19.4 内联函数与编译器

内联函数不一定会被展开处理，以下情况编译器可能考虑不会将函数进行内联编译：

1.   不能存在任何形式的循环语句
2.   不能存在过多的条件判断语句
3.   函数体不能过于庞大（这是个定性的分析）
4.   不能对函数进行**取址操作**

>   内联仅仅是给编译器一个建议，编译器不一定接受这种建议，如果没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。

所以内联函数这个概念了解即可。

### 3.20 函数的默认参数

C++在声明函数原型的时候可以为一个或者多个参数指定默认（缺省）的参数值，当函数调用的时候如果没有指定这个值，编译器会自动用默认值代替。例如：

```cpp
//如果一个位置有了默认参数，那么它的后面都必须要有默认参数
void testFunc01(int a, int b = 10, int c = 1)
{
    cout << a + b + c<< endl;
}

testFunc01(1，2);//对应a，b
testFunc01(1);// 对应a
```

如果函数声明中有了默认参数，那么函数实现的时候必须没有默认参数！

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105001425021.png" alt="image-20221105001425021" style="zoom:40%;" />

**会显示重定义Error，函数的声明与实现最多只能出现一个默认参数。**

### 3.21 函数的占位参数

占位参数没有什么大用，只有重载的时候有一点用

```cpp
//如果有了占位参数,函数调用之后必须提供这个参数,但是这个参数用不到

void func1(int a, int)
{

}
int main()
{
    func1(10, 1);
    return EXIT_SUCCESS;
}
```

调用的时候必须提供，如果不想提供，占位参数也可以有默认参数

```cpp
void func1(int a, int = 10)
{

}
```

而C语言中没有默认参数和占位参数。

### 3.22 函数重载(overload)

#### 3.22.1 基本语法

C++中 函数名称可以重复，前提是必须在同一个作用域下，还需要满足：函数的参数个数不同 或者 类型不同（加不加`const`也属于这种情况），或者顺序不同。返回值不同不能作为函数重载的条件，因为函数调用时对于返回值可以不做处理。**

同时还需要注意，函数重载和默认参数之间的二义性问题：

```cpp
//函数重载与默认参数的冲突
void func2(int a, int b = 10)
{
    
}
void func2(int a)
{
    
}
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105004827389.png" alt="image-20221105004827389" style="zoom:40%;" />

此时会出现二义性，需要避免这种情况。

**还需要注意引用的重载：**

```cpp
//引用的重载
void func3(int &a)
{

}

void func3(const int &a)
{

}

void test03()
{
    func3(10);
}
```

此时会调用下面的`func3`，原因在于10是一个数字，不是一个合法的内存空间，不能直接作为引用参数的输入，但是加上`const`关键字后，会临时开辟一块临时空间，此时10可以直接作为下面`func3`的时参数。

#### 3.22.2 函数重载的实现原理

编译器为了实现函数重载，会默认做一些幕后的工作，编译器用不同的参数类型来修饰不同的函数名，比如`void func();`，编译器可能会将函数名修饰为`_func()`，当编译器碰到`void func(int x)`，可能会将函数名修饰为`_func_int`，碰到`void func(int x, char y)`，可能修饰为`_func_int_char`。使用`可能`的原因在于，编译器修饰重载的函数名称没有统一的标准，不同的编译器可能产生不同的内部名。

### 3.23 `extern “C”`浅析

`extern "C"`解决了在C++中调用C语言的函数。

有`test.h`、`test.c`和`externC.cpp`三个文件

```
test.h
#ifndef INC_01C_BASIC_TEST_H
#define INC_01C_BASIC_TEST_H
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>

void show();

void show2();

#ifdef __cplusplus
}
#endif


#endif //INC_01C_BASIC_TEST_H

```

test.c

```c

#include "test.h"
void show()
{
    printf("hello world!");
}
void show2()
{
    printf("zz");
}
```

extern.cpp

```cpp
#include <iostream>
#include "test.h"
using namespace std;

//C++调用C语言的方法



int main()
{
    //在C++中,函数是会发生重载的,编译器会将函数名称偷偷改变 找的是:_show而非show
    show();
    show2();
    return EXIT_SUCCESS;
}
```

这样可以在C++中调用C的函数。

```c
#ifdef __cplusplus
extern "C" {
#endif
    
// Your C Code
 
     
#ifdef __cplusplus
}
#endif

```

## 4. 面向对象

### 4.1 面向对象的基本概念

#### 4.1.1 类的封装

对于C的类（struct）

```c
/*  
 *  Description : 4.1.1 C的封装
 *  Created by 旋风冲锋龙卷风 on 2022/11/05 01:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include<stdio.h>
#include<string.h>
#include<stdlib.h>

struct Person
{
    char mName[64];
    int mAge;
};

void PersonEat(struct Person *person)
{
    printf("%s在吃饭\n", person->mName);
}

void test01()
{
    struct Person p1;
    strcpy(p1.mName,"张三");

    PersonEat(&p1);
}


struct Dog
{
    char mName[64];
    int mAge;
};

void DogEat(struct Dog * dog)
{
    printf("%s在吃狗粮\n", dog->mName);

}

void test02()
{
    struct Dog d1;
    strcpy(d1.mName,"旺财");
    struct Person p1;
    strcpy(p1.mName,"张三");
    DogEat(&d1);
    DogEat(&p1);

}


int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

![image-20221105020248585](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105020248585.png)

C语言的封装属性和行为是分开的，C的struct不能放函数；同时C没有严格的类型检测。

C++的封装会将属性和行为绑定在一起，同时有严格的类型转换检测。



```cpp
struct Person
{
    char mName[64];
    int mAge;
    void personEat()
    {
        cout << mName << "在吃饭" << endl;
    }
};
```

同时C++的封装有控制权限：

1.   public：公有成员（属性、函数）在类内部和类外部都可以访问

2.   protected：**保护权限在类内部可以访问，当前类的子类可以访问，类外部不可以访问**

     例如：你的财产是受保护的，你的儿子可以继承你的受保护财产

3.   private：私有成员在类内部可以访问，类外部不可以访问 

C++中`class`和`struct`是一个意思，唯一的区别是`struct`的默认权限是`public`，而`class`的默认权限是`private`。C++通常使用`class`。

#### 4.1.2 建议将所有成员变量设置为private

通过`set`和`get`函数来控制这些成员变量的读写权限。

### 4.2 OOP案例

#### 4.2.1 设计立方体类

![image-20221105142028315](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105142028315.png)

```cpp
/*  
 *  Description : 面向对象设计一个立方体,求面积 体积和判断相等
 *  Created by 旋风冲锋龙卷风 on 2022/11/05 14:21
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Cube
{
public:
    //set函数
    void setL(int L)
    {
        m_L = L;
    }

    int getL()
    {
        return m_L;
    }

    int getW()
    {
        return m_W;
    }

    int getH()
    {
        return m_H;
    }

    void setW(int W)
    {
        m_W = W;
    }
    void setH(int H)
    {
        m_H = H;
    }

    //求立方体的面积
    void getCubeS()
    {
        cout << "立方体的面积为: " << 2 * m_H * m_L + 2 * m_H * m_W + 2 * m_L * m_W <<  endl;
    }

    //求立方体的体积
    void getCubeV()
    {
        cout << "立方体的体积为: " << m_H * m_L * m_W << endl;
    }

    //通过成员函数比较两个立方体
    bool compareCubeByClass(Cube &c)
    {
        return m_H == c.getH() && m_L == c.getL() && m_W == c.m_W;
    }

private:
    //长宽高
    int m_L;
    int m_W;
    int m_H;
};

//全局函数判断两个立方体是否相等,使用引用传递
bool compareCube(Cube &c1, Cube &c2)
{
    //加const不能访问成员方法(因为编译器不能确定成员函数是否修改了成员属性,所以不用const Cube &c1
    //但是可以在成员函数后面添加const来说明该成员函数没有修改成员属性）
    if(c1.getH() == c2.getH() && c1.getL() == c2.getL() && c1.getW() == c2.getW())
        return true;
    return false;
}


void test01()
{
    Cube c1;
    c1.setH(2);
    c1.setL(3);
    c1.setW(4);
    c1.getCubeS();
    c1.getCubeV();

    Cube c2;
    c2.setH(2);
    c2.setL(3);
    c2.setW(4);
    //0假   1真
    cout << compareCube(c1, c2)  << endl;
    cout << c1.compareCubeByClass(c2) << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

 

#### 4.2.2 点和圆的关系

成员也可以另一个类。

![image-20221105152909123](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105152909123.png)

```cpp
/*  
 *  Description : 4.2.2点和圆的关系
 *  Created by 旋风冲锋龙卷风 on 2022/11/05 15:20
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <cmath>
using namespace std;

class Point
{
public:
    //在成员函数声明后加const代表不会修改成员属性,那么const修饰的参数也可以调用这类成员函数
    int getX() const
    {
        return m_X;
    }

    int getY() const
    {
        return m_Y;
    }

    void setX(int mX)
    {
        m_X = mX;
    }

    void setY(int mY)
    {
        m_Y = mY;
    }

private:
    int m_X;
    int m_Y;
};

class Circle
{

public:
    int getR() const
    {
        return m_R;
    }

    void setR(int mR)
    {
        m_R = mR;
    }

    void setC(Point mC)
    {
        m_C = mC;
    }

    //这样操作方便,同时加上const也不能修改成员变量,与直接返回Point相比节省了空间
    const Point &getC() const
    {
        return m_C;
    }

    // const Point & p 可以调用p的const的get函数
    void isInCircleByClass(const Point & p)
    {
        double distance = pow((getC().getX() - p.getX()),2) + pow((getC().getY() - p.getY()), 2);
        double rDistance = pow(getR(), 2);
        if(distance == rDistance)
        {
            cout << "点在圆上" << endl;
        }
        else if(distance < rDistance)
        {
            cout << "点在圆内" << endl;
        }
        else
        {
            cout << "点在圆外" << endl;
        }
    }
private:
    //半径和圆心
    int m_R;
    Point m_C;
};

void isInCircle(Circle &c,Point &p)
{
    //获取圆心和点之间的距离的平方
    double distance = pow((c.getC().getX() - p.getX()),2) + pow((c.getC().getY() - p.getY()), 2);
    double rDistance = pow(c.getR(), 2);
    if(distance == rDistance)
    {
        cout << "点在圆上" << endl;
    }
    else if(distance < rDistance)
    {
        cout << "点在圆内" << endl;
    }
    else
    {
        cout << "点在圆外" << endl;
    }
}

void test01()
{
    Point p1;
    p1.setX(10);
    p1.setY(10);

    Circle c1;
    Point center;
    center.setX(10);
    center.setY(0);
    c1.setC(center);
    c1.setR(9);
    isInCircle(c1,p1);
    c1.isInCircleByClass(p1);
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

注意在实际开发中，需要将这些类分离到不同文件中，并分成`.h`和`.cpp`文件。



### 4.3 对象的构造和析构

#### 4.3.1 初始化和清理（构造函数和析构函数）

为了解决这两个问题，C++的解决方案是使用**构造函数**和**析构函数**。这两个函数会被编译器自动调用，完成对象的初始化和对象清理工作。

如果没写这两个函数，编译器会自动加上这两个函数，但是没有任何代码。

构造函数的写法如下：

```cpp
class Person
{
   
public:
    //构造函数写法
    //函数名与类名相同,没有返回值,也不写void,可以发生重载(可以有参数)
    Person()
    {
        cout << "Person的构造函数" << endl;
    }
        Person(int a)
    {
        cout << "重载的构造函数" << endl;
    }
};

void test01()
{
    //会默认调用构造和析构,只不过是系统提供的两个空实现的函数
    Person p1;
}

```

1.   函数名与类名相同,没有返回值,也不写void,可以发生重载(可以有参数)
2.   构造函数由编译器自动调用，而不是手动，并且只会调用一次。
3.   构造和析构必须写在`public`下

析构函数的写法如下：

```cpp
    ~Person()
    {
        cout << "Person的析构函数" << endl;
    }
```

1.   函数名为`~类名` 也没有返回值,没有参数(不能重载)
2.   析构函数也是自动调用

#### 4.3.2  构造函数的分类及调用

构造函数分为：

-   按参数进行分类：

    -   无参构造函数（默认构造函数）

        默认构造函数调用不用加`()`,`Person p1;`即可。`Person p1()`**编译器会认为这是函数的声明。**

    -   有参构造函数

-   按类型进行分类

    -   普通构造函数

    -   拷贝构造函数

        ```cpp
            //拷贝构造函数的调用
            //保证拷贝的时候不能修改传入的数据,加上const,同时&可以节省空间
            Person(const Person &p)
            {
                m_Age = p.m_Age;
                cout << "拷贝构造函数调用" << endl;
            }
        
        ```



同时，构造函数可以使用三种种方法调用，分别是：

```cpp
    //这是小括号调用
    Person p1(1);
    p1.m_Age = 10;
    Person p2(p1);
    cout << p2.m_Age << endl;
    Person p3;

    //这是匿名对象调用
    Person p4 = Person(100);
    Person p5 = Person(p4);
    Person(100);//匿名对象，如果编译器发现了对象是匿名的，那么这行代码结束后，就会释放这个对象，而不是整个函数结束
    
    //这是隐式类型转换
    Person p7 = 100; //相当于Person p7(100),隐式类型转换
    Person p8 = p7; // Person p8 = Person(p7); 但是不直观，不建议使用
```

**不能用拷贝构造函数来初始化匿名对象**。下面的代码是不可以的：

```cpp
Person p4 = Person(100);
Person(p4);
```

如果这么写（写成左值），编译器认为这是`Person p4`，对象的声明，会重定义的错，但是如果写成右值是可以的。**同时需要注意，如果p4之前没定义，这么写相当于 `Person p4`。**



#### 4.3.3 拷贝构造函数的调用时机

1.   用已经创建好的对象来初始化新的对象

     ```cpp
         Person p1;
         Person p2(p1);
     ```

2.   以值传递的方式给函数参数传值

     ```cpp
     void doWork(Person p1)
     {
     
     }
     
     void test03()
     {
         Person p1(10);
     
         doWork(p1);
     }
     ```

     相当于`Person p = Person(p1)`，会调用拷贝构造，所以提倡使用引用传递。

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105203854859.png" alt="image-20221105203854859" style="zoom:67%;" />

3.   以值的方式返回局部对象

     ```cpp
     //值的方式返回局部对象
     Person doWork2()
     {
         Person p1;
         return p1;
     }
     
     void test04()
     {
         Person p = doWork2();
     }
     
     ```
     
      但是在我的环境下并没有调用拷贝构造函数，甚至没有调用构造函数！原因在于老师用的VS的`Debug`模式，如果采用`Release`模式，则也不会调用构造函数，编译器会优化，偷偷使用引用传递。



#### 4.3.4 构造函数的调用规则

系统会给一个类提供三个函数：

1.   默认构造函数：无参，函数体为空
2.   拷贝构造函数：进行简单的值拷贝
3.   析构函数：无参，函数体为空



自己写的构造函数和系统提供的会有一些规则：

1.   当我们写了有参构造函数，那么系统就不会提供默认构造函数了，但是系统提供的默认拷贝构造函数还在。

     ```cpp
     class MyClass
     {
     public:
         MyClass(int a)
         {
             cout << "有参构造函数" << endl;
         }
     };
     
     void test01()
     {
         MyClass c1(1);
         MyClass c2(c1);
     }
     ```

     这里不能用`MyClass c3;`。也就是没有默认构造函数了。

2.   当我们提供了拷贝构造函数，那么系统就不会提供其他构造函数了（相当于默认的拷贝构造函数被覆盖了）。

#### 4.3.5 深拷贝和浅拷贝

浅拷贝和深拷贝就是拷贝值和拷贝指针的区别。栈上存基本数据类型和指针，堆存具体的string值。如果使用简单的浅拷贝，会导致两个指针指向同一块堆区，析构的时候会释放两次导致崩溃。



```cpp
    //拷贝函数系统会提供简单的值拷贝构造函数,需要自己提供拷贝函数,浅拷贝会导致释放相同的堆区空间两次

    //深拷贝则是创建一块新的堆区,然后把原来堆区的值拷贝到新的堆区
    Person(const Person & p)
    {
        m_Age = p.m_Age;
        m_Name = (char *) malloc(strlen (p.m_Name) + 1);
        strcpy(m_Name, p.m_Name);
    }

    //析构函数
    ~Person()
    {
        cout << "析构函数调用" << endl;
        if(m_Name != NULL)
        {
            free(m_Name);
            m_Name = NULL;
        }
    }
```

#### 4.3.6 初始化列表的基本使用

使用方式非常简单，在函数后面加`:`。

```cpp

class Person
{
public:
    //利用初始化列表来初始化参数
    Person() : m_A(1), m_B(2), m_C(3)
    {}

    Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c)
    {}



    int m_A;
    int m_B;
    int m_C;
};

```

>   同时需要注意：不一定需要把所有的值都写上，可以只写一部分，剩下的在函数体里完成！

#### 4.3.7 类对象作为成员

当类对象作为类成员的时候，构造顺序先将类对象一一构造，然后构造自己，析构的顺序是相反的。

```cpp
/*  
 *  Description : 类作为成员变量的情况
 *  Created by 旋风冲锋龙卷风 on 2022/11/05 21:41
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

class Phone
{
public:
    Phone()
    {
        cout << "Phone的默认构造调用" << endl;
    }
    string phoneName;

    Phone(const string &phoneName) : phoneName(phoneName)
    {}
};

class Game
{
public:
    Game()
    {
        cout << "Game的默认构造函数调用" << endl;
    }

    string gameName;

    Game(const string &gameName) : gameName(gameName)
    {}
};

class Person
{
public:
    //使用string相比char *会自动维护,不需要手动释放
    string m_Name;
    Phone m_phone;
    Game m_Game;

    Person(const string &mName, const Phone &mPhone, const Game &mGame) : m_Name(mName), m_phone(mPhone), m_Game(mGame)
    {}

    Person(string name, string phoneName, string gameName) : m_Name(name), m_phone(phoneName), m_Game(gameName)
    {}

    ~Person()
    {
        cout << "Person的析构函数调用" << endl;
    }
};

void test01()
{
    Person p("Lisa", "苹果", "LOL");
    cout << p.m_Name << endl << p.m_Game.gameName << endl << p.m_phone.phoneName << endl;
    //p.m_phone.phoneName = "苹果";
    //p.m_Game.gameName = "LOL";

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

初始化列表调用的是类对象的有参构造函数。

#### 4.3.8 `explicit`关键字

唯一的作用：防止构造函数调用时的隐式类型转换。是针对单参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言

```cpp
    explicit MyString(int a)
    {}
```

![image-20221105222347053](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221105222347053.png)

#### 4.3.9 静态成员

静态成员就是在成员变量和成员函数前加上关键字`static`，称为静态成员。

静态成员分为：

-   静态成员变量

    -   所有对象共享同一份数据

        ```cpp
        void test01()
        {
            Person p;
        
            cout << p.m_A << endl; //1
        
            Person p2;
            p2.m_A = 10;
            cout << p.m_A << endl; //10
        }
        ```

    -   在编译阶段分配内存

    -   类内声明，类外初始化

        ```cpp
        class Person
        {
        public:
            static int m_A;
        };
        int Person::m_A = 1;
        ```

    -   可以通过对象或者类名进行访问

        ```cpp
           //2. 通过类名进行访问
            cout << Person::m_A << endl;
        ```

    -   **静态成员变量也有访问权限**，私有权限类外无法访问

-   静态成员函数

    -   所有对象共享同一个函数

    -   静态成员函数只能访问静态成员变量，因为非静态成员变量需要创建对象才能访问，而静态成员变量只有一份。

    -   静态成员函数也有访问权限

    -   调用方法也是可以通过类名或者对象名

        ```cpp
        class Person
        {
         public:
                //静态成员函数
            static void func()
            {
                cout << "static func的调用"  << endl;
            }
            
        };
        
        void test03()
        {
            Person p;
            p.func();
            Person::func();
        }
        ```

        >   需要注意，通过类名访问静态成员的时候，C++使用`::`，而Java使用`.`。

### 4.4 C++对象模型和this 指针

#### 4.4.1 成员变量和成员函数分开存储

在C++中，类中的成员变量和成员函数是分开存储，**只有非静态成员变量才属于类的对象上。**

```cpp
class Person
{

};

void test01()
{
    Person p;
    //空对象占用的内存空间是1
    cout << "sizeof p = " << sizeof(p) << endl;

```

C++编译器也会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置。每个空对象也应该有一个独一无二的内存地址。

```cpp
class Person
{
    int m_A; // 非静态成员变量
};
void test02()
{
    Person p;
    //一个int就是4
    cout << "sizeof p = " << sizeof(p) << endl;
}
```

如果不是空，那么就该分配多少就分配多少，

```cpp
class Person
{
    int m_A; // 非静态成员变量
    static int m_B;//静态成员变量
};
```

sizeof仍然为4。

```cpp
class Person
{
    int m_A; // 非静态成员变量
    static int m_B;
    void func(); // 非静态成员函数，不在类的对象上
};
```

sizeof仍然为4，所以函数也只有一份，通过this指针区分。

```cpp
class Person
{
    int m_A; // 非静态成员变量
    static int m_B;
    void func();
    static void func2(); //静态成员函数
};
```

sizeof仍然为4。所以综上，只有非静态成员变量在类对象上，空对象的sizeof为1。

#### 4.4.2 this指针概念

**this指针指向被调用的成员函数所属的对象。**this指针是隐含每一个非静态成员函数内的一种指针，this指针也不需要定义，直接使用即可。

this指针的作用：

-   当形参和成员变量同名时，可用this指针来区分。

    ```cpp
        Person(int age)
        {
            this->age = age;
        }
    ```

-   在类的非静态成员函数中返回对象本身，可以使用`return *this`。

    ```cpp
    class Person
    {
    public:
        Person(int age)
        {
            //this指针指向被调用的成员函数所属的对象
            this->age = age;
        }
        //如果不用引用传递而是值传递，则会调用拷贝构造函数，p2只会加一次，剩下的加到复制的对象上去了，输出p2的age为20。如果想正确输出，需要用一个左值来接收。
        Person& personAddPerson(Person &p)
        {
            this->age += p.age;
            return *this; //返回对象自身
        }
        int age;
    };
    
    void test02()
    {
        Person p1(10);
        Person p2(10);
        p2.personAddPerson(p1).personAddPerson(p1).personAddPerson(p1);
        cout << p2.age << endl;
    }
    ```

    这种编程思想叫做链式编程。

#### 4.4.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针。如果用到this指针，需要加以判断保证代码的健壮性。

**示例：**

```cpp
/*  
 *  Description : 空指针调用成员函数
 *  Created by 旋风冲锋龙卷风 on 2022/11/08 22:53
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Person
{
public:
    void showClassName()
    {
        cout << "this is Person Class" << endl;
    }

    void showPersonAge()
    {
        if (NULL == this)
        {
            return;
        }
        cout << "age = " << m_Age << endl;
    }
    int m_Age;
};

void test01()
{
    Person *p = NULL;
    //正常调用
    p->showClassName();
    //报错，加上判断this是否为空或在成员变量前加this->
    p->showPersonAge();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

#### 4.4.4 `const`修饰成员函数

`const`就是不让修改。例如`const Person* const this;`这行代码，第一个`const`代表不可以修改this指向的对象的值，第二个const代表不可以修改this指针的指向。

**常函数**

-   成员函数加上`const`之后就称为常函数，这个`const`加在函数声明的后面，与上面例子的第一个`const`作用相同（本质是用来修饰this指针），用来防止修改成员变量（只读，包括静态变量）。
-   常函数不可以修改成员属性
-   成员属性声明时加上`mutable`关键字后，在常函数中依然可以修改

**示例：**

```cpp
public:
    //this指针的本质 是指针常量 指针的指向是不可修改的
    //this指针 const Person* const this;
    //在成员函数后的const修饰this指针
    void showPerson() const
    {
        this->m_B = 100;
        //this = NULL; //this指针是不可以修改指针的指向
    }
    int m_A;
    //加上mutable关键字,在常函数中也能修改
    mutable int m_B;
};
```

**常对象**

-   声明对象前加`const`称该对象为常对象
-   常对象只能调用常函数
-   常对象只能修改`mutable`修饰的成员变量

**示例：**

```cpp
void test02()
{
    //在对象前加const,变为常对象
    const Person p{};
    //p.m_A = 100; //不能修改普通成员变量
    p.m_B = 100;
    //常对象只能调用常函数
    p.showPerson();
    //常对象不能调用普通成员函数,因为我们不知道普通成员函数是否修改了属性
}
```

>   常函数和常对象之间相当于遵循了共同的一个约定：不能修改属性。 `mutable`关键字相当于开了个后门。



### 4.5 友元

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221108235411999.png" alt="image-20221108235411999" style="zoom:67%;" />

在C++中，有些私有属性 也想让类外特殊的一些函数或者类进行访问，这时候就需要用到「友元」的技术。友元的目的就是让一个函数或者类访问 另一个类中私有成员。友元的关键字`friend`。

**友元的三种实现**

1.   全局函数做友元
2.   类做友元
3.   成员函数做友元

#### 4.5.1 全局函数做友元

`friend void goodGay(Building &building);`不一定要写在`public:`下，只要写在类中就可以（包括`private:`）。

**示例：**

```cpp
/*  
 *  Description : 全局函数做友元
 *  Created by 旋风冲锋龙卷风 on 2022/11/08 23:58
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>
using namespace std;

//建筑类
class Building
{
    //goodGay全局函数是Building的好朋友,可以访问Building中私有成员
    friend void goodGay(Building &building);
public:
    Building(const string &mSitting, const string &mBedroom) : m_Sitting(mSitting), m_Bedroom(mBedroom)
    {}

    Building()
    {
        m_Bedroom = "卧室";
        m_Sitting = "客厅";
    }

public:
    //客厅
    string m_Sitting;
private:
    //卧室
    string m_Bedroom;
};

//全局函数
void goodGay(Building &building)
{
    cout << "正在访问公有成员变量 : " << building.m_Sitting << endl;
    cout << "正在访问公有私有变量 : " << building.m_Bedroom << endl;

}

```



#### 4.5.2 类做友元

`new`关键字返回的是指针。

这样使得一个类可以访问另一个类的私有作用域。` friend class GoodGay;`

```cpp
/*  
 *  Description : 类做友元
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 00:09
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
using namespace std;

class Building;

class GoodGay
{
public:
    GoodGay();
    //参观函数访问Building中的属性
    void visit();
    Building * building;
};

class Building
{
    //GoodGay类是本类的友元类,可以访问本类的私有成员(成员变量和成员函数)
    friend class GoodGay;
public:
    Building();
    string m_SittingRoom;
private:
    string m_BedRoom;
};

//类外写成员函数
Building::Building()
{
    m_BedRoom = "卧室";
    m_SittingRoom = "客厅";
}

GoodGay::GoodGay()
{
    //创建一个建筑物对象
    building = new Building;
}

void GoodGay::visit()
{
    cout << "访问building的 : " << building->m_SittingRoom << endl;
    cout << "访问building的 : " << building->m_BedRoom << endl;
}

void test01()
{
    GoodGay gg;
    gg.visit();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 4.5.3 成员函数做友元

```cpp
/*  
 *  Description : 
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 00:22
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;
class Building;
class GoodGay
{
public:
    GoodGay();
    //让visit函数可以访问Building中的私有成员
    void visit();
    Building * building;
};

class Building
{
    friend void GoodGay::visit();
public:
    Building()
    {
    m_SittingRoom = "客厅";
    m_BedRoom = "卧室";
    }

//客厅
string m_SittingRoom;
private:
//卧室
string m_BedRoom;
};

GoodGay::GoodGay()
{
    building = new Building;
}

void GoodGay::visit()
{
    cout << building->m_SittingRoom << endl;
    cout << building->m_BedRoom << endl;
}

void test01()
{
    GoodGay gg;
    gg.visit();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

需要注意的是：由于C++的编译器是 从上往下扫描的，所以上面行没有出现的类下面行不能使用，所以**函数需要在类内声明类外定义**。

### 4.6 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同数据类型。

#### 4.6.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算。

对于内置的数据类型，编译器知道如何进行运算。但是对于自定义的类不能直接用`+`运算符。但是我们可以通过**成员函数**或**全局函数**重载加法`+`运算符。

**成员函数重载+号运算符：**

```cpp
class Person
{
private:

public:
    int m_age;
    int m_A;
    Person(int mAge, int mA) : m_age(mAge), m_A(mA)
    {}

    Person()
    {}
    //成员函数重载+号
    Person operator+(Person &person)
    {
        Person tmp;
        tmp.m_A = this->m_A + person.m_A;
        tmp.m_age = this->m_age + person.m_age;
        return tmp;
    }
};


void test01()
{
    Person p1(10,10);
    Person p2(20, 10);

    Person p3 = p1 + p2;
    cout << p3.m_A << endl << p3.m_age << endl;
}
```



**全局函数重载+号运算符：**

```cpp
//全局函数重载+号
Person operator+(Person &p1, Person &p2)
{
    Person tmp;
    tmp.m_age = p1.m_age + p2.m_age;
    tmp.m_A = p1.m_A + p2.m_A;
}
```



本质调用：

```cpp
//成员函数的本质调用
Person p3 = p1.operator+(p2);
//全局函数的本质调用
Person p3 =operator+(p1,p2);
```



简化调用：

```cpp
Person p3 = p1.operator+(p2);
```



运算符重载也可以发生函数重载：

```cpp
    //运算符重载也可以发生函数重载
    Person operator+(int a)
    {
        Person tmp;
        tmp.m_age = this->m_age + a;
        tmp.m_A = this->m_A + a;
        return  tmp;
    }
```



>   总结：
>
>   1.   对于内置类型的表达式的运算符是不可能改变的
>   2.   不要滥用运算符重载，要使得运算符重载好理解

#### 4.6.2 左移运算符`<<`重载

作用：可以输出自定义类型。相当于重写Java类中的`print()`函数。



一般<<重载写为全局函数。

`cout`是`ostream`（标准输出流）对象，而且这个对象全局只有一个，所以要用引用传递，同时为了`<<`无限追加，需要返回`cout`。在函数体中的引用名可以更改，一般用`os`，同时为了输出类中的私有成员变量，可以将其作为Person类的友元函数。

```cpp
/*  
 *  Description : 左移运算符重载
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 20:45
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//左移运算符重载
class Person
{
public:
    //如果想输出私有成员变量,可以将全局函数添加为Person类的友元函数
    friend ostream &operator<<(ostream &os, const Person &person);

public:
    int m_b;
private:
    int m_a = 1;
}

ostream &operator<<(ostream &os, const Person &person)
{
    os << "m_a: " << person.m_a << " m_b: " << person.m_b;
    //链式编程
    return os;
}

void test01()
{
    Person p;
    p.m_b = 2;
    //本质调用
    &operator<<(cout, p);
    //时机调用
    cout << p << endl;
}
```



>   由于`>>`接收用户定义的类型为右实参，所以它和`<<`必须以非成员实现。
>
>   本质上重载的是流类型的`<<`和`>>`操作，但是不能改写流类型，所以必须设置为全局作用域。

#### 4.6.3 递增运算符重载

作用：通过重载递增运算符，实现自定义类的递增。

>   需要注意`++a`和`a++`（前置递增和后置递增）是不同的，这一点在重载时如何体现？

**前置++代码：**

```cpp
/*  
 *  Description : 递增运算符重载
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 21:08
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//自定义一个整型变量
class MyInteger
{
public:
    friend ostream& operator<<(ostream &os, MyInteger myInt);

public:
    MyInteger()
    {
        m_num = 0;
    }
    //重载前置++运算符,返回引用可以
    MyInteger& operator++()
    {
        this->m_num ++;
        //返回自身
        return *this;
    }

private:
    int m_num;
};

//重载左移运算符
ostream& operator<<(ostream &os, MyInteger myInt)
{
    os << myInt.m_num;
    return os;
}

void test01()
{
    MyInteger myInt;
    cout << ++myInt << endl;
}

```

>   为什么要返回`MyInteger&`？如果返回`MyInteger`会怎样？
>
>   首先，我们需要清楚，返回`MyInteger`代表返回是一个新的对象，而对于新的对象，我们需要一个左值去接收它才有效。
>
>   ```cpp
>       MyInteger& operator++()
>       {
>           this->m_num ++;
>           //返回自身
>           return *this;
>       }
>   void test01()
>   {
>       MyInteger myInt;
>       //输出2 和 1，与我们预期不符
>       cout << ++(++myInt) << endl;
>       cout << myInt << endl;
>   }
>   ```
>
>   我们需要的是对同一个对象进行操作。



**后置++代码：**

用一个`int`代表占位参数，让编译器区分前置递增和后置递增

```cpp
    //重载后置++运算符 ,int代表一个占位参数,可以用来区分前置和后置递增,后置递增返回的是值!
    MyInteger operator++(int)
    {
        //先记录当时结果
        MyInteger tmp = *this;
        //后递增
        m_num++;
        //最后将记录结果做返回
        return tmp;
    }
void test01()
{
    MyInteger myInt;
    cout << myInt++ << endl;
    cout << myInt << endl;
}
```

重载后置递增运算符需要注意：

1.   返回值而非引用，原因在于，首先tmp是局部变量，同时后置++需要原来的数据，而++之后的数据不需要输出（使用）
2.   相当于返回一个和之前相同的中间变量

>   但是这样写有一个问题：
>
>   对于内置类型的后置++而言，下面的代码是编译错误的：
>
>   ```cpp
>       int a = 0;
>       cout << (a++)++ <<endl;
>       cout << ++(a++) << endl;
>   ```
>
>   这两条cout语句都是错误的，但是如果重载后置++不能判断出这个是错误的。下面代码可以正常编译通过：
>
>   ```cpp
>       MyInteger myInt;
>       cout << --(--myInt) << endl;
>       cout << (myInt--)-- << endl;
>   ```
>

#### 4.6.4 赋值运算符重载

C++编译器至少给一个类添加4个函数：

1.   默认构造函数（无参，函数体为空）
2.   默认析构函数（无参，函数体为空）
3.   默认拷贝构造函数，对属性进行值拷贝（浅拷贝）
4.   赋值运算符`operator=`，对属性进行值拷贝

如果有类中属性指向堆区，做赋值操作时也会出现「深/浅拷贝」问题。

**问题代码：**

```cpp
#include <iostream>

using namespace std;

class Person
{
public:
    Person(int age)
    {
        //new返回指针
        m_age = new int(age);
    }
    ~Person()
    {
        if(NULL != m_age)
        {
            delete m_age;
            m_age = NULL;
        }
    }
    //写一个指针,真实数据存放在堆区
    int *m_age;
};

void test01()
{
    Person p1(18);

    Person p2(20);

    p2 = p1;
    cout << *p1.m_age << endl;
}

```

上述代码使用的是默认的值拷贝，两个指针指向同一片区域，所以当析构的时候，一个指针指向的区域先被释放掉，另一个指针指向的区域会异常（堆区内存重复释放）。

如果直接输出指针，结果（地址）相同

![image-20221109223002340](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221109223002340.png)

我们使用深拷贝来解决这个问题，我们不简单拷贝指针的值，而是在堆区重新开辟一块空间，这样析构的时候不会重复释放。

**重载=运算符代码：**

```cpp
/*  
 *  Description : 赋值运算符重载
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 21:53
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Person
{
public:
    Person(int age)
    {
        //new返回指针
        m_age = new int(age);
    }
    ~Person()
    {
        if(NULL != m_age)
        {
            delete m_age;
            m_age = NULL;
        }
    }

    //重载赋值运算符
    Person& operator=(Person &p)
    {
        //编译器提供的是浅拷贝
        //m_age = p.m_age;

        //应该先判断是否有属性在堆区,如果有,先释放干净,然后再深拷贝
        if(NULL != m_age)
        {
            delete m_age;
            m_age = NULL;
        }
        //深拷贝核心代码
        m_age = new int(*p.m_age);
        //也需要返回自身,这样可以连等号操作
        return *this;
    }

    //写一个指针,真实数据存放在堆区
    int *m_age;
};

void test01()
{
    Person p1(18);

    Person p2(20);

    Person p3(25);
    p3 = p2 = p1;
    cout << *p1.m_age << endl;
    cout << *p2.m_age << endl;
    cout << *p3.m_age << endl;
}
```



#### 4.6.5 关系运算符重载

**关系运算符：**`>`、`<`、`!=`和`==`

**作用：**重载关系运算符，可以让两个自定义类型对象进行比较操作

```cpp
/*  
 *  Description : 关系运算符重载
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 22:41
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Person
{
public:
    string m_name;

    Person(const string &mName, const int &mAge) : m_name(mName), m_age(mAge)
    {}

    // == 操作运算符重载
    bool operator==(const Person & p)
    {
        if(this->m_age == p.m_age && this->m_name == p.m_name)
        {
            return true;
        }
        return false;
    }
    // !=操作运算符重载
    bool operator!=(const Person &p)
    {
        return !this->operator==(p);
    }

    int m_age;
};

void test01()
{
    Person p1("Tom", 19);
    Person p2("Tom", 19);

    if(p1 == p2)
    {
        cout << "p1和p2相等" << endl;
    }else
    {
        cout << "p1和p2不等" << endl;
    }
    if(p1 != p2)
    {
        cout << "p1和p2不等" << endl;
    }else
    {
        cout << "p1和p2相等" << endl;
    }
}

```

#### 4.6.6 函数调用运算符`()`重载

-   函数调用运算符`()`也可以重载
-   由于重载后的使用方式非常像函数的调用，因此称为「仿函数」
-   仿函数没有固定写法，非常灵活
-   仿函数在STL中使用的非常多

**示例：**

```cpp
/*  
 *  Description : 函数调用运算符重载(仿函数)
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 22:59
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//打印输出类
class MyPrint
{
public:
    //重载的函数调用运算符
    void operator()(string text)
    {
        cout << text << endl;
    }
};

void test01()
{
    MyPrint myPrint;
    //输出helloworld,重载了()，对象使用()，使用起来非常类似于函数调用
    myPrint("hello world");
}

```

重载了()，对象使用()，使用起来非常类似于函数调用，因此被称为「仿函数」。

仿函数非常灵活，没有固定的写法：

```cpp
//加法类
class MyAdd
{
public:
    int operator()(int num1, int num2)
    {
        return num1 + num2;
    }
};
void test02()
{
    MyAdd myAdd;
    cout << myAdd(1,2) << endl;
}
```



**匿名函数对象**

也就是重载了运算符的类的匿名对象

`类名()`：匿名对象

匿名函数对象：

```cpp
 MyAdd()(100,100)
```

这一行结束后匿名对象就被释放。

>    在STL中会大量使用仿函数。



### 4.7 继承

**继承是面向对象三大特性之一**

继承可以减少重复代码，继承的核心思想是把共同的部分抽象成基类。

#### 4.7.1 继承的基本语法

**基本语法：**

```cpp
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};
```

继承方式默认为`private`。派生类也叫子类，基类也叫父类。子类的成员除了从基类继承过来的，还有自己增加的成员。**从基类继承过来的表现其共性，而新增的成员表现其个性。**

**示例：**

```cpp
/*  
 *  Description : 继承的基本语法
 *  Created by 旋风冲锋龙卷风 on 2022/11/09 23:19
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//公共页面
class BasePage
{
public:
    void header()
    {
        cout << "首页" << endl;
    }
    void footer()
    {
        cout << "帮助中心" << endl;
    }
    void left()
    {
        cout << "公共分类列表" << endl;
    }
};

//Java页面
class Java : public BasePage
{
public:
    void content()
    {
        cout << "Java学科视频" << endl;
    }
};

//Python页面
class Python : public BasePage
{
public:
    void content()
    {
        cout << "Python学科视频" << endl;
    }
};

//C++页面
class CPP : public BasePage
{
public:
    void content()
    {
        cout << "CPP学科视频" << endl;
    }
};

void test01()
{
    Java java;
    java.header();
    java.footer();
    java.left();
    java.content();
    Python py;
    py.header();
    py.footer();
    py.left();
    py.content();

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

#### 4.7.2 继承方式

**继承方式一共有三种：**

-   公共继承
-   保护继承
-   私有继承

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221109234543366.png" alt="image-20221109234543366" style="zoom:40%;" />

1.   基类的私有的东西永远无法访问
2.   对于`public`和`protected`权限，公有继承不改变他们的属性，保护继承把他们全都变为`protected`属性，私有继承把他们全都变成`private`属性。

**注意：不可访问和`private`是不同的**。

#### 4.7.3 继承中的对象模型

**问题：**从父类继承过来的成员，哪些属于子类对象中？

**示例：**

```cpp
/*  
 *  Description : 继承中的对象模型
 *  Created by 旋风冲锋龙卷风 on 2022/11/10 00:07
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base
{
public:
    int m_a;
protected:
    int m_b;
private:
    int m_c;
};

class Son : public Base
{
public:
    int m_d;
};

void test01()
{
    //结果是16，也就是4个int类型的size
    cout << "sizeof Son = " << sizeof(Son) << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

所以其实在父类中不管什么权限的非静态成员属性，都会被子类继承下去，只是父类的私有成员属性是被编译器隐藏了，只是访问不到，但是确实被继承下去了。

子类拥有但是不能访问。

可以通过clang的` clang -： -fdump-record-layouts -stdlib=libc++  XX.cpp`命令查看内存分布，但是输出很长，需要grep

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221110004100161.png" alt="image-20221110004100161" style="zoom:40%;" />

#### 4.7.4 继承中的构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

**问题：**父类和子类的构造和析构顺序是什么？

```cpp
/*  
 *  Description : 父类和子类的构造和析构顺序
 *  Created by 旋风冲锋龙卷风 on 2022/11/10 00:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base
{
public:
    Base()
    {
        cout << "Base的构造" << endl;
    }

    virtual ~Base()
    {
        cout << "Base 的析构" << endl;
    }
};

class Son : public Base
{
public:
    Son()
    {
        cout << "Son的构造" << endl;
    }

    virtual ~Son()
    {
        cout << "Son的析构" << endl;
    }
};

void test01()
{
    Son a;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

**结果：**

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221110004905006.png" alt="image-20221110004905006" style="zoom: 67%;" />

-   构造是先父后子
-   析构是先子后父

#### 4.7.5 继承同名成员处理方式

**问题：**当子类与父类中出现同名的成员，如何通过子类对象，访问到子类或者父类中同名的数据呢？

-   访问子类同名成员，直接访问即可
-   访问父类同名成员，需要加作用域

**示例：**

```cpp
/*  
 *  Description : 继承中同名成员处理
 *  Created by 旋风冲锋龙卷风 on 2022/11/11 11:53
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base
{
public:
    Base()
    {
        m_a = 100;
    }
    void func()
    {
        cout << "Base 下的 func 调用" << endl;
    }
    void func(int a)
    {
        cout << "Base 下的 func(int) 调用" << endl;
    }
    int m_a;
};

class Son : public Base
{
public:
    Son()
    {
        m_a = 200;
    }
    void func()
    {
        cout << "Son 下的 func 调用" << endl;
    }

    void func(int a)
    {
        cout << "Son 下的 func(int) 调用" << endl;
    }
    int m_a;
};

//同名成员属性处理
void test01()
{
    Son s;
    cout << s.m_a << endl;
    //如何访问 Base下的m_a?
    //在同名成员属性前加上作用域
    cout << s.Base::m_a << endl;
}

//同名成员函数处理
void test02()
{
    Son s;
    s.func(1);
    s.Base::func(1);
}

int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

**总结：**

1.   子类对象可以直接访问到子类中同名成员
2.   子类对象加作用域可以访问到父类同名成员
3.   当子类和父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中的同名函数

#### 4.7.6 继承同名静态成员处理方式

**问题：**继承中同名的静态成员在子类对象上如何进行访问？



静态成员与非静态成员出现同名，处理方式一直

-   访问子类同名成员，直接访问即可
-   访问父类同名成员，需要加作用域



**示例：**

```cpp
/*  
 *  Description : 继承中同名静态成员的处理: 也是分为同名的静态成员函数和同名的静态成员属性
 *  Created by 旋风冲锋龙卷风 on 2022/11/11 15:22
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base
{
public:
    static int m_A;
    static void func()
    {
        cout << "Base Static Fun " << endl;
    }
};

int Base::m_A = 100;

class Son : public Base
{
public:
    static int m_A;
    static void func()
    {
        cout << "Son Static Fun " << endl;
    }
};

int Son::m_A = 200;
//同名静态成员属性
void test01()
{
    Son s;
    //通过对象来访问数据
    cout << s.m_A << endl;
    cout << s.Base::m_A << endl;

    //通过类名访问
    cout << Son::m_A << endl;
    //第一个::代表通过类名方式访问，第二个::代表访问父类的成员属性
    cout << Son::Base::m_A << endl;
    //与上面结果一样
    cout << Base::m_A << endl;
}
//同名静态成员函数
void test02()
{
    Son::Base::func();
    //这时不能直接调用Son::func(int) 需要加上父类作用域
    Son::Base::func(19);
}


int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

子类出现了和父类同名静态成员函数，也会隐藏父类中所有同名成员函数，如果想访问父类中被隐藏的同名成员，需要加作用域。



#### 4.7.7 多继承语法

C++允许**一个类继承多个类**，也就是支持**多继承**。

语法`class 子类 : [继承方式] 父类  ,[继承方式] 父类 ...`

多继承会引发父类中有同名成员出现，需要加作用域区分



>   **在实际开发中，不建议使用多继承**，出现不同父类中有同名成员比较麻烦。



**示例：**

```
/*  
 *  Description : 多继承的语法
 *  Created by 旋风冲锋龙卷风 on 2022/11/11 15:46
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base1
{
public:
    int m_A;
    Base1()
    {
        m_A = 100;
    }
};

class Base2
{
public:
    int m_A;
    Base2()
    {
        m_A = 200;
    }
};

//子类继承Base1 和 Base2
class Son : public Base1, public Base2
{
public:
    Son()
    {
        m_C = 300;
        m_D = 400;
    }
    int m_C;
    int m_D;
};

void test01()
{
    Son s;
    //sizeof(Son)的结果是16字节
    cout << "sizeof Son = " << sizeof(s) << endl;

    //如果直接写s.m_A 会产生二义性,当不同的父类中出现同名成员,必须加作用域区分
    cout << s.Base1::m_A << endl;
    cout << s.Base2::m_A << endl;
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

#### 4.7.9 菱形继承

**菱形继承概念：**

-   两个派生类继承同一个基类
-   又有某个类同时继承两个派生类
-   这种继承被称为「菱形继承」，AKA「钻石继承」。

**案例：**

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221111160224797.png" alt="image-20221111160224797" style="zoom:40%;" />

**菱形继承引发的问题：**

1.   羊继承了动物的数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性
2.   羊驼继承自动物的数据继承了两份，其实这份数据只需要一份即可



![image-20221111162446262](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221111162446262.png)

**vbptr：虚基类指针**

全称为：virtual base pointer。vbptr会指向vbtable（虚基类表），表中记录的是偏移量。通过虚继承，会使得从不管Sheep或者Camel继承过来的都是一个指针，这个两个指针+偏移量会找到唯一的数据。



### 4.8 多态（Polymorphism）

#### 4.8.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分为两类：

-   静态多态：函数重载和运算符重载属于静态多态，复用函数名
-   动态多台：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：

-   静态多态的函数地址早绑定 - 编译阶段确定函数地址
-   动态多台的函数地址晚绑定 - 运行阶段确定函数地址



**案例：**

```cpp
/*  
 *  Description : 静态多态和动态多态
 *  Created by 旋风冲锋龙卷风 on 2022/11/11 16:35
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

//sizeof(Animal) = 8
class Animal
{
public:
    virtual void speak()
    {
        cout << "动物在说话"  << endl;
    }
};

class Cat : public Animal
{
public:
    void speak()
    {
        cout << "猫在叫" << endl;
    }
};

class Dog : public Animal
{
public:
    void speak()
    {
        cout << "狗在叫" << endl;
    }
};

//执行说话的函数
//地址早绑定 在编译阶段就确定了函数的地址
//如果想执行让cat说话,那么这个函数的地址就不能提前绑定,需要在运行阶段进行绑定,也就是地址晚绑定
//做法,在Animal的speak()函数前加 virtual关键字实现晚绑定
void doSpeak(Animal &animal)
{
    animal.speak();
}

void test01()
{
    Cat cat;
    //父类Animal 的引用 来接受子类对象 Animal &animal = cat;
    //也就是父类的指针指向子类对象
    doSpeak(cat);
    Dog dog;
    doSpeak(dog);
}


int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

**动态多态的满足条件：**

1.   有继承关系
2.   子类要重写**父类的虚函数**
     -   重写和重载是不同的，重写需要 函数返回值类型 函数名 参数列表 完全相同
     -   子类重写的时候，`virtual`可写可不写

**动态多态的使用：**

父类的指针或者引用指向子类的对象

**多态的底层原理：**

首先，在我的机器中（clang + M1 mac），一个指针的size为8。

上述案例的`Animal`类，尽管它没有成员属性，但是却有一个**虚函数**，而`sizeof(Animal)的大小为8（字节），正好是一个指针的大小，而这个指针便是vfptr。

vfptr：虚函数（表）指针，指向虚函数表，clang中似乎是vtable pointer

>   **注：不同环境下不同编译器，对于虚表会有不同的实现(内存布局)。**

-   v - virtual
-   f - function
-   ptr - pointer

vftable：虚函数表

-   表内部记录**虚函数的地址**
-   当子类重写了父类的虚函数，那么子类中的虚函数表内部会替换成子类的虚函数地址。
-   当父类的指针或者引用指向子类对象的时候，就发生了多态。

![image-20221112003242715](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221112003242715.png)



#### 4.8.2 多态案例1：计算器类

**案例描述：**分别用普通方法和多态的技术实现计算器类

**多态的优点：**

-   代码结构清晰
-   可读性强
-   利于前期和后期的维护和扩展

**示例：**

```cpp
/*  
 *  Description : 用多态写一个计算器类
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 00:41
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <string>

using namespace std;

//普通写法
//如果需要扩展新的功能,需要修改源码
//在真实的开发中,更为提倡开闭原则:对扩展进行开放,对修改进行关闭
class Calculator
{
public:

    int getResult(string oper)
    {
        if("+" == oper)
        {
            return m_num1 + m_num2;
        }
        else if("-" == oper)
        {
            return m_num1 - m_num2;
        }
        else if("*" == oper)
        {
            return m_num1 * m_num2;
        }
    }

    //两个操作数
    int m_num1;
    int m_num2;
};

//利用多态实现计算器
//先实现一个计算器基类(抽象类)
//多态的好处: 降低耦合 组织结构清晰 可读性强 扩展维护性高
class AbstractCalculator
{
public:

    virtual int getResult()
    {
        return 0;
    }

    int m_num1;
    int m_num2;
};

//加法计算器类
class AddCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_num1 + m_num2;
    }
};

//减法计算器类
class SubCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_num1 - m_num2;
    }
};

//乘法计算器类
class MulCalculator : public AbstractCalculator
{
public:
    int getResult()
    {
        return m_num1 * m_num2;
    }
};

void test01()
{
    Calculator c;
    c.m_num1 = 10;
    c.m_num2 = 10;

    cout << c.getResult("-") << endl;
}

void test02()
{
    //多态使用父类指针指向子类对象

    //加法运算
    AbstractCalculator * abc = new AddCalculator;
    abc->m_num1 = 10;
    abc->m_num2 = 10;

    cout << abc->getResult() << endl;
    //用完记得销毁,销毁只是释放堆区的数据,指针的指向没有改变
    delete abc;

    //减法
    abc = new SubCalculator;
    abc->m_num1 = 10;
    abc->m_num2 = 10;

    cout << abc->getResult() << endl;
}


int main()
{
    test02();
    return EXIT_SUCCESS;
}
```

>    使用多态是在写程序之前。在写之前想好是否使用多态。在C++开发中尽量使用多态。



#### 4.8.3 纯虚函数和抽象类

在多态中，父类中的虚函数其实很多没有必要有函数体。主要都是调用子类重写的内容。因此可以将虚函数改为「**纯虚函数**」。

**语法：**

在虚函数后写上`=0;`。

```cpp
virtual 返回值类型 函数名 (参数列表)  = 0;
```

当一个类中只要出现纯虚函数，这个类就称为「**抽象类**」，抽象类有如下特点：

-   无法实例化对象(栈上和堆区都不可以)
-   子类必须重写抽象类中的纯虚函数，否则也属于抽象类

>   写所谓虚函数、纯虚函数的目的就是为了实现多态，让子类重写这些虚函数，如果不重写父类中的纯虚函数，不能实例化。

**示例：**

```cpp
/*  
 *  Description : 纯虚函数和抽象类
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 01:39
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Base
{
public:
    //纯虚函数
    //只要出现一个纯虚函数就称为抽象类: 无法实例化对象
    virtual void func() = 0;

};

class Son : public Base
{
    void func()
    {
        cout << "Son func 调用" << endl;
    }
};

void test01()
{
    Base * base = new Son;
    base->func();
}
int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

#### 4.8.4 多态案例2：制作饮品

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221112014910634.png" alt="image-20221112014910634" style="zoom:40%;" />

#### 4.8.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。

**解决办法：**将父类中的析构函数改为「**虚析构**」或者「**纯虚析构**」。

虚析构和纯虚析构共性：

-   可以解决父类指针释放子类对象
-   都需要有具体的函数实现

虚析构和纯虚析构区别：

-   如果是纯虚析构，该类属于抽象类，无法实例化对象

-------



-   虚析构语法： `virtual ~类名(){}`
-   纯虚析构语法：`virtual ~类名()  = 0;   类名::~类名(){}`。也就是说纯虚析构也要实现。

父类指针在析构的时候，不会调用子类中析构函数，导致子类如果有堆区属性，会出现内存泄漏，**把父类的析构函数改成虚析构即可解决。**

而如果写成纯虚函数的写法，还需要在类外实现（注意纯虚函数并不需要实现），只有纯虚析构函数也属于抽象类。

```cpp
/*  
 *  Description : 虚析构和纯虚析构
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 02:08
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class Animal
{
public:
    Animal()
    {
        cout << "Animal的构造函数调用" << endl;
    }
    virtual ~Animal() = 0;
    virtual void speak() = 0;
};

Animal::~Animal()
{
    cout << "Animal析构函数的调用" << endl;
}

class Cat : public Animal
{
public:
    Cat(string name)
    {
        cout << "Cat的构造函数调用" << endl;
        m_Name = new string(name);
    }
    ~Cat()
    {
        if(m_Name != NULL)
        {
            cout << "Cat的析构调用" << endl;
            delete m_Name;
            m_Name = NULL;
        }
    }
    void speak() override
    {
        cout << *m_Name << "小猫在说话" << endl;
    }

    string *m_Name;
};

void test01()
{
    Animal * animal = new Cat("Tom");
    animal->speak();
    delete animal;

}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

1.   虚析构和纯虚析构解决的是一个问题：就是解决父类指针指向子类对象的问题，析构时不走子类的析构函数。
2.   如果子类中没有堆区数据，父类可以不写为虚析构或纯虚析构
3.   拥有纯虚析构函数的类也属于抽象类

#### 4.8.6 多态案例3：电脑组装

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221112141156088.png" alt="image-20221112141156088" style="zoom:40%;" />

```cpp
/*  
 *  Description : 电脑组装案例
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 14:12
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>

using namespace std;

class CPU
{
public:
    //抽象计算函数,写成纯虚函数
    virtual void calculate() = 0;
};

class DisplayCard
{
public:
    virtual void display() = 0;
};

class Memory
{
public:
    virtual void storage() = 0;
};

//电脑类
class PC
{
public:
    PC(CPU *cpu, DisplayCard *displayCard, Memory *memory) : cpu(cpu), displayCard(displayCard), memory(memory)
    {}
    //提供析构函数来释放电脑的零件
    ~PC()
    {
        if(cpu != NULL)
        {
            delete cpu;
            cpu = NULL;
        }
        if(displayCard != NULL)
        {
            delete displayCard;
            displayCard = NULL;
        }
        if(memory != NULL)
        {
            delete memory;
            memory = NULL;
        }
    }
    //提供一个工作的函数
    void work()
    {
        //调用各个零件的接口
        cpu->calculate();
        displayCard->display();
        memory->storage();
    }
private:
    CPU *cpu;
    DisplayCard *displayCard;
    Memory *memory;
};

//具体厂商
class IntelCPU : public CPU
{
public:
    void calculate() override
    {
        cout << "Intel的CPU开始工作" << endl;
    }
};

class NvidiaGPU : public DisplayCard
{
    void display() override
    {
        cout << "Nvidia的显卡开始工作" << endl;
    }
};

class IntelMemory : public Memory
{
public:
    void storage() override
    {
        cout << "Intel的内存条开始工作" << endl;
    }
};

class M1CPU : public CPU
{
public:
    void calculate() override
    {
        cout << "M1芯片开始工作" << endl;
    }
};

void test01()
{
    //第一台电脑
    CPU * intelCPU = new IntelCPU;
    DisplayCard * nvidiaGPU = new NvidiaGPU;
    Memory * intelMemory = new IntelMemory;

    //创建第一台电脑
    PC *pc1 = new PC(intelCPU, nvidiaGPU, intelMemory);
    pc1->work();
    delete pc1;

    PC *pc2 = new PC(new M1CPU, new NvidiaGPU, new IntelMemory);
    pc2->work();
    delete pc2;
}


int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

在这个案例中，核心的案例在于：

1.   零件抽象出来，全写纯虚函数，子类厂商实现
2.   PC类中用父类指针接受零件
3.   增加厂商时不用修改代码，只需要添加继承就可以了



## 5. 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放，通过**文件可以将数据持久化**，C++中对于文件操作需要包含头文件`<fstream>`。



**文件类型分为两种：**

1.   **文本文件**：文件以文本的**ASCII**形式存储在计算机中，本章主要讨论的就是文本文件
2.   **二进制文件**：文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂他们



**操作文件的三大类：**

1.   `ofstream`：写操作
2.   `ifstream`：读操作
3.   `fstream`：读写操作



>   读写文件的主体都应该是计算机的CPU，cpu写文件，相当于cpu向文件输出内容，也就是用out；cup读文件，相当于文件给CPU输入内容，也就是in。

### 5.1 文本文件

#### 5.1.1 写文件

**写文件步骤如下：**

1.   包含头文件  : `#include<fstream>`
2.   创建流对象：`ofstream ofs;`
3.   打开文件：`ofs.open("PATH",打开方式);`
4.   写数据：`ofs << "写入的数据" `
5.   关闭文件`ofs.close();`



**文件的打开方式：**



| **打开方式**  | **解释**                   |
| :------------ | -------------------------- |
| `ios::in`     | 为读文件而打开文件         |
| `ios::out`    | 为写文件而打开文件         |
| `ios::ate`    | 初始位置：文件尾           |
| `ios::app`    | 追加方式写文件             |
| `ios::trunc`  | 如果文件存在先删除，再创建 |
| `ios::binary` | 二进制方式                 |



**注意：**文件打开可以配合使用，利用`|`操作符

**例如：**用二进制方式写文件`ios::binary | ios::out`



```cpp
/*  
 *  Description : 文本文本 写文件
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 15:05
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <fstream>

using namespace std;

void test01()
{
    ofstream ofs;
    //在cmake-build-debug-clang-arm/test.txt
    ofs.open("./test.txt", ios::out);
    ofs << "你好" << endl;
    ofs.close();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



#### 5.1.2 读文件

读文件与写文件步类似，但是读取方式相对而言比较多



**读文件的步骤如下：**

1.   包含头文件`<fstream>`
2.   创建流对象 `ifstream ifs`
3.   打开文件并判断文件是否成功打开：`ifs.open("Path", 打开方式);`
4.   读取数据：共有四种方式
5.   关闭文件`ifs.close()`

**示例：**

```cpp
/*  
 *  Description : 读文件
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 15:51
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <fstream>
#include <string>
using namespace std;

void test01()
{
    ifstream ifs;
    ifs.open("./test.txt", ios::in);

    //判断是否打开成功
    if(!ifs.is_open())
    {
        cout << "文件打开失败" << endl;
        return;
    }
    //读数据,共有四种方法
    //方法1:

    
    char buf1[1024] = {0};
    while(ifs >> buf1)
    {
        cout << buf1 << endl;
    }
    

    //方法2:

    char buf2[1024] = {0};
    while(ifs.getline(buf2, sizeof(buf2)))
    {
        cout << buf2 << endl;
    }

    //方法3:
    string buf3;
    while(getline(ifs, buf3))
    {
        cout << buf3 << endl;
    }

    //方法4: 不推荐使用
    char c;
    //EOF : End Of File 文件尾
    while((c = ifs.get()) != EOF)
    {
        cout << c;
    }

    //关闭文件
    ifs.close();


}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```



### 5.2 二进制文件

以二进制方式对文件进行读写操作，打开方式要指定为`ios::binary`

#### 5.2.1 写文件

二进制方式写文件主要利用流对象调用成员函数`write()`

函数原型：`ostream& write(const char * buffer, int len)`，字符指针`buffer`指向内存中一段存储空间，`len`是读写的字节数。



**示例：**

```cpp
/*  
 *  Description : 写二进制文件
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 22:26
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <fstream>
using namespace std;

class Person
{
public:
    //对二进制文件读写最好用C语言的字符数组
    char m_name[64];
    int m_age;
};

void test01()
{
    //包含头文件
    //创建流对象,打开文件
    ofstream ofs("person.txt", ios::out | ios::binary);
    //ofs.open("person.txt", ios::out | ios::binary);

    //写文件
    Person p = {"张三", 18};
    ofs.write((const char *)&p, sizeof(Person));

    //关闭文件
    ofs.close();

    //
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

写入的`text.txt`打开之后有乱码，这是正常的，只要能读出正确数据即可。



#### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员`read`

函数原型：`istream & read(char * buffer, int len)`



**示例：**

```cpp
/*  
 *  Description : 读二进制文件
 *  Created by 旋风冲锋龙卷风 on 2022/11/12 22:34
 *  个人博客 : http://letsgofun.cn/
 */
//

#include <iostream>
#include <fstream>
using namespace std;

class Person
{
public:
    //对二进制文件读写最好用C语言的字符数组
    char m_name[64];
    int m_age;
};

//二进制文件的读
void test01()
{

    //1. 包含头文件

    //2.创建流对象
    ifstream ifs;

    //3.打开文件 判断文件是否打开成功
    ifs.open("person.txt", ios::in | ios::binary);
    if(!ifs.is_open())
    {
        cout << "文件打开失败" << endl;
        return;
    }
    //4. 读文件
    Person p;
    ifs.read((char *) &p, sizeof(Person));

    cout << p.m_age << endl << p.m_name << endl;
    //5.关闭文件
    ifs.close();
}

int main()
{
    test01();
    return EXIT_SUCCESS;
}
```

输出：

![image-20221112224036083](https://raw.github.com/Missyesterday/picgo/main/picgo/image-20221112224036083.png)