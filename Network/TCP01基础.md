# TCP协议基础

>   来源小林coding，重新组织了一下语言。

## TCP基本认识

### TCP头：

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230534096.png" style="zoom:50%;" />

-   源端口、目的端口（16位）：也就是0到65535，这个不多说了
-   序列号（Seq Num）：在建立连接时计算机生成的随机数作为其「初始值」，通过SYN包传给接收端主机，没发送一次数据，就「累加」一次「该数据字节数」的大小。**用来解决网络包乱序问题**。
-   确认应答号（Ack Num）：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答号之后可以认为这个序列号以前的数据都已经被正常接收。**用来解决丢包的问题**。
-   控制位：
    -   `ACK`：为1代表「确认应答」的字段变为有效，TCP规定除了最初建立连接时的`SYN`包之外，该位必须为1
    -   `RST`：为1代表TCP连接出现异常，需要强制断开连接
    -   `SYN`：为1表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定
    -   `FIN`：为1代表今后不再有数据发送，希望断开连接。



>   序列号用来解决网络包乱序的问题，确认应答号用来解决丢包的问题，每发送一次数据，序列号累加的是「数据的字节数」，而不是「`+1`」。

### TCP的概念

IP层不可靠，上层的TCP协议来负责。

TCP是：

-   面向连接的：一对一的连接
-   可靠的：TCP保证数据报文一定到达接收端
-   基于字节流：用户消息通过TCP协议传输时，消息可能会被操作系统分组成多个TCP报文，所以需要接受方程序知道「消息的边界」。

TCP：需要保证「接收端」接收的网络包是「无损坏、无间隔、非冗余、按序」的。

TCP 连接，需要客户端和服务端达成下面三个信息的共识：

-   Socket：由 IP 地址和端口号组成
-   序列号：用来解决乱序问题
-   窗口大小：用来做流量控制

### 确定一个TCP连接

TCP四元组：

-   源地址（32 位，在 IP 头中）
-   源端口（16 位，在 TCP 头中）
-   目的地址
-   目的端口

客户端的端口是可变的，理论上来说，TCP的最大连接数和服务端无关，等于「客户端的 IP 数 × 客户端的端口数」大约是`2 的 48 次方`。

但是，事实上，服务器最大并发TCP连接数受到限制：

-   文件描述符，每一个TCP连接都有一个文件描述符（都是一个文件），Linux对于可打开的文件描述符有三个方面的限制：
    -   系统级：当前系统可以打开的最大数量
    -   用户级：指定用户可以打开的最大数量
    -   进程级：单个进程可以打开的最大数量
-   内存限制：每个TCP连接都要占用一定内存，内存是有物理限制的。



### TCP和UDP的区别

UDP头：

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230439961.png" style="zoom:50%;" />

包长度，和校验和，是常见的包头。

目标端口和源端口：主要告诉 UDP 协议应该把报文发送给哪个进程。

>   socket、端口、进程
>
>   -   socket：对 TCP/IP协议进行了抽象和实现，socket 中存储了特定的四元组，UDP 和 TCP 也有四元组，就可以找到对应的 socket。
>   -   进程与端口，其实并没有什么直接或必然的关系，关键还是socket！

```cpp
1> bind 到特定 ip 和 port 的socket 对应 [(src ip, src port) <=> (*, *)] ；
2> connect 到特定目的ip+port 的 socket 对应 [(src ip, src port) <=> (dst ip,  dst port)]；
3> accept 返回了的 socket 对应  [(src ip, src port) <=> (dst ip,  dst port)]；
```



可以看到`bind()`的`socket`没有目的 ip 和目的端口，是不是可以这样认为，如果一个四元组没有找到对应的 socket，那么就 accept 返回一个新的 socket。理论上来说，可以通过`sendmsg()`将socket描述符传递给其他进程，但是没有这么用过。

**TCP和UDP的区别：**

1.   连接
     -   TCP是面向连接的传输层协议，传输数据前要建立连接。
     -   UDP不需要连接，即刻传输数据
2.   服务对象
     -   TCP是一对一的两点服务，一条连接只有两个端点
     -   UDP支持一对一、一对多、多对多的交互通信
3.   可靠性
     -   TCP是可靠交付数据的，数据 「无差错、不丢失、不重复、按序到达」。
     -   UDP则是尽最大努力交付。
4.   拥塞控制、流量控制
     -   TCP有拥塞控制和流量控制，保证数据传输的安全性
     -   UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率
5.   首部开销
     -   TCP首部的长度比较长，有一定开销
     -   UDP8个字节固定不变
6.   传输方式
     -   TCP是流式传输，没有边界，保证顺序和可靠
     -   UDP则是一个包一个包的发送，是有边界的，但可能会丢包和乱序
7.   分片不同
     -   TCP的数据如果大于MSS（max s size）的大小，则会在传输层进行分片，目标主机也会在传输层进行组装，如果丢失，只需要重新发送丢失的这个分片
     -   UDP的数据大小如果大于MTU（max transport unit）的大小，则会在IP层（网络层）进行分片，目标主机收到之后，在IP层组装数据



**TCP和UDP的应用场景：**

TCP：

-   FTP文件传输
-   HTTP/HTTPS

UDP：主要用于处理简单的数据：

-   DNS（包总量较少）
-   视频、音频
-   广播



**TCP和UDP可以使用同一个端口吗**

答案是可以。IP包有一个「协议号」字段，可以根据这个信息确定发送给UDP模块还是TCP模块。

## TCP连接建立

### 三次握手

第三次握手可以携带数据，前两次握手不能携带数据。客户端和服务器都要初始化自己的序列号，同时确认应答号+1，因为没有数据。

### why三次握手？



-   确保双方都有接收和发送的能力，**同时防止发送方伪造IP地址**
-   阻止重复历史连接的初始化（主要原因）



**连接：**

-   Socket（源 ip、源端口、目的 ip、目的端口）
-   序列号
-   窗口大小



简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**

>   考虑一个场景：
>
>   客户端先发送了`SYN`报文，然后客户端宕机了，同时这个`SYN`报文被网络阻塞，服务器没有收到。
>
>   接着客户端重启后，又给服务器发送`SYN`包，注意这个SYN的序列号是会变化的。注意不是重传，重传的 syn 的序列号是一样的。

服务端收到后，会发送SYN+ACK回去，如果回复的是旧的`ACK`包，客户端会发送`RST`包，然后重新发送新的SYN包。

**最主要原因就是防止「历史连接」初始化了连接**。服务器收到第一个SYN连接的时候，不知道自己收到的是历史连接，直接发送数据。

两次握手的情况下，服务器没有「中间状态」给客户端来阻止历史连接，导致服务端简历一个历史链接，造成资源浪费。如果没有这个中间状态，服务器收到第一次握手，然后自己发送第二次握手，就直接建立连接了，会浪费服务器的资源。如果有三次握手，服务器在「三次握手」前不会发送数据，而是等待客户端发送第三次握手，客户端如果发现服务器应答的是「前一个废弃的 SYN」，则会发送`rst`中止连接。

**还有个原因是：同步双方初始序列号。**序列号可以：

-   接收方可以去除重复的数据
-   接收方可以根据数据包的序号按序接收
-   可以表示发送出去的数据包中，哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）
-   如果只有两次握手，被动发起连接方，不知道自己的序列号被对方接收到了

**第三个原因：避免资源浪费**

-   如果是两次握手，每次客户端发送 SYN 服务器都会建立连接
-   因为服务器不清楚重复的连接中，哪个连接收到了自己的 ACK 报文。
-   当然这一点也可以通过两次握手根据上下文信息丢弃 syn 报文解决。



### 为什么初始序列号需要随机生成？

如果固定初始化序列号：

-   会导致历史报文被下一个相同的四元组的连接接收
-   为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收**历史报文被下一个相同的四元组连接接收**

上一次的报文可能 seq 序列号在下一相同链接的服务器的接收窗口内。那这个历史包被接受了，就会造成数据错乱。如果每次都随机生成序列号，有很大可能避免这种情况。

### MTU和MSS

-   MTU：`Max transmission unit`一个网络包的最大长度（网络层IP），以太网中一般为`1500`字节。以太网可以看成是一种实现局域网通信的技术标准。最大传输单元
-   MSS：`Max Segment Size`除去TCP和IP的头部之后，一个网络包所能容纳的TCP数据的最大长度。最大分节大小

### 在 网络层（IP 层）和传输层（TCP 层）分片的区别。

IP 层没有超时重传机制。假设「TCP头 + TCP 数据」大于 MTU，则会在 IP 层分片。**注意在 IP 层分片，是直接把数据拆开，不会补充 TCP 头。**这样如果某一个 IP 分片丢失后，IP 层无法组装一个「TCP 头+TCP 数据」，导致需要重发「整个 TCP 报文（头+数据）」。所以在 IP 层分片你没有效率。

MSS 则是在 TCP 协议在确认连接的时候协商的，当 TCP 层发现数据超过 MSS，就会分片，在 TCP 层分片会带上 TCP 头。MSS 一般是 1460，也有可能会更小（不可能更大）。这样重传是以 MSS 为单位。

### 三次握手丢失的情况

1.   第一次握手丢失

     客户端不断重发SYN报文（SYN 报文的序列号不会变），达到最大重传次数，再等待一段时间，没有收到服务器的`SYN+ACK`报文，那么客户端断开连接。重发一般是五次，第一次 1 秒，第二次 2 秒，第三次 4 秒。总共大约 1 分钟。如果 1 分钟都没有收到服务端的「SYN+ACK」报文，就会从 SYN_SEND 变为 CLOSE。

2.   第二次握手丢失

     客户端和服务器端都会重传。客户端重传如上。服务端也是按照「最大重传次数」从 SYN_RCVD 变为 CLOSE 状态。

3.   第三次握手丢失

     客户端已经建立连接了（ESTABLISH），服务器端超时重传，客户端不会重传，**因为`ACK报文`不会有重传**。当时每次服务端发送`SYN+ACK`，客户端还是会发送一个`ACK`，但是这个ACK会丢失。

>   ACK报文不会重传，但是 ACK+SYN 会重传。

### SYN攻击

如果黑客伪造IP，在段时间内发送许多SYN包，服务端每接收到一个SYN，就会进入`SYN_RCVD`状态，并发送`SYN+ACK`包，但是不会收到第三个握手包。久而久之就会占满服务端的「半连接队列」，使得服务端不能为正常用户服务。

Linux内核会维护两个队列：

-   半连接队列，也叫 syn 队列，收到 ACK 报文就会将连接对象加入到这个队列
-   全连接队列，也叫 accept 队列，服务端收到第三次握手的 ACK 报文会把链接对象加入到这个队列

调用`accept()`接口，会从全连接队列中取出连接对象。但是这两个队列都有长度限制。

我们可以：

-   增大TCP半连接队列
-   减少`SYN+ACK`重传的次数
-   开启`net.ipv4.tcp_syncookies`，开启这个功能后，可以绕开 SYN 队列建立连接（CentOS7.4 默认打开）。当 SYN 队列满了之后，后续服务端收到 SYN 包，不会丢弃，而是计算出一个`cookie`值，把这个值放到「序列号」中发送第二个握手包给客户端。当服务端收到客户端的应答报文时，会检查这个 ACK 包的合法性，如果合法，就会直接加入到 Accept 队列。



## TCP连接断开

### TCP四次挥手

首先，TCP连接的双方都可以主动断开连接，断开连接后，主机中的「资源」将会被释放：

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230614791.png" style="zoom:50%;" />

这里我们假设客户端主动关闭连接：

-   客户端发送一个`FIN`报文，进入`FIN_WAIT_1`状态
-   服务端收到客户端的`FIN`报文后，就会立即向客户端发送`ACK`应答报文，服务端进入`CLOSE_WAIT`状态。
-   客户端收到服务端的`ACK`应答报文后，进入`FIN_WAIT_2`状态
-   **等到服务端处理完数据后**，也向客户端发送`FIN`报文，之后服务端进入`LAST_ACK`状态。
-   客户端收到服务端的`FIN`报文后，回应一个`ACK`应答报文，之后进入`TIME_WAIT`状态。
-   服务端收到`ACK`应答报文后，就进入了`CLOSE`状态，服务端已经完成连接的关闭。
-   客户端在经过`2MSL`时间后，进入`CLOSE`状态。

 

>   主动关闭连接的，才有`TIME_WAIT`状态。



### 为什么要四次挥手

-   客户端向服务端发送`FIN`，仅仅表示客户端不再发送数据了，但是仍然有可能接收数据。
-   服务端收到客户端的`FIN`报文时，先回一个`ACK`应答报文（这一步是不可缺少的），但是服务端可能还有数据需要处理和发送，等到服务端不再发送数据的时候，才发送`FIN`报文给客户端来表示同意现在关闭连接。
-   所以服务端的`ACK`和`FIN`需要分开发送，因此是四次挥手。



### 四次挥手丢失

-   第一次挥手丢失：

    客户端进入`FIN_WAIT_1`状态，如果第一次挥手丢失，则会触发超时重传机制。第一次超时重传的等待时间是RTO，之后每次超时重传都是上一次的两倍，当重传的次数超过`tcp_orphan_retries`时，就会进入`close`状态。**此时服务端是`ESTABLISH`状态。**

-   第二次挥手丢失：

    客户端同上，多次超时重传后进入`CLOSE`状态。服务端发送`ACK`包，进入`CLOSE_WAIT`状态。**`ACK`报文是不会重传的**。所以情况就是，客户端多次重传，服务端收到客户端的`FIN`后再发送`ACK`。服务端一直处于`CLOSE_WAIT`状态。

-   第三次挥手丢失：

    也就是服务端发送的`ACK`，客户端接收到了，但是服务端发送的`FIN`，客户端没有接收到。

    当服务端收到客户端的`FIN`报文，内核会自动回复`ACK`，同时连接处于`CLOSE_WAIT`状态，这个状态需要进程调用`close()`函数关闭连接。

    此时，**内核没有权限替代进程关闭连接，必须由进程主动调用`close()`函数来出发服务端发送`FIN`报文**。

    服务端处于`CLOSE_WAIT`状态时，调用了`close()`函数，内核就会发出`FIN`报文，同时服务端进入`LAST_ACK`状态，等待客户端返回`ACK`来确认连接关闭。

    由于这个`FIN`丢失，服务端会重发`FIN`，重发次数依然是`tcp_orphan_retrie`参数控制，到达规定次数后服务端进入`CLOSE`状态。客户端则一直处于`FIN_WAIT_2`状态（由`close()`或`shutdown()`决定这个状态的停留时间），这个时间是有时间限制的，如果超过了限制，客户端会进入`close`状态。

-    第四次挥手丢失：

     也就是客户端发送的`ACK`丢失。服务端没有收到`ACK`，则会重发`FIN`，次数由参数决定。

     客户端则不会重发`ACK`，只有每次收到服务端的`FIN`，会回复一个`ACK`（丢失）。每次`FIN`时，都会`TIME_WAIT`的等待时间，直到服务端发送最后一个`FIN`包，客户端等待2MSL，进入`CLOSE`。

​    

>   close_wait代表等待服务器调用`close()`来终端连接。

### close关闭连接和shutdown关闭连接

close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2.drawio.png" style="zoom:50%;" />

但是如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/tcp/fin_wait_2死等.drawio.png" style="zoom:50%;" />



### 为什么`TIME_WAIT`等待的时间是2MSL

MSL（Maximum Segment Lifetime），报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间，报文将会被丢弃。因为TCP报文基于IP协议，IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个处理它的路由器，此值就-1，当TTL为0的时候，数据报将被丢弃，同时发送ICMP报文通知源主机。

MSL单位是时间，MSL要大于等于TTL消耗为0的时间，以确保报文已被自然消亡。

TTL的值一般是64，Linux下MSL一般是30秒，意味着Linux认为数据报经过64个路由器的时间不会超过30秒，如果超过，则认为报文已经消失在网络中了。

TIME_WAIT等待时间是2MSL，比较合理的解释是：**网络中可能存在来自发送方的数据包，当这些发送方的数据包被接受方处理后又会想对方发送响应。一来一回需要两倍的时间。**

其实就是说，如果客户端最后发送的那个`ACK`如果服务端没有收到，那么服务端就会触发超时重传`FIN`，此时客户端处于`TIME_WAIT`状态，收到服务端重传的`FIN`，还是可以发送一个`ACK`，也就是说这个`TIME_WAIT`状态允许ACK至少丢失一次。

而更长的MSL，几率太小了。



### 为什么需要TIME_WAIT状态

主动发起关闭连接的一方，才会有TIME_WAIT状态，主要有两个原因：

-   防止历史连接的数据，被后面相同四元组的连接错误接收
-   保证「被动关闭连接」的一方，能被正确的关闭

**原因1:防止历史连接中的数据，被后面相同四元组的连接错误接收：**

-   序列号（seq）：是TCP的一个头部字段，保证消息的顺序性和可靠性
-   初始序列号（isn）：在TCP连接建立的时候，客户端和服务端都会生成一个初始序列号，它是基于时钟生成的一个随机数。32位。

序列号和初始序列号并不是无限递增的，可能会回绕成初始值。



<u>假设TIME_WAIT没有等待时间，或者时间过短，被延迟的数据包抵达后会发生什么呢？</u>



<img src="https://cdn.xiaolincoding.com//mysql/other/6385cc99500b01ba2ef288c27523c1e7-20230309230608128.png" style="zoom:50%;" />

如上图：

-   服务端在关闭连接之前发送的`SEQ=301`的报文，被网络延迟了，同时客户端和服务端经过四次挥手，断开连接，此时客户端的TIME_WAIT时间过短（或没有）
-   接着，服务端以**相同四元组**重新建立了新的连接，而前面被延迟的`SEQ=301`此时抵达了客户端，**而且这个数据报的序列号刚好在客户端接收窗口内**，因此客户端会正常接收这个数据报文，而这个数据报文是上一个连接的，这样就导致了数据错乱。

所以，TCP设计了TIME_WAIT状态，持续`2MSL`时长，这个时间**足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新连接产生的**。



**原因2: 保证「被动关闭连接」的一方，能被正确的关闭：**

先说结论：TIME_WAIT的另一个作用，是「主动关闭连接」的一方等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助「被动关闭的一方」正常关闭。



**先看没有TIME_WAIT或TIME_WAIT过短的情况：**

<img src="https://cdn.xiaolincoding.com//mysql/other/3a81c23ce57c27cf63fc2b77e34de0ab-20230309230604522.png" style="zoom:50%;" />

-   如果客户端最后发送的一个ACK丢失了，那么服务端就会重发`FIN`报文，此时客户端是`CLOSE`状态，收到服务端的FIN报文后，会发送一个RST报文，服务端收到这个RST并将其解释为一个错误，这个终止方式对于一个可靠的协议而言并不优雅。

为了防止这种情况，**客户端就必须等待足够长的时间，确保服务端能收到ACK**。如果服务端没有收到ACK，那么就会触发TCP重传机制，这样以来一会刚好2MSL时间：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/网络/TIME-WAIT连接正常关闭.drawio.png" style="zoom:50%;" />

同时客户端收到FIN时，会重制TIME_WAIT计时器。



### TIME_WAIT过多的危害

-   占用系统资源，比如文件描述符、内存资源、CPU资源，线程资源等
-   占用端口资源，一般可以开启的端口为`32768~61000`

客户端和服务端TIME_WAIT过多，造成的影响是不同的：

**客户端（主动发起关闭的一方）的TIME_WAIT状态过多：**

-   占满了所有的端口资源，那么就无法对「目的IP和目的PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的，因为内核在定位一个连接时，是通过一个四元组信息来定位的。

**服务端（主动发起关闭的一方）的TIME_WAIT状态过多：**

-   并不会导致端口资源受限，但是TCP连接过多，会占用过多系统资源。



### 如何优化TIME_WAIT

这些选项都在` /etc/sysctl.conf `中

**方法1: 打开net.ipv4.tcp_tw_reuse和tcp_timestamps选项：**

-   打开后，就可以**复用处于TIME_WAIT的socket为新连接所用**。
-   tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。



**方法2：net.ipv4_max_tw_buckers**

这个值默认为18000，当系统中处于TIME_WAIT的连接一旦超过这个值时，系统就会将后面的TIME_WAIT连接状态重制，这个方法最暴力。



**方法3: 程序中使用SO_LINGER**

可以使用`setsockopt()`函数来修改。

```cpp
struct linger so_linger;
so_linger.l_onoff = 1;
so_linger.l_linger = 0;
setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));
```

如果`l_onoff`为非0，且`l_linger`为0，那么调用`close()`函数后，会立刻发送一个RST标志给对方，跳过TCP四次挥手，直接关闭，也就没有了TIME_WAIT。

：**TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它**。服务端可以不主动关闭连接，而是让客户端去断开，让客户端来承受`TIME_WAIT`。



### 服务端出现大量TIME_WAIT的原因

服务端出现大量TIME_WAIT说明服务端主动断开了很多TCP连接。以Web服务器威力，服务端主动断开的连接的场景有：

-   HTTP没有使用长连接
-   HTTP长连接超时
-   HTTP长连接的请求数量达到上限

**HTTP没有使用长连接：**

在HTTP/1.0中是默认关闭的，如果浏览器需要开启Keep-Alive，必须在请求头添加：

```
Connection: Keep-Alive
```

这样，TCP连接

**HTTP使用长连接时**

### 服务端出现大量CLOSE_WAIT状态

**说明服务端的程序没有调用`close()`函数关闭连接。**

一个普通TCP服务端的流程：

1.	 创建服务端socket，bind绑定端口，listen监听端口
2.	 将服务端socket（监听socket）注册到epoll
3.	 `epoll_wait()`等待连接，连接到来时，调用`accept()`获取已经连接的socket
4.	 将连接socket注册到epoll
5.	 epoll_wait等待
6.	 对方关闭连接，服务端调用`close()`

服务端没有调用`close()`的原因有：

1.   第2步没有做，也就是没有将监听socket注册到epoll，这样有新连接到来时，服务端感知不到，也没法对连接`socket`调用`close()`函数。但是这种错误有点不太可能。
2.   第3步没有做，也就是说没有调用`accept()`函数来获取连接socket，当有大量客户端主动断开连接，而服务端没机会对这些socket调用`close()`函数，从而导致服务端出现大量`CLOSE_WAIT`状态。一般这种情况时代码卡在某一个逻辑或者提前抛出异常。
3.   第四步没有做，
4.   第六部没有做

当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close。 



## Socket编程

### accept发生在三次握手的哪一步

-   客户端收到ACK后，程序从`connect()`阻塞返回
-   服务端收到ACK后，程序从`accept()`阻塞调用返回

客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。

如下图：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/网络/socket三次握手.drawio.png" style="zoom:50%;" />



### 客户端调用`close()`，连接断开的流程

<img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230538308.png" style="zoom:50%;" />

-   客户端调用`close()`，表示客户端没有数据要发送了，此时向服务端发送`FIN`报文，进入`FIN_WAIT_1`状态。
-   服务端收到了FIN报文，TCP协议栈会为FIN包插入一个文件结束符`EOF`到接收缓冲区中，应用程序可以通过调用`read()`来感知这个FIN包，这个`EOF`会被**放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为EOF表示在该连接上再无任何额外数据到达，此时，服务端进入`CLOSE_WAIT`状态。
-   接着当处理完数据之后，读到`EOF`，于是也调用`close()`关闭这个socket，这会使得服务端也发送一个`FIN`包，并进入`LAST_ACK`状态



### 没有accept，能建立TCP连接吗？

答案是**可以**。

accept系统调用并不参与TCP三次握手的过程，它只是负责从全连接队列中取出一个已经建立连接socket。



### 没有listen，能建立TCP连接吗？

可以。

客户端是可以自己连自己的形成连接（**TCP自连接**），也可以两个客户端同时向对方发出请求建立连接（**TCP同时打开**），这两个情况都有个共同点，就是**没有服务端参与，也就是没有 listen，就能 TCP 建立连接。**





>   接收窗口：
