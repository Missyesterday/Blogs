# 重新思考C++的多态

《C++ Primer》中OOP的核心思想被定义为：**数据抽象、继承和动态绑定**，而非我大脑中的封装、继承、多态。

同时对于动态绑定，又有：

>   《C++ Primer》第五版15.2 ：
>
>   ​	「在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。」



## 1. 继承

几点总结：

-   继承之后的成员访问权限只会小于等于基类的访问权限
-   派生不能访问基类的private作用域，但是编译器其实会全部继承过来，只是这部分对派生类不可见
-   public继承不会改变访问权限，protect继承把两个权限改为private，private继承则把两个权限改为private
-   在除了继承的其他情况，protect和private一样 



## 2. 动态绑定

当使用存在继承关系的类型时，必须将一个变量或者其他表达式的「静态类型」（static type）和该表达式**表示对象的**「动态类型」（dynamic type）区分。静态类型是声明时的类型，在编译期间是已知的。动态类型是变量或表达式表示的在内存中的对象的类型，直到运行时才可知。

如果不是引用或指针，则动态类型和静态类型永远一致。

只有引用（指针）+ 虚函数的组合才会发生动态绑定，这点非常重要。



动态绑定的两个关键字：

1.   引用或指针
2.   虚函数

C++11新增`override`关键字来检查是否正确重写。

在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据所指对象的实际类型来调用相应的函数。

虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。

虚表指针：在含有虚函数的类实例化对象的时候，对象地址的前四个字节存储的指向虚表的指针。

![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022551.png)

![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220022619.png)

当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面

-   虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
-   虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

