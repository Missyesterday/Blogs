# 03运行时数据区

## 1. 概述

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220502192907392.png" alt="image-20220502192907392" style="zoom: 25%;" />

内存是硬盘和CPU的中间仓库和桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效运行。**不同的JVM对于内存的划分方式和管理机制存在着部分差距。**我们以经典的HotSpot虚拟机来探讨经典的JVM内存布局。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220502193704143.png" alt="image-20220502193704143" style="zoom: 25%;" />

Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

灰色区域是单独线程私有的，红色是多个线程之间共享的：

1.   每个线程：独立包括程序计数器、栈、本地栈
2.   线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220502201736567.png" alt="image-20220502201736567" style="zoom: 33%;" />

也就说，红色区域只有一份，灰色区域有几个线程就有几份。

## 2. 线程

### 简介

-   线程是一个程序里的运行单元。Java允许一个应用有多个线程并行执行。

-   在HotSpot JVM里，每个线程都与操作系统的本地线程直接映射。
    -   当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程终止之后，本地线程也会回收。
-   操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的`run()`方法。

### JVM系统线程

-   如果使用jconsole或者任何一个调试工具，能看到后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程。
-   后台系统线程在HotSpot JVM里主要是以下几个：
    -   虚拟机线程：这种线程的草组需要JVM到达安全点才会出现
    -   周期任务线程：这种线程是时间周期事件的体现（例如中断），他们一般用于周期性操作的调度执行
    -   GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
    -   编译线程：这种线程在运行时会将字节码编译成到本地代码
    -   信号调度线程：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理

## 3. 程序计数器（PC寄存器）

### PC Register介绍

JVM中的PC寄存器（Program Counter Register），名称起源于CPU的寄存器。

但是这里，并非是指物理寄存器，JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，也成为程序钩子（类似于黄金矿工的钩子，用于找某个东西）、PC计数器、指令计数器等。

作用：PC寄存器来存储指向下一条指令的地址，也就是即将执行的指令代码。由执行引擎读取下一条指令。

-   它是一块很小的内存空间，几乎可以忽略不计。也是运行最快的存储区域。
-   在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
-   任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。PC寄存器会存储当前线程正在执行的Java方法的JVM地址；或者，如果是在执行native方法，则是未指定值（undefined）
-   它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
-   字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
-   它是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域

### 举例说明

对于下面代码：

```java
package com.hyf.PCReg;
public class PCRegisterTest {
    public static void main(String[] args) {
        int i = 10;
        int j = 20;
        int k = i + j;

        String s = "abc";
        System.out.println(i);
        System.out.println(k);
    }
}
```

`javap -v`反编译之后的字节码文件：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220502210655163.png" alt="image-20220502210655163" style="zoom:40%;" />

### 两个常见问题

1.   使用PC寄存器存储字节码指令地址有什么用呢？
2.   为什么使用PC寄存器记录当前线程的执行地址呢？

这两个问题是一个问题。

>   因为CPU在不停切换线程，这时候切换回来之后，就得知道接着从哪开始继续执行。
>
>   JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令

3.   PC寄存器为什么会被设定为线程私有呢？

>   在所谓的多线程情况下某个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地切换任务。为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的方法就是为每一个线程都准确分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会互相干扰。

并行VS串行

并发：多线程宏观上是并行，微观上是并发交替执行。

## 4. 虚拟机栈

### 虚拟机栈概述

#### 为什么用栈

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台的CPU架构不同，所以不能设计为基于寄存器的。

优点：

1.   跨平台
2.   指令集小
3.   编译器容易实现

缺点：

1.   性能下降
2.   实现同样的功能需要更多的指令

栈是运行时的单位，而堆是存储的单位。堆空间在内存中是一块比较大的区域。

#### Java虚拟机栈是什么

Java虚拟机栈，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java调用。

它是线程私有的。

-   **生命周期**

    生命周期与线程一致

-   **作用**

    主管Java程序的运行，它保存方法的局部变量（8种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。

>   **局部变量**是相对于**成员变量**而言的
>
>   **基本数据类型变量**是相对于**引用类型变量（类、数组、接口）**而言的

#### 栈的优点

-   栈是一种快速有效的分配存储的方式，访问速度仅次于程序计数器
-   JVM直接对栈的操作只有两个
    -   每个方法执行，伴随着进栈（入栈、压栈）
    -   执行结束后的出栈工作
-   对于栈来说不存在垃圾回收问题

#### 开发中常见的异常？（深层次一点的）

栈中可能出现的异常：

-   Java虚拟机规范允许**Java栈的大小是动态或者固定不变的。**
    -   如果采用固定大小的虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机将抛出一个`StackOverflowError`异常
    -   如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将会抛出一个`OutOfMemoryError`异常。

对于第一种异常：

```java
    public static void main(String[] args) {
        main(args);

    }
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220505200309553.png" alt="image-20220505200309553" style="zoom:40%;" />

死循环或者没有退出条件的递归，会导致这个异常。

#### 设置栈内存的大小

我们可以使用参数`-Xss [option]`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220505202411936.png" alt="image-20220505202411936" style="zoom: 25%;" />

```java
public class StackErrorTest {
    private static int count = 1;

    /*
    默认情况下count 22537
    设置栈大小:-Xss384:count:3188
    * */
    public static void main(String[] args) {
        System.out.println(count);
        count++;
        main(args);

    }

}
```



### 栈的存储单位

#### 栈中存储什么

-   每个线程都有自己的栈，栈中的数据都是以**栈帧（stack frame）的格式存在**。
-   在这个线程上正在执行的每个方法都各自对应一个栈帧。
-   栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

#### 栈运行原理

-   JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈

-   在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为**当前栈帧（Current Frame）**，与当前栈帧相对应的方法就是**当前方法（Current Method）**，定义这个方法的类就是**当前类（Current Class）**。

-   执行引擎运行的所有字节码指令只针对当前栈帧进行操作。

-   如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

-   不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧

-   如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前的帧，使得前一个栈帧重新成为当前栈帧。

-   Java方法有两种返回函数的方式：

    1.   **正常的函数返回，使用return指令**

    2.   **抛出异常，未处理**

         不论使用哪种方式，都会导致栈帧被弹出。

#### 栈帧的内部结构

每个栈帧中存储着：

-   **局部变量表（Local Variables）**
-   **操作数栈（Operand Stack）或表达式栈**
-   动态链接（Dynamic Linking）或指向运行时常量池的方法引用
-   方法返回地址（Return Address）或方法正常退出或异常退出的定义
-   一些附加信息

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220505223329705.png" style="zoom:40%;" />



### 局部变量表（Local Variables）

#### 概述

-   局部变量表也被称之为局部变量数组或本地变量表
-   **定义一个数字数组，主要用于存储方法参数和定义在方法体内部的局部变量，**这些数据类型包括各种基本数据类型、对象引用（reference），以及`returnAddress`类型
-   由于局部变量表是建立在线程的栈上，是线程的私有数据，**因此不存在数据安全问题**
-   **局部变量表所需的容量大小是在编译期确定下来的，**并保存在方法的Code属性的maximum local varaibles数据项中。在方法运行期间是不会改变局部变量表的大小的。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220505231340871.png" alt="image-20220505231340871" style="zoom: 33%;" />

-   **方法嵌套的次数由栈的大小决定。**
-   **局部变量表中的变量只在当前方法调用中有效。**在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量的列表的传递过程。**当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。**

#### 关于slot的理解

-   局部变量表，**最基本的存储单元时Slot（变量槽）**

-   在局部变量表里，**32位以内的类型只占一个slot（包括returnAddress（引用）类型）**，**64位的类型（long和都double）占用两个slot。**

-   JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值。

-   当一个实例方法被调用的时候，它的方法参数和方法内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个slot上。

-   **如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可，**（比如，访问long或double类型变量）

    <img src="/Users/heyufan1/Library/Application Support/typora-user-images/image-20220506151622564.png" alt="image-20220506151622564" style="zoom: 50%;" />

    例如上图，访问long m只需要访问1。

-   如果当前帧是由构造方法或者实例方法创建的，那么该**对象引用的this将会存放在index为0的slot处**，其余的参数按照参数表顺序继续排列。

    >   这也是为什么静态方法不能使用this变量，因为this变量不存在当前方法的局部变量表中！

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220506152418204.png" alt="image-20220506152418204" style="zoom: 33%;" />

-   同时slot还存在重复利用的机制

```java
    public void test01(){
        int a = 0;
        {
            int b = 0;
            b = a + 1;
        }
        //变量c使用之前已经被销毁的变量b占据的slot的位置
        int c = a + 1;
    }
```

#### 静态变量与局部变量的对比

>   首先回顾一下变量的分类，变量有两种分类方法：
>
>   1.   按照数据类型分类
>        1.   基本数据类型
>        2.   引用数据类型
>   2.   按照类中声明的位置
>        1.   成员变量：在使用前都经历过初始化赋值
>             1.   被`static`修饰：类变量或静态变量，在Linking的Prepare，给类变量默认赋值-----> initial阶段给类变量显式赋值，即静态代码块赋值（如果有静态代码块的话）
>             2.   未被`static`修饰：实例变量，随着对象的创建，在堆空间中分配实例变量空间，并进行默认赋值
>        2.   局部变量：在使用前，**必须要进行显式赋值，否则编译不通过**

```java
public void test(){
  int num;
  System.out.println(num);//局部变量未初始化
}
```

#### 补充说明

-   在栈帧中，与性能调优最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
-   **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。**



### 操作数栈（Operand Stack）

-   每一个独立的栈帧中除了包含局部变量表之外，还包含一个后进先出的**操作数栈**，也可以称之为**表达式栈（Expression Stack）**。

-   操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈和出栈

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220506170721403.png" alt="image-20220506170721403" style="zoom:33%;" />

-   **操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间**

-   操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随着被创建出来，**这个方法的操作数栈时空的**

-   每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220506171245192.png" alt="image-20220506171245192" style="zoom: 67%;" />

-   栈中任何一个元素都可以是任意的Java数据类型。

    -   32bit的类型占用一个栈单位深度
    -   64bit的类型占用两个栈单位深度

-   操作数栈**并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈来完成一次数据访问**

-   **如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中**，并更新PC寄存器中下一条需要执行的字节码指令。

-   操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

-   另外，所谓的Java虚拟机的**解释引擎是基于栈的执行引擎**，其中的栈值得就是操作数栈。

### 代码追踪

>   使用`javap`命令反编译class文件 `javap -v 类名.class`

### 栈顶缓存技术（Top-of-Stack Cashing）

基于栈式结构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作需要更多的入栈和出栈指令，这也就意味着需要更多的指令分派（instruction dispatch）次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁读写操作会影响执行速度，为了解决这个问题，HotSpot JVM使用**栈顶缓存（ToS，Top-of-Stack Cashing）**技术，**将栈顶元素全部缓存在物理CPU的寄存器中，以此降低内存的读/写次数，提升执行引擎的执行效率。**

### 动态链接（Dynamic Linking）

>   在一些地方，会将附加信息、动态链接和方法返回地址三者统称帧数据区。

也称之为指向运行时常量池的方法引用

每一个栈帧内部都包含一个指向**运行时常量池**中**该栈帧所属方法的引用**。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接

在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。

例如：描述一个方法调用了另外其他的方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220511002938221.png" alt="image-20220511002938221" style="zoom:40%;" />

>   为什么不将方法直接存到栈帧中？需要重复使用，没必要每个栈帧都存一份。

>   为什么需要常量池？
>
>   常量池的作用，就是为了提供一些符号和常量，便于指令识别。同时使得文件小一点。

### 方法的调用：解析与分派

>   所有的符号引用都要转换为直接引用，就如同所有的相对路径最终都是转换为绝对路径。

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

#### 静态链接和动态链接

-   静态链接

    当一个字节码文件被装载进JVM内部时，如果被调用的**目标方法在编译期可知**，且运行时保持不变，这种情况下将调用方法的符号引用转换为直接引用的过程称之为动态链接。

-   动态链接

    如果被**调用的方法在编译期间无法被确定下来**，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。

对应的方法绑定机制为早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。**

#### 早期绑定和晚期绑定

-   早期绑定

    早期绑定就是指被调用的目标方法如果在编译期间可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。

-   晚期绑定

    如果被调用的方法无法在编译期间被确定下来，只能够在程序运行期间根据实际的类型绑定的相关的方法，这种绑定方式也就被称之为晚期绑定。

#### 其他面向对象的语言与Java

所有的面向对象语言都具备多态，那么也具备早起绑定和晚期绑定两种绑定方式。

Java中任何一个普通方法其实都具备虚函数的特征，而C++需要用virtual关键字来修饰。如果在Java程序中不希望某个方法拥有虚函数特征时，则可以使用关键字`final`来标记这个方法。标识为fianl的方法就不能被重写。

#### 虚方法和非虚方法

>   子类对象的多态性的使用前提：
>
>   1.   类的继承关系
>   2.   方法重写

非虚方法：

-   如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称之为**非虚方法**。
-   静态方法、私有方法、final方法、实例构造器（构造器不能被重写）、父类方法都是非虚方法。
-   其他方法称之为虚方法。

#### 方法调用指令

虚拟机中提供了以下几条方法调用指令：

-   普通调用指令

    1.   `invokestatic`：调用静态方法，解析阶段确定唯一方法版本
    2.   `invokespecial`：调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
    3.   `invokevirtual`：调用所有虚方法
    4.   `invokeinterface`：调用接口方法

-   动态调用指令：

    `invokedynamic`：动态解析出需要调用的方法，然后执行

前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而`invokedynamic`指令支持有用户确定方法版本。其中`invokestatic`指令和`invokespecial`指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。

例子可见：JVM项目package com.hyf.virtualFun包下的Son.java文件

```java
public void show(){
  // invokestatic
  showStatic("Letsgofun.cn");

  //最好不要用super调用父类的静态方法
  //invokestatic
  super.showStatic("good!");

  //invokespecial  private修饰
  showPrivate("hello");

  // invokespecial
  super.showCommon();

  // invokevirtual，虽然叫做invokevirtual但不能认为加了final就是虚方法
  showFinal();//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法

  // invokevirtual，在编译期间确定不下来 public修饰
  showCommon();

  // invokevirtua
  info();

  MethodInterface in = null;
  //invokeinterfac
  in.methodA();
}
```

#### 关于invokedynamic指令

-   JVM字节码指令集一直比较稳定，一直到Java7才增加了一个`invokedynamic`指令，**这是Java为了实现动态类型语言支持而做的一种改进。**
-   但在Java7中并没有提供直接生成`invokedynamic`指令的方法，需要借助ASM这种底层字节码工具来产生`invokedynamic`指令。**直到Java8的Lambda表达式的出现，`invokedynamic`指令的生成，在Java中才有了直接生成的方法。**

#### 动态类型语言和静态类型语言

动态类型语言和静态类型两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。

静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

lambda表达式的引入使得Java拥有了动态语言的特点。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517005200587.png" alt="image-20220517005200587" style="zoom:40%;" />

#### 方法重写的本质

Java语言中方法重写的本质：

1.   找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。
2.   如果在类型C种找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回`java.lang.IllegalAccessError`异常。
3.   否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
4.   如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常。

>   `java.lang.IllegalAccessError`异常介绍：
>
>   程序试图访问或修改一个属性或调用一个方法，这个属性或方法，如果没有权限访问，一般来说会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。
>
>   可能在maven包冲突时出现。

#### 虚方法表

**为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table)来实现，使用索引表来代替查找，省略了层层向上判断。**

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

例如：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517011521424.png" alt="image-20220517011521424" style="zoom: 50%;" />

-   Father类和Son类重写了的方法指向自己，没有重写的方法指向父类。

**其实就是指向从子类到父类向上最近重写的方法。**

### 方法返回地址（Return Address）

-   存放调用该方法的PC寄存器的值。
-   一个方法的结束，有两种方式：
    -   正常执行完成
    -   出现未处理异常，非正常退出
-   无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，**调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址。**而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

#### 方法退出的两种方式

当一个方法开始执行后，只有两种方式可以退出这个方法：

1.   执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层方法的调用者，简称**正常完成出口**。

     -   一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。
     -   在字节码指令中，返回指令包含`ireturn`（当返回值是boolean、byte、char、short和int类型时使用）、`lreturn`、`freturn`、`dreturn`以及`areturn`（分别对应long、float、double和引用类型），另外还有一个`return`指令提供声明为void的方法、实例初始化方法、类和接口的初始化方法使用。

2.   在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称**异常出口。** 

     方法执行过程中抛出异常时的异常处理，存在一个异常处理表，方便在发生异常时找到处理异常的代码。

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517161035903.png" alt="image-20220517161035903" style="zoom:40%;" />

     解释如下：

     如果在4-16行（字节码指令的行号）发生的异常，就按照19行的catch来处理异常，针对任何（any）类型。

​		javap指令和jclasslib的显示不一样。例如JVM项目的com.hyf.returnAddress包下的ReturnAddressTest文件的method2方法的异常处理表：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517161516398.png" alt="image-20220517161516398" style="zoom:40%;" />

在method2方法的LineNumberTable中：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517161802501.png" alt="image-20220517161802501" style="zoom:40%;" />

4-8对应代码行72-75，而11对应73行：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517161908789.png" alt="image-20220517161908789" style="zoom:40%;" />



#### 方法退出的本质

本质上，方法的退出就是当前栈帧的出栈过程。因此需要恢复上层方法的局部变量表、操作数栈，将返回值压入调用者栈帧的操作数栈、设置PC寄存器的值等，让调用者方法继续执行下去。

**正常完成出口和异常完成出口的区别在于：通过异常完成出口的退出不会给他的上层调用者产生任何的返回值。**

### 一些附加信息

栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。

### 常见问题

1.   举例栈溢出的情况？（StackOverflowError）

     -   当栈空间一步步加载栈帧，空间不足的时候，导致栈溢出
     -   通过-Xss设置栈的大小
     -   当我们设置动态扩容时，整个内存空间满了会导致OOM

2.   调整栈大小，就能保证不出现溢出吗？

     -   答案是不能的
     -   对于普通的循环和递归，例如循环5000次，是可以通过调整栈大小来保证栈不溢出的。
     -   但是对于死循环和无限递归，调整栈的大小是无效的，仍然会导致StackOverflowError）

3.   分配的栈内存越大越好吗？

     -   理论上来说，分配的栈内存越大发生StackOverflowError的概率越小。
     -   但是整个内存空间是有限的，过大会挤占别的区域的空间。

4.   垃圾回收是否会涉及到虚拟机栈？

     -   不会！

     -   我们依次来看运行时数据区是否存在Error和GC

         |            | Error  | GC     |
         | ---------- | ------ | ------ |
         | 程序计数器 | 不存在 | 不存在 |
         | 虚拟机栈   | 存在   | 不存在 |
         | 本地方法栈 | 存在   | 不存在 |
         | 堆空间     | 存在   | 存在   |
         | 方法区     | 存在   | 存在   |

5.   方法中定义的局部变量是否存在线程安全问题？

     具体问题具体分析

     1.   内部的变量在内部产生，内部消亡的，是安全的(没有发生逃逸)
     2.   其余情况是不安全的。

     ```java
     package com.hyf.returnAddress;
     
     /**
      * @author 旋风冲锋龙卷风
      * @description: 方法中定义的局部变量是否存在线程安全问题？具体问题具体分析
      *
      *  什么是线程安全? 如果只有一个线程才可以操作此数据,则必是安全的.
      *  如果有多个线程操作次数据,则此数据是共享数据,如果不考虑同步机制的话,会存在线程安全问题
      * @date 2022/05/17 16:42
      * @Copyright: 个人博客 : http://letsgofun.cn/
      **/
     public class StringBuilderTest {
     
         int num = 10;
     
         //s1的声明方式是线程安全的,在方法内部定义,在方法内操作,并没有返回s1
         public static void method1(){
             //StringBuilder:线程不安全
             StringBuilder s1 = new StringBuilder();
             s1.append("a");
             s1.append("b");
             //...
         }
         //sBuilder的操作过程：是线程不安全的,传入的StringBuilder可能被其他线程调用
         public static void method2(StringBuilder sBuilder){
             sBuilder.append("a");
             sBuilder.append("b");
             //...
         }
         //s1的操作：是线程不安全的,因为返回s1,可能被其他线程调用
         public static StringBuilder method3(){
             StringBuilder s1 = new StringBuilder();
             s1.append("a");
             s1.append("b");
             return s1;
         }
     
         //s1的操作：是线程安全的,因为s1在内部消亡了
         // StringBuilder的toString是new了一个新的String,这个String可能不安全
         //但是s1是安全的
         public static String method4(){
             StringBuilder s1 = new StringBuilder();
             s1.append("a");
             s1.append("b");
             return s1.toString();
         }
     
         public static void main(String[] args) {
             StringBuilder s = new StringBuilder();
     
             //并发执行
     
             new Thread(() -> {
                 s.append("a");
                 s.append("b");
             }).start();
     
             method2(s);
     
         }
     
     }
     ```

     

## 5. 本地方法接口（Native Method Interface）

### 本地方法的概念

简单来说，一个Native Method就是Java调用非Java代码的接口。一个Native Method是这样一个Java方法：

>   该方法的实现由非Java语言实现，比如C。

这个特征并非Java所特有，很多其他编程语言都有这一机制，比如在C++中，可以用`extern C`告知C++编译器去调用一个C的函数。

本地接口的作用是融合不同的编程语言为Java所用，他的初衷是融合C/C++程序。

在定义一个本地方法的时候，并不提供实现体（有点像定义一个Java接口），因为其实现体是由非Java语言在外面实现的。

### 举例

Object类的getClass方法，Thread的start0方法，Thread的setPriority方法。

**标识符native可以与所有其他Java标识符连用，但是abstract除外**

### 为什么要使用Native Method

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

-   与Java环境外交互：

    **有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。**例如Java与一些底层系统，如操作系统或某些硬件交互信息的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

-   与操作系统交互

    JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。**通过使用本地方法，我们得以用Java实现了JRE的与底层系统的交互，甚至JVM的一些部分就是用C写的。**还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

-   Sun's Java

    **Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。**JRE大部分都是用Java实现的，它也通过一些本地方法与外界交互。例如：类`java.lang.Thread`的setPriority方法。这个本地方法使用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。

    #### 现状

    **目前该方法使用的越来越少了，除非是与硬件有关的应用。**比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等。



## 6. 本地方法栈(Native Method Stack)

-   Java虚拟机用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。
-   本地方法栈，也是线程私有的
-   允许被实现成固定或者可动态扩展的内存大小。（在内存溢出方面是相通的）
    -   如果线程请求分配的栈容量超过本地方法栈允许的最大容量。Java虚拟机将会抛出一个`StackOverflowError`异常。
    -   如果本地方法可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个`OutOfMemoryError`异常。
-   本地方法是使用C语言实现的。
-   它的具体做法是本地方法栈登记本地方法，在执行引擎（Execution Engine）执行时加载本地方法库。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517182945093.png" alt="image-20220517182945093" style="zoom: 42%;" />

上图是Hotspot的规范。

-   **当某个线程调用本地方法时，它就进入了一个全新并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。**
    -   本地方法可以通过本地方法接口来**访问虚拟机内部的运行时数据区**
    -   它甚至可以直接使用本地处理器中的寄存器
    -   直接从本地内存的堆中分配任意数量的内存
-   **并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。**如果JVM产品不打算支持native方法，也可以无需使用本地方法栈。
-   在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。

## 7. 堆

### 堆的核心概念

#### 堆的核心概述

方法区和堆是一个进程一份，一个Java进程就是一个JVM实例，只有一个Runtime。

可以使用命令`jvisualvm`来可视化看堆空间大小：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517195944397.png" alt="image-20220517195944397" style="zoom: 25%;" />

-   一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。

-   Java堆在JVM启动的时候被即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间（也是最重要）。

    -   堆的大小是可调节的。

-   《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

-   所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer, TLAB)，这也就意味着堆中有不共享的区域，每个线程一块。

-   《Java虚拟机规范》中对Java堆的描述是：所有对象实例以及数组都应当在运行时分配在堆上。

    -   但是实际上，是：“几乎”所有的对象实例都在这里分配内存。——从实际使用角度看的。

-   数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用只想对象或者数组在堆中的位置。

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517211500879.png" alt="image-20220517211500879" style="zoom:33%;" />

    ```java
    SimpleHeap s1 = new SimpleHeap(1); 
    ```

    对于上面代码，s1存在Java栈中，s1指向的实例存在堆中，而实例对应的方法实现和该类存放在方法区中。

-   在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
-   堆，是GC(Garbage Collection,垃圾收集器)执行垃圾回收的重点区域。

#### 内存细分

现代垃圾收集器大部分都基于分代手机理论设计，堆空间细分为：

-   Java 7及之前对内存<u>逻辑上</u>分为三部分：新生区 + 养老区 + **永久区**
    -   Young Generation Space 新生区 Young/New
        -   又被划分为Eden区和Survivor区
    -   Tenure Generation Space 养老区 Old/Tenure
    -   Permanent Space 永久区 Perm
-   Java 8及之后堆内存<u>逻辑上</u>分为三部分：新生区 + 养老区 + **元空间**
    -   Young Generation Space 新生区 Young/New
        -   又被划分为Eden区和Survivor区
    -   Tenure Generation Space 养老区 Old/Tenure
    -   Meta Space 元空间 Meta

>   约定：
>
>   <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220517214207185.png" alt="image-20220517214207185" style="zoom: 50%;" />

### 设置堆内存大小与OOM

#### 堆空间大小的设置

-   Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过添加VM选项`-Xmx`和`-Xms`来进行设置。
    -   `-Xms`用于表示堆区的起始内存，等价于`-XX:InitialHeapSize`
    -   `-Xmx`用于表示堆区的最大内存，等价于`-XX:MaxHeapSize`	
-   一旦堆区中的内存大小超过`-Xmx`所指定的最大内存时，将会抛出`OutOfMemoryError`异常。
-   通常会将 `-Xms`和`-Xmx`两个参数配置相同的值，其**目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。**
-   默认情况下
    -   初始内存大小：物理电脑内存大小 / 64
    -   最大内存大小：物理电脑内存大小 / 4

-   查看设置的参数:
    -    方式1 jps + jstat -gc 进程id       
    -   方式2 加一个参数: -XX:+PrintGCDetails


#### OutOfMemory举例

```java
package com.hyf.heap;

import java.util.ArrayList;
import java.util.Random;

/**
 * @author 旋风冲锋龙卷风
 * @description: 针对堆空间的OutOfMemory
 * @date 2022/05/20 15:14
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class OOMTest {
    public static void main(String[] args) {
        ArrayList<Picture> list = new ArrayList<>();
        while(true){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            list.add(new Picture(new Random().nextInt(1024 * 1024)));
        }
    }
}

class Picture{
    private byte[] pixels;

    public Picture(int length) {
        this.pixels = new byte[length];
    }
}
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520153409963.png" alt="image-20220520153409963" style="zoom:40%;" />

　

### 年轻代与老年代

-   从生命周期的角度来看，存储在JVM中的Java对象可以被划分为两类：
    -   一种是生命周期比较短的瞬时对象，这类对象的创建和消亡都非常迅速
    -   另外一类对象的生命周期却非常长，在某些极端情况下还能够与JVM的生命周期保持一致
-   Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）
-   其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区，但没有明确的说明说Survivor1就是to区）

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520163051442.png" alt="image-20220520163051442" style="zoom: 50%;" />

下面这个参数开发中一般不会调整：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520163317439.png" alt="image-20220520163317439" style="zoom:40%;" />

-   配置新生代与老年代在堆结构的比例
    -   默认`-XX:NewRatio=2`表示新生代占比1，老年代占比2，新生代占整个堆的1/3
    -   可以修改`-XX:NewRatio=4`表示新生代占比1，老年代占比4，新生代占整个堆的1/5
-   如果已经明确，在程序中生命周期长的数据较多，可以提高比例。
-   可以通过`jps + jinfo -flag NewRatio 进程id`来查看比例
-   在HotSpot中，Eden空间和另外两个Survivor空间缺省所占比例是8:1:1
-   当然开发人员可以通过选项`-XX:SurvivorRatio`调整这个空间比例，默认值是8。也可以用`jinfo`查看。
-   **几乎所有**的Java对象都是在Eden区被new出来的
-   绝大部分的Java对象的销毁都在新生代进行的
    -   IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。
-   可以使用选项`-Xmn`设置新生代最大内存大小，在矛盾的时候以它为准
    -   这个参数一般使用默认值就可以了。

### 图解对象分配过程

#### 概述

为新对象分配内存是一件非常严谨和复杂的部分，JVM的设计者们不仅需要考虑内存是如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收密切相关，所以还需要考虑GC执行玩内存回收后是否会在内存空间中产生内存碎片。

1.   new的对象先放在Eden区。此区有大小限制

2.   当Eden区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收（YGC/Minor GC），将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区。

3.   然后将Eden区中剩余的对象移动到幸存者0区（S0）。

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520230225298.png" alt="image-20220520230225298" style="zoom:40%;" />

     数字代表年龄计数器age，红色代表被销毁的，绿色代表留下的。

4.   如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有被回收，就会放到幸存者1区。

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520230249153.png" alt="image-20220520230249153" style="zoom:40%;" />

     因此幸存者0区和幸存者1区又被称为from区和to区，但是关系不确定。在每次执行玩后，谁空谁是to区。

5.   如果再次经历垃圾回收，此时会重新放回幸存者0区，如果没有被回收，就会放到幸存者1区。

6.   当年龄计数器age达到15的时候，如果仍然未被回收，则进入养老区。

     -   可以设置参数:`-XX:MaxTenurningThreshold=<N>进行设置`

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520230632702.png" alt="image-20220520230632702" style="zoom:40%;" />

7.   在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。

8.   若养老区执行了Major GC之后发现仍然无法进行对象的保存，就会产生OOM异常。

#### 总结

-   针对幸存者s0和s1:复制之后有交换，谁空谁是to
-   关于垃圾回收，频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间收集。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520233749275.png" alt="image-20220520233749275" style="zoom:40%;" />

存在一些特殊情况，直接晋升养老区。

#### 举例

```java
package com.hyf.heap;

import java.util.ArrayList;
import java.util.Random;

/**
 * @author 旋风冲锋龙卷风
 * @description: -Xms600m -Xmx600m
 * @date 2022/05/20 23:44
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class HeapInstanceTest {
    byte[] buffer = new byte[new Random().nextInt(1024 * 200)];

    public static void main(String[] args) {
        ArrayList<HeapInstanceTest> list = new ArrayList<HeapInstanceTest>();
        while (true) {
            list.add(new HeapInstanceTest());
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220520235724420.png" alt="image-20220520235724420" style="zoom:33%;" />

不同的区域，图表的形状是不一样的。

#### 常用的调优工具

-   JDK命令行
-   Jconsole
-   VisualVM
-   Jprofiler
-   Java Flighrt Recorder
-   GCViewer
-   GC Easy

### Minor GC、Major GC、Full GC

#### 部分收集和整堆收集

JVM在进行GC的时候，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指的新生代。

针对HotSpot VM的实现，它里面的GC按照回收区又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）

-   部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为:
    -   新生代收集（Minor GC / Young GC）：只是新生代（Eden、S0、S1）的垃圾收集
    -   老年代收集（Major GC / Old GC）：只是针对老年代的垃圾手机
        -   目前，只有CMS GC会有单独收集老年代的行为
        -   **注意，很多时候Major GC 会和 Full GC混淆使用，需要具体分辩是老年代回收还是整堆回收。**
    -   混合收集（Mixed GC）：收集整个新生代和部分老年代的垃圾收集
        -   目前，只有G1 GC会有这种行为
-   整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

####  最简单的分代式GC策略的触发条件

-   **年轻代GC（Minor GC）触发**

    -   当年轻代空间不足时，就会触发**Minor GC**，这里的年轻代满指的是**Eden**代满，**Survivor**满不会触发GC。每次（**Minor GC** 会清理年轻代的内存）。
    -   因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义即清晰又易于理解。
    -   Minor GC 会引发STW，暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复运行。

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521004307126.png" alt="image-20220521004307126" style="zoom:40%;" />

-   **老年代GC （Major GC / Full GC）触发机制**

    -   指发生在老年代的GC，对象从老年代消失时，我们所说的“Major GC”或“Full GC”发生了
    -   出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallerl Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。
        -   也就是说，在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。
    -   Major GC的速度一般会比Minor GC满10倍以上，STW的时间则更长。
        -   调优的一个目的就是减少Major GC的次数
    -   如果Major GC后，内存还不足，就报OOM。

-   **Full GC 触发时机**

    1.   调用`System.gc()`时，系统建议执行Full GC，但不是必然执行
    2.   老年代空间不足
    3.   方法区空间不足
    4.   通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    5.   由Eden区、S0区向S1区复制时，对象大小大于S1区（To Space）的可用内存时，则把该对象转存到老年代，且老年代的可用内存小雨该对象大小。

    >   说明：Full GC时开发或调优中尽量要避免的。这样暂时时间会短一些

#### 举例

```java
package com.hyf.heap;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 旋风冲锋龙卷风
 * @description: 测试Minor GC、Major GC、Full GC
 * 参数设置： -Xms9m -Xmx9m -XX:+PrintGCDetails
 * @date 2022/05/21 00:56
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class GCTest {
    public static void main(String[] args) {
        int i = 0;
        try {
            List<String> list = new ArrayList<>();
            String a = "atguigu.com";
            while (true) {
                list.add(a);
                a = a + a;
                i++;
            }

        } catch (Throwable t) {
            t.printStackTrace();
            System.out.println("遍历次数为：" + i);
        }
    }
}
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521010537659.png" alt="image-20220521010537659" style="zoom:40%;" />

### 堆空间分代思想

**为什么需要把Java堆分代？不分代就不能正常工作了吗？**

-   经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。
    -   新生代：有Eden、两块大小相同的Survivor（又称为from/to，s0/s1）构成，to总为空
    -   老年代：存放新生代中经历多次GC仍然存活的对象
-   其实不分代完全可以，分代的唯一理由就是优化GC性能。如果没有分代，那么所有的对象都在一块。GC的时候要找到哪些对象没用，需要对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一些地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。



### 内存分配策略（对象提升（Promotion）规则）

如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间中，并将对象年龄设为1。对象在Survivor区每熬过一次MinorGC，年龄就增加1，当它的年龄增加到一定程度（默认15，但其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代。

对象晋升老年代的年龄阈值，可以通过选项`-XX:MaxTenuringThreshold`来设置。

针对不同年龄段的对象分配原则如下所示：

-   优先分配到Eden
-   大对象直接分配到老年代
    -   尽量避免程序中出现过多的大对象
-   长期存活的对象分配到老年代
-   **动态对象年龄判断**
    -   如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。
-   **空间分配担保**
    -   `-XX:HandlePromotionFailure`

举个例子：

```java
package com.hyf.heap;

/**
 * @author 旋风冲锋龙卷风
 * @description: 大对象直接进入老年代
 *      参数：-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails
 * @date 2022/05/21 14:09
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class YoungOldAreaTest {
    public static void main(String[] args) {
        byte[] bytes = new byte[1024 * 1024 * 20]; //20m
    }
}
```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521142137822.png" alt="image-20220521142137822" style="zoom:40%;" />

没有产生垃圾回收，Old区占用20m。

### 为对象分配内存：TLAB

#### 为什么存在TLAB（Thread Local Allocation Buffer）？

-   堆区是共享区域，任何线程都可以访问到堆区中的共享数据
-   由于对象实例创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
-   为避免多个线程操作同一个地址，需要使用加锁等机制，进而影响分配速度

#### 什么是TLAB

-   从内存模型而不是垃圾收集的角度，对Eden区继续划分，JVM为**每个线程分配了一个私有缓存区域**，它包含在Eden空间内。

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521143256073.png" alt="image-20220521143256073" style="zoom:40%;" />

-   多线程同时分配内存的同时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们将这种没存分配方式称之为**快速分配策略**

-   所有OpenJDK衍生出来的JVM都提供了TLAB的设计。

#### TLAB的再说明

-   尽管不是所有的对象实例都能够在TLAB中成功分配内存，但**JVM确实是将TLAB作为内存分配的首选。**
-   在程序中，开发人员可以通过选项`- XX:UseTLAB`设置是否开启TLAB。默认情况是开启的。
-   默认情况下，TLAB空间的内存非常小，**仅占整个Eden空间的1%**，当然我们可以通过选项`-XX:TLABWasteTargetPercent`设置TLAB所占Eden空间的百分比大小。
-   一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过**使用加锁机制**确保数据操作的原子性，从而直接在Eden空间中分配内存。

#### 对象分配过程：TLAB

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521144040486.png" alt="image-20220521144040486" style="zoom:40%;" />



### 小结堆空间的参数设置

-   官网说明

    -   https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

-   `-XX:+PrintFlagsInitial`：查看所有的参数的默认初始值

-   `-XX:+PrintFlagsFinal`：查看所有参数的最终值（可能会存在修改，不再是初始值）

    <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521145644170.png" alt="image-20220521145644170" style="zoom:40%;" />

    修改后的值会有一个冒号`:`代表已经修改过

-   `jps` ：查看当前运行中的进程  + `jinfo -flag 参数名 进程id`：查看某个参数的值

-   `-Xms`：初始堆空间内存（默认为物理内存的 1/64）

-   `-Xmx`：最大堆空间内存（默认为物理内存的1/4）

-   `-Xmn`：设置新生代的大小（初始值及最大值）

-   `-XX:NewRatio`:配置新生代与老年代在堆的结构占比

-   `-XX:SurvivorRatio`：设置新生代中Eden和S0/S1空间的比例

-   `-XX:MaxTenuringThreshold`：设置新生代垃圾的最大年龄

-   `-XX:+PrintGCDetails`：输出详细的GC处理日志

    -   打印GC简要信息：1. `-XX:PrintGC` 2. `-verbose:gc`

-   `-XX:HandlePromotionFailure`：是否设置空间分配担保

**对于HandlePromotionFailure的解释**

在发生Minor GC之前，虚拟机会**检查老年代最大可用的连续空间是否大于新生代所有对象的总空间**。

-   如果大于，则此次Minor GC时安全的
-   如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`是否允许担保失败
    -   如果`HandlePromotionFailure=true`，那么会**检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。**
        -   如果大于，则尝试进行一次Minor GC，但这次Minor GC依然有风险。
        -   如果小于，则改为进行一次Full GC
    -   如果`HandlePromotionFailure=false`，则改为进行一次Full GC。

在JDK 6 Update 24以后（JDK 7），`HandlePromotionFailure`参数不会再影响到虚拟机的空间分配担保策略，观察Open JDK中的源码变化，虽然源码中还定义了`HandlePromotionFailure`参数，但是在代码中已经不会再去使用它。JDK 6 Update 24之后的规则变为**只要老年代的连续空间大于新生代对象总大小** 或者 **历次晋升的平均大小就会进行Full GC** ，否则将进行Full GC。

### 堆是分配对象存储的唯一选择吗

#### 堆是分配对象存储的唯一选择吗？

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：

>   随着JIT编译期的发展与**逃逸分析技术**的成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象分配到堆上也渐渐变得不那么“绝对”了。



在Java虚拟机中，对象是在Java堆中分配内存的，这是一个常识。但是，有一种特殊情况，那就是**如果经过逃逸分析(Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。**这样就无需在堆上分配内存，也无需进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于Open JDK深度定制的TaoBao VM，其中创新的GCIH(GC Invisiable Heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此降低GC的回收频率和提升GC的回收效率的目的。

#### 逃逸分析概述

-   如何将堆上的对象分配到栈，需要使用逃逸分析手段
-   这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
-   通过逃逸分析，Java HotSpot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
-   逃逸分析的基本能行为就是分析对象动态作用域：
    -   当一个对象在方法中被定义以后，对象只在方法内部使用，则认为没有发生逃逸。
    -   当一个对象爱过你在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

```java
public void my_method()	{
  V v = new V();
  //...
  v = null;
}
```

v这个对象只作用于一个方法内部，没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。



```java
public static StringBuffer createStringBuffer(String s1, String s2){
  StringBuffer sb = new StringBuffer();
  sb.append(s1);
  sb.append(s2);
  return sb;
}
```

上述代码如果想要`StringBuffer sb`不逃出方法，可以这样写：

```java
public static StringBuffer createStringBuffer(String s1, String s2){
  StringBuffer sb = new StringBuffer();
  sb.append(s1);
  sb.append(s2);
  return sb.toString();
}
```

上述代码如果想要`StringBuffer sb`对象只在方法内使用，不会发生逃逸。可以分配到栈上。



**逃逸的几种可能**：

```java
package com.hyf.heap;

/**
 * @author 旋风冲锋龙卷风
 * @description: 逃逸分析的几种情况
 * 如何快速判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用
 * @date 2022/05/21 16:08
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class EscapeAnalysis {
    public EscapeAnalysis obj;
    /*
    *   方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance() {
        return obj == null ? new EscapeAnalysis() : obj;
    }

    /*
    * 为成员属性赋值，发生逃逸
    * */
    public void setObj(){
        this.obj = new EscapeAnalysis();
    }

    //如果当前的obj引用声明为static，仍然会发生逃逸
    /*
    * 对象的作用域仅在当前方法中有效，没有发生逃逸
    * */
    public void useEscapeAnalysis(){
        EscapeAnalysis e = new EscapeAnalysis();
        // getInstance().xxx同样也会发生逃逸
    }

    /*
    * 引用成员变量的值，发生逃逸,我们关心的不是引用e，而是实体
    * */
    public void useEscapeAnalysis1(){
        EscapeAnalysis e = getInstance();
    }
}
```

只要没有发生逃逸，对象就可以分配到栈上。

**参数设置：**

-   在JDK 6u23版本（JDK7）之后，HotSpot中默认就已经开启了逃逸分析。
-   如果使用的是较早的版本，开发人员可以通过：
    -   选项`-XX:DoEscapeAnalysis`显式开启逃逸分析
    -   选项`-XX:+PrintEscapeAnalysis`查看逃逸分析的筛选结果

>   结论：
>
>   开发中能使用局部变量的，就不要在方法外定义。

#### 逃逸分析：代码优化

使用逃逸分析，编译器可以对代码做如下优化：

1.   **栈上分配。**将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆配。
2.   **同步省略。**如果一个对象呗法相只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
3.   **分离对象或标量替换。**有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

#### 代码优化之栈上分配

JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈呢执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。

**常见的栈上分配的场景**

-   在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。

**开启逃逸分析和不开启逃逸分析**

```java
package com.hyf.heap;

/**
 * @author 旋风冲锋龙卷风
 * @description: 栈上分配测试
 * 参数设置 ：-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 * @date 2022/05/21 16:35
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class StackAllocation {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
        // 为了方便查看堆内存中对象个数，线程sleep
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e1) {
            e1.printStackTrace();
        }
    }

    private static void alloc() {
        User user = new User(); //未发生逃逸
    }

    static class User {

    }
}

```

alloc函数的User对象并为发生逃逸。

`-XX:-DoEscapeAnalysis`代表不开启逃逸分析，`-XX:+DoEscapeAnalysis`代表开启逃逸分析。

`-server`：启用Server模式，只有在Server模式下，才可以使用逃逸分析。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521174303209.png" alt="image-20220521174303209" style="zoom:40%;" />

64位机，在默认情况下，就是Server模式。

1.   不开启逃逸分析：

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521164938953.png" alt="image-20220521164938953" style="zoom:40%;" />

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521164954546.png" alt="image-20220521164954546" style="zoom:40%;" />

2.   开启逃逸分析

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521164628205.png" alt="image-20220521164628205" style="zoom:40%;" />

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521164645601.png" alt="image-20220521164645601" style="zoom:40%;" />

可以看到开启逃逸分析，运行时间少了很多，User对象的个数也少了很多。如果堆空间大小不足的话，未开启逃逸分析会引起GC，开启逃逸则不会。（仅针对上述案例）

#### 代码优化之同步省略（消除）

-   线程同步的代价是相当高的，同步的后果是降低并发性和性能
-   在动态编译同步块的时候，JIT编译器可以借助逃逸分析来**判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发不到其他线程。**如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

**代码分析**

```java
public void f(){
  Object hollis = new Object();
  synchronized(hollis){
    System.out.println(hollis);
  }
}
```

代码中堆`hollis`这个对象进行加锁，但是`hollis`对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉。优化成：

```java
public void f(){
  Object hollis = new Object();
  System.out.println(hollis);
}
```

这两段代码的区别就是取消了同步块。看字节码文件的时候可能会有`synchronized`的身影，但在执行的时候会消除。

#### 代码优化之标量替换

**标量(Scalar)**是指一个无法再分解成更小的数据。Java中的原始数据类型就是标量。例如Java中的基本数据类型就属于标量。

相对的，那些还可以分解的数据叫做**聚合量(Aggregate)**，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含若干个成员变量来代替。这个过程就是**标量替换。**

**标量替换参数设置：**

参数`-XX:+EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配在栈上。

**代码：**

```
package com.hyf.heap;

/**
 * @author 旋风冲锋龙卷风
 * @description: 标量替换测试
 * -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations
 * @date 2022/05/21 17:23
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class ScalarReplace {
    public static class User {
        public int id;
        public String name;
    }

    public static void alloc() {
        User u = new User();//未发生逃逸
        u.id = 5;
        u.name = "www.atguigu.com";
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
    }
}
```

1.   未开启标量替换：

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521173824417.png" alt="image-20220521173824417" style="zoom:40%;" />

2.   开启标量替换

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521173855329.png" alt="image-20220521173855329" style="zoom:40%;" />

花费的时间减少了，同时也没有发生GC



#### 逃逸分析小结：逃逸分析并不成熟

-   关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才实现，而且这项技术到如今也不是十分成熟。
-   其根本原因就是**无法保证逃逸分析的性能消耗一定高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，者其实也是一个相对耗时的过程。**
-   一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就浪费了。
-   虽然这项技术并不十分成熟，但是它也**是即时编译器优化技术中一个十分重要的手段**。
-   注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，Oracle HotSpot JVM中并未这么多，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。而之前看到的效果提升都是基于标量替换。
-   目前很多书记还是基于JDK 7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象都是分配在堆上。

### 小结

-   年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集，结束生命。
-   老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也会有特殊情况，我们知道普通的对象会被分配在TLAB上；如果对象较大，JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就直接分配到老年代。
-   当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生老年代时则被称为Major GC或Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。

## 8. 方法区

### 堆、栈、方法区的交互关系

从运行时数据区来看：已经介绍过

从线程是否共享的角度来看：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521193720838.png" alt="image-20220521193720838" style="zoom:40%;" />

#### 栈、堆、方法区的交互关系：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521195352295.png" alt="image-20220521195352295" style="zoom:40%;" />

### 方法区的理解

#### 方法区的概念

方法区是线程共享的，方法区存储类的结构：

1.   类的常量池
2.   属性和方法数据
3.   方法和构造器的字节码
4.   用于类、接口、实例初始化的特殊方法



#### 方法区在哪里

《Java虚拟机规范》中明确说明：

>   尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择区进行垃圾收集或者进行压缩。

但对于HotSpot JVM而言，方法区还有一个别名叫做`Non-Heap（非堆）`，目的就是要和堆分开。

所以，**方法区看作一块独立于Java堆的内存空间**。

#### 方法区的基本理解

-   方法区（Method Area）和Java堆一样，是各个线程共享的内存区域。
-   方法区在JVM启动的时候被创建，并且它的实际物理内存空间和Java堆区一样都可以是不连续的。
-   方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：`java.lang.OutOfMemoryError: PermGen space `或者`java.lang.OutOfMemoryError: Metaspace` 
    -   **加载大量第三方的jar包；Tomcat部署的工程过多（30-50个）；大量动态的生成反射类。**
-   关闭JVM就会释放这个区域的内存

#### HotSpot中方法区的演进

-   在JDK7及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。
-   本质上，方法区和永久代并不等价。仅是对于HotSpot而言的这两者是等价的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA  JRockit / IBM J9不存在永久代的概念。
    -   现在看来，当年使用永久代，不是好的idea。导致Java程序更容易OOM（超过`-XX:MaxPermSize`上限）

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521223041348.png" alt="image-20220521223041348" style="zoom:40%;" />

-   到了JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。
-   元空间的本质与永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：**元空间不再虚拟机设置的内存中，而是使用本地内存。**
-   永久代、元空间二者并不只是名字比那了，内部结构也调整了。
-   根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常。

### 设置方法区大小与OOM

方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。

#### JDK7及以前

-   通过`-XX:PermSize`来设置永久代初始分配空间。默认值是20.75M
-   `-XX:MaxPermSize`来设定永久代的最大可分配空间。32位机器默认是64M，64位机器默认是82M
-   当JVM加载的类信息容量超过了这个值，会报异常OOM

#### JDK8及以后

-   元数据区大小可以使用参数`-XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`制定，替代上述原有的两个参数。
-   默认值依赖于平台。windows下，`-XX:MetaspaceSize`是21M，`-XX:MaxMetaspaceSize`的值是-1，即没有限制
-   与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用内存。如果元数据区发生溢出，虚拟机一样会抛出一个OOM异常。
-   `-XX:MetaspaceSize`：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21M。这就是初始的高水位线，一旦触及这个水位线，Full GC将会触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重制。新的高水位线的值取决于GC 后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。
-   如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将`-XX:MetaspaceSize`设置为一个相对较高的值。

#### 方法区内存溢出举例

```java
package com.hyf.methodArea;
import com.sun.xml.internal.ws.org.objectweb.asm.ClassWriter;
import jdk.internal.org.objectweb.asm.Opcodes;

/**
 * @author 旋风冲锋龙卷风
 * @description: 测试方法区内存溢出
 * VM args : -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m -XX:-UseCompressedOops

 * @date 2022/05/21 23:39
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class OOMTest extends ClassLoader {
    public static void main(String[] args) {
        int j = 0;
        try {
            OOMTest test = new OOMTest();
            for (int i = 0; i < 10000000; i++) {
                //创建ClassWriter对象，用于生成类的二进制字节码
                ClassWriter classWriter = new ClassWriter(0);
                //指明版本号，修饰符，类名，包名，父类，接口
                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, "Class" + i, null, "java/lang/Object", null);
                //返回byte[]
                byte[] code = classWriter.toByteArray();
                //类的加载
                test.defineClass("Class" + i, code, 0, code.length);//Class对象
                j++;
            }
        } finally {
            System.out.println(j);
        }
    }
}

```

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220521235234531.png" alt="image-20220521235234531" style="zoom:40%;" />

#### 如何解决OOM

1.   要解决OOM异常或者heap  space的异常，一般的手段是通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆存储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分析清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。
2.   如果是内存泄漏，可以进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置
3.   如果不存在内存泄漏，换句话说就是内存中的对象确实都嗨必须活着，那就应当检查虚拟机的堆参数(-Xmx 与 -Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

### 方法区的内部结构

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522000940559.png" alt="image-20220522000940559" style="zoom:40%;" />

#### 方法区（Method Area）存储什么

《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：

>   它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/%E7%AC%AC09%E7%AB%A0_%E6%96%B9%E6%B3%95%E5%8C%BA%E5%AD%98%E5%82%A8%E4%BF%A1%E6%81%AF.jpg" alt="第09章_方法区存储信息" style="zoom:40%;" />

#### 方法区的内部结构

**类型信息**

对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：

1.   这个类型的完整有效名称（全名 = 包名.类名）
2.   这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
3.   这个类型的修饰符（public、abstract、final的某个子集）
4.   这个类型直接接口的一个有序列表

**域(Field)信息**

也被称之为成员变量或者属性

-   JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
-   域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、static、final、volatile、transient的某个子集）

**方法(Method)信息**

JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：

-   方法名称
-   方法的返回类型（或void）
-   方法参数的数量和类型（按顺序）
-   方法的修饰符（public、private、protected、static、final、synchroniezd、native、abstract的一个子集）
-   方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
-   异常表（abstract和native方法除外）
    -   每个异常处理的开始位置、结束为止、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引。

#### non-final的类变量

-   静态变量和类关联在一起，随着类的加载而加载，它们称为类数据在逻辑上的一部分。
-   类变量被类的所有实例共享，即使没有类实例时你也可以访问它。

我们声明一个为`null`的实例，仍然可以访问静态变量：

```java
package com.hyf.methodArea;
/**
 * @author 旋风冲锋龙卷风
 * @description: 测试 non-final 的类变量
 * @date 2022/05/22 14:21
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class MethodAreaTest {
    public static void main(String[] args) {
        Order order = null;
        order.hello();
        System.out.println(order.count);
    }
}

class Order {
    public static int count = 1;
    public static final int number = 2;


    public static void hello() {
        System.out.println("hello!");
    }
}
```

#### 全局常量：static final

被声明为final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522143148616.png" alt="image-20220522143148616" style="zoom:40%;" />

#### 运行时常量池 VS 常量池

-   方法区，内部包含了运行时常量池
-   字节码文件，内部包含了常量池
-   要弄清楚方法区，需要理解清楚ClassFIle，因为加载类的信息都在方法区。
-   要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池

一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用。

#### 为什么需要常量池？

一个Java源文件中的类、接口，编译后产生一个一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。

#### 常量池中有什么？

**几种在常量池内存储的数据类型包括：**

-   数量值
-   字符串值
-   类引用
-   字段引用
-   方法引用

例如下面这段代码：

```java
public class MethodAreaTest2{
  public static void main(String[] args){
    Object obj = new Object();
  }
}
```

`Object obj = new Object();`将会被编译成如下字节码：

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522145312109.png" alt="image-20220522145312109" style="zoom:40%;" />

**小结：**

常量池，可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。

#### 运行时常量池

-   运行时常量池(Runtime Constant Pool)是方法区的一部分。
-   常量池表(Constant Pool Table)是Class文件的一部分，**用于存放编译期生成的各种字面量于符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。**
-   运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
-   JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过**索引**访问的。
-   运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为**真实地址**。
    -   运行时常量池，相对于Class文件常量池的另一重要特征是：**具备动态性**
        -   `String.intern()`
-   运行时常量池类似于传统编程语言的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。
-   当创建类或接口的运行时常量 池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OOM。

### 方法区使用举例

有如下代码：

```java
package com.hyf.methodArea;

/**
 * @author 旋风冲锋龙卷风
 * @description: 运行时常量池举例
 * @date 2022/05/22 15:15
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class MthodAreaDemo2 {
    public static void main(String[] args) {
        int x = 500;
        int y = 100;
        int a = x / y;
        int b = 50;
        System.out.println(a + b);
    }
}
```

逐步看字节码指令的执行过程：

1.   将500这个数值压入操作数栈：

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522152515345.png" alt="image-20220522152515345" style="zoom:40%;" />

2.   弹出操作数栈栈顶500，保存到本地变量表1

     <img src="/Users/heyufan1/Library/Application Support/typora-user-images/image-20220522152623678.png" alt="image-20220522152623678" style="zoom:40%;" />

3.   将100这个数值压入操作数栈，并弹出操作数栈栈顶100，保存到本地变量表2

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522152808567.png" alt="image-20220522152808567" style="zoom:40%;" />

4.   读取本地变量1（对应500），压入操作数栈

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522152949209.png" alt="image-20220522152949209" style="zoom:40%;" />

5.   读取本地变量2，压入操作数栈

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522153045501.png" alt="image-20220522153045501" style="zoom:40%;" />

6.   将栈顶两int类型数相除，结果入栈  500 / 100 = 5

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522153249032.png" alt="image-20220522153249032" style="zoom:40%;" />

7.   将50压入操作数栈

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522153418433.png" alt="image-20220522153418433" style="zoom:40%;" />

8.   将栈顶int类型值保存到局部变量4中

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522153459629.png" alt="image-20220522153459629" style="zoom:40%;" />

9.   获取类或接口字段的值，并将其推入操作数栈，`#2`对应常量池中的 Fieldref #15.#16。最终目的是调用System.out

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522153727843.png" alt="image-20220522153727843" style="zoom:40%;" />

10.   将本地变量3和本地变量4取出，压入操作数栈

      <img src="/Users/heyufan1/Library/Application Support/typora-user-images/image-20220522153919953.png" alt="image-20220522153919953" style="zoom:40%;" />

11.   将栈顶两int类型数相加，结果入栈

      <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522154003929.png" alt="image-20220522154003929" style="zoom:40%;" />

12.   调用静态方法。JVM会根据这个方法的描述，**创建新的栈帧，方法的参数从操作数栈中弹出来，压入虚拟机栈，然后虚拟机会开始执行虚拟机栈最上面的栈帧。**

      执行完毕后，再继续执行main方法对应的栈帧。

      <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522154239619.png" alt="image-20220522154239619" style="zoom:40%;" />

13.   void函数返回。main方法执行结束。

      <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522154321153.png" alt="image-20220522154321153" style="zoom:40%;" />

在整个执行过程中，当前线程的程序计数器PC始终会记录当前的执行位置，因为在执行过程中随时可能切换。

### 方法区的演进细节

1.   首先明确：只有HotSpot才有永久代。

     BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属域虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。

2.   HotSpot中方法区的变化：

     |     版本     |                             变化                             |
     | :----------: | :----------------------------------------------------------: |
     | JDK1.6及以前 |   有永久代（permanent generation），静态变量存放在永久代上   |
     |    JDK1.7    | 有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中 |
     | JDK1.8及以后 | 无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆 |

3.   JDK 6

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522160858003.png" alt="image-20220522160858003" style="zoom:40%;" />

4.   JDK 7

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522160927821.png" alt="image-20220522160927821" style="zoom:40%;" />

5.   JDK 8

     <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522161003501.png" alt="image-20220522161003501" style="zoom:40%;" />

#### 为什么要用元空间替换永久代？

类信息的生命比较长。不放在虚拟机内存而是放在本地内存可能更好。

-   随着Java 8的到来，HotSpot VM中再也见不到永久代了。但这并不意味着类的元数据信息也消失了。这些数据被移到了一个**与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）**。

-   由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。

-   这项改动是很有必要的，原因有：

    1.   为永久代设置空间大小是很难确定的。

         在某些场景下，如果动态加载的类过多，容易产生Perm区的OOM。比如某个实际Web工程中吗，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。

         <img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522161917857.png" alt="image-20220522161917857" style="zoom:40%;" />

         而元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

    2.   对永久代进行调优是很困难的。

#### StringTable为什么要调整

JDK 7中将StringTable放到了堆空间中。因为永久代回收效率很低，在Full GC时候才会触发。而Full GC时老年代的空间不足、永久代不足时才会触发。

这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

#### 静态变量放在哪里？

>   首先需要明确的一个概念是：静态引用对象的实体始终存在堆空间，也就是通过new生成的结构。

例如：

```java
 private static byte[] arr = new byte[1024 * 1024 * 100];
```

上述代码`new byte[1024 * 1024 * 100]`生成的实体时存放在堆中的，这一点没有异议。我们需要讨论的是`arr`这个变量存放的位置。

```java
package com.hyf.methodArea;

/**
 * @author 旋风冲锋龙卷风
 * @description: <<深入理解Java虚拟机>>中的案例:
 *  staticObj,instanceObj,localObj存放在哪里
 * @date 2022/05/22 22:43
 * @Copyright: 个人博客 : http://letsgofun.cn/
 **/
public class StaticObjTest {
    static class Test {
        //静态属性
        static ObjectHolder  staticObj = new ObjectHolder();
        //非静态属性
        ObjectHolder instanceObj = new ObjectHolder();

        void foo() {
            //局部变量
            ObjectHolder localObj = new ObjectHolder();
            System.out.println("done");
        }
    }

    private static class ObjectHolder {
    }

    public static void main(String[] args) {
        Test test = new StaticObjTest.Test();
        test.foo();
    }
```

上述代码中，`staticObj`随着`Test`的类型信息存放在方法区，`instanceObj`随着`Test`对象实例存放在Java堆，`localObj`测试存放在foo()方法栈帧的局部变量表中。

JDK 7及以后版本的HotSpot虚拟机选择把**静态变量与类型**在Java语言一端的映射Class对象存放在一起，存储于Java堆之中。

### 方法区的垃圾回收

很多人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。

一般来说**这个区域的回收效果比较难以令人满意，尤其是类型的卸载，条件相当苛刻。**但是这个部分区域的回收**有时候又确实是必要的**。以前Sun公司的Bug列表中，曾出现过若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。

**方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型**。

-   方法区内常量池之中主要存放两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
    1.   类和接口的全限定名
    2.   字段和名称的描述符
    3.   方法的名称和描述符
-   HotSpot虚拟机对常量池的回收策略是很明确的，**只要常量池中没有被任何地方引用，就可以被回收**。
-   回收废弃常量与回收Java堆中的对象非常类似。

判断一个常量是否废弃还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：

1.   该类的所有实例都已经被回收，也就是Java堆中不存在该类以及其任何派生子类的实例。
2.   加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景。如OSGi、JSP的重加载等，否则通常是很难达成的。
3.   该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否对类型进行回收，HotSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class`以及`-XX:+TraceClass-Loading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，<u>通常都需要Java虚拟机具备类型卸载的能力，以确保不会对方法区造成过大的内存压力</u>。

### 总结

<img src="https://raw.github.com/Missyesterday/picgo/main/picgo/image-20220522232319617.png" alt="image-20220522232319617" style="zoom:40%;" />

#### 常见面试题

-   百度三面：说一下JVM内存模型吧，有哪些区？分别干什么的？
-   蚂蚁金服：
    -   Java8内存分代改进
    -   JVM内存分哪几个区，每个区的作用是什么
    -   一面：JVM内存结构？栈和堆的区别？堆的结构？为什么两个Survivor区？
    -   二面：Eden和Survivor的比例分配
-   小米：JVM内存分区，为什么要有新生代和老年代
-   字节：
    -   一面：Java的内存分区
    -   二面：讲讲JVM运行时数据区
    -   什么时候对象会进入老年代？
-   京东：
    -   JVM的内存结构，Eden区和Survivor的比例
    -   JVM内存为什么要分成新生代、老年代、持久代。新生代为什么要分为Eden和Survivor
-   天猫：
    -   一面：JVM内存模型以及分区，需要详细到每个区放什么
    -   一面：JVM的内存模型，Java8有什么修改
-   美团：JVM的永久代会发生垃圾回收吗？

