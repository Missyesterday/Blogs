# 纤程（Fiber）和协程（Routine）

## 纤程（Fiber）

纤程（Fiber）是 Windows操作系统提出的概念。当我们「异步执行」一些任务时，常用的做法是开启一个工作线程，在工作线程中执行我们的任务，但是这样存在两个问题：

-   线程的调度是操作系统内核控制的，我们没法准确确定操作系统何时会运行或挂起该线程；
-   对于一些 「更加轻量级」的任务，创建一个线程消耗也比较大。

有没有一种机制，即可以新建线程去执行任务，又没有新建线程消耗那么大呢？**纤程可以做到。**

Windows 中「一个线程可以有多个纤程」，用户可以根据需要自由在各个线程之间切换。在线程中使用纤程，需要将该线程切换成**纤程模式**：

```cpp
LPVOID ConvertThreadToFiber(LPVOID lpParameter);
```

默认的主纤程什么都不干，需要创建纤程：

```cpp
LPVOID CreateFiber(SIZE_T                dwStackSize,
				   LPFIBER_START_ROUTINE lpStartAddress, 
				   LPVOID                lpParameter);

```

纤程的删除、修改、和切换

```cpp
VOID WINAPI FIBER_START_ROUTINE(LPVOID lpFiberParameter);
void DeleteFiber(LPVOID lpFiber);
void SwitchToFiber(LPVOID lpFiber);
```

**demo**

```cpp
#include <Windows.h>
#include <string>

char g_szTime[64] = { "time not set..." };
LPVOID mainWorkerFiber = NULL;
LPVOID pWorkerFiber = NULL;

void WINAPI workerFiberProc(LPVOID lpFiberParameter)
{
    while (true)
    {
        //假设这是一项很耗时的操作
        SYSTEMTIME st;
        GetLocalTime(&st);
        wsprintfA(g_szTime, "%04d-%02d-%02d %02d:%02d:%02d", st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
        printf("%s\n", g_szTime);

        //切换回主纤程
        //SwitchToFiber(mainWorkerFiber);
    }  
}

int main()
{
    mainWorkerFiber = ConvertThreadToFiber(NULL);
    
    int index = 0;
    while (index < 100)
    {
        ++index;
                 
        pWorkerFiber = CreateFiber(0, workerFiberProc, NULL);
        if (pWorkerFiber == NULL)
            return -1;
        //切换至新的纤程
        SwitchToFiber(pWorkerFiber);

        memset(g_szTime, 0, sizeof(g_szTime));
        strncpy(g_szTime, "time not set...", strlen("time not set..."));
        

        printf("%s\n", g_szTime);
        
        Sleep(1000);      
    }

    DeleteFiber(pWorkerFiber);

    //切换回线程模式
    ConvertFiberToThread();
    
    return 0;
}

```

>   Fiber 可以在多个纤程之间切换。
>
>   例如：把主线程转换为主 Fiber，然后创建两个纤程，分别用来读和。然后主线程切换到到写纤程，写纤程切换到读纤程，不停切换，直到文件拷贝完毕，最后由主线程删除读写纤程，并转换为 线程，结束。

## 协程（Routine）

内核态线程是操作系统的内核对象，多线程的切换需要切换到内核态，而「协程」是用户态线程。例如，在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 很不明智，所以现在的主流做法都是用操作系统提供的「基于事件模式的异步编程模型」（epoll），用少量的线程来服务大量的网络连接和 IO，但是这样的程序代码复杂，容易出错，也不容易排查。

**协程**就是在应用层模拟的线程，它没有线程上下文切换的损耗，同时又能并发运行，在高并发的网络服务器中，可以为每一个 socket 连接使用协程来处理，代码结构更加清晰。

操作系统 API 并不支持协程，Golang 在语言的运行时环境利用线程技术模拟了一套协程。

在这些语言中，**协程的内部实现都是基于线程的，**思路是维护了一组数据结构和 n 个线程，真正执行的还是线程，协程执行的时候代码被放进一个「待执行队列」中，由这n 个线程拉起来执行，当异步函数返回 busy 或者 blcoking 的时候，Golang 将这个协程的代码放入待执行队列中，再让线程拉起另一个协程的代码来执行。Golang 可以十万协程同时运行，因为他从编译器和语言基础库等多个层面对协程进行了实现。

腾讯公司开源了一套 C/C++ 版本的协程库 libco。