# MySQL是怎样运行的02

## 08. MySQL的数据目录

### 8.1 数据库和文件系统的关系

类似于`InnoDB`和`MyISAM`这样的存储引擎都是把表存在磁盘上的，而操作系统用来管理磁盘的是`文件系统`。所以：像 **InnoDB** 、 **MyISAM** 这样的存储引擎都是把表存储在文件系统上的。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们，当我们想写入数据的时候，这些存储引擎会把这些数据又写回文件系统。



### 8.2 MySQL数据目录

MySQL服务器程序在启动时会到文件系统的某个目录下加载一些文件，之后在运行过程中产生的数据也会存储到这个目录下的某些文件中，这个目录被称为`数据目录`。

#### 8.2.1 数据目录和安装目录的区别



#### 8.2.2 确定MySQL中的数据目录

使用:

```sql
show variables like 'datadir';
```

查看`数据目录`，在我的电脑（Mac）上为`/usr/local/mysql/data/`，而在Linux服务器这个目录为`/usr/local/mysql/data/`。



### 8.3 数据目录的结构

MySQL在运行的过程中，会产生很多数据，例如：创建的数据库、表、视图和触发器，这些被称为「用户数据」。除此之外，MySQL也会创建一些其他的额外数据。



#### 8.3.1 数据库在文件系统中的表示

每个数据库都对应数据目录下的一个子目录（文件夹），每当我们新建一个数据库，MySQL会：

1.   在`数据目录`下创建一个和数据库同名的子目录（文件夹）
2.   在这个子目录下创建一个名为`db.opt`文件，这个文件包含了该数据的各种属性，例如字符集和比较规则等。

查看数据目录：

```
-rw-r-----. 1 root mysql  27K 4月  30 15:04 aliyun.err
-rw-r-----. 1 root mysql    5 4月  29 15:18 aliyun.pid
-rw-r-----. 1 root mysql   56 1月   6 01:11 auto.cnf
-rw-------. 1 root mysql 1.7K 1月   6 01:11 ca-key.pem
-rw-r--r--. 1 root mysql 1.1K 1月   6 01:11 ca.pem
-rw-r--r--. 1 root mysql 1.1K 1月   6 01:11 client-cert.pem
-rw-------. 1 root mysql 1.7K 1月   6 01:11 client-key.pem
-rw-r-----. 1 root mysql  286 4月  29 15:18 ib_buffer_pool
-rw-r-----. 1 root mysql  12M 4月  29 15:18 ibdata1
-rw-r-----. 1 root mysql  48M 4月  29 15:18 ib_logfile0
-rw-r-----. 1 root mysql  48M 1月   6 01:11 ib_logfile1
-rw-r-----. 1 root mysql  12M 4月  29 15:18 ibtmp1
-rw-r-----. 1 root mysql  12K 1月  22 21:32 iz2ze04i2j4qfxax1se5xvz.err
-rw-r-----. 1 root mysql  11K 1月  15 16:11 iZ2ze04i2j4qfxax1se5xvZ.err
-rw-r-----. 1 root mysql    6 1月   6 01:14 iZ2ze04i2j4qfxax1se5xvZ.pid
drwxr-x---. 2 root mysql 4.0K 1月   6 01:11 mysql
drwxr-x---. 2 root mysql 4.0K 1月   6 01:11 performance_schema
-rw-------. 1 root mysql 1.7K 1月   6 01:11 private_key.pem
-rw-r--r--. 1 root mysql  452 1月   6 01:11 public_key.pem
-rw-r--r--. 1 root mysql 1.1K 1月   6 01:11 server-cert.pem
-rw-------. 1 root mysql 1.7K 1月   6 01:11 server-key.pem
drwxr-x---. 2 root mysql  12K 1月   6 01:11 sys
drwxr-x---. 2 root mysql 4.0K 1月   6 01:22 yourdb
```

这个数据目录下文件和子目录比较多，除了`information_schema`这个系统数据库外，其他的数据库在`数据目录`下都有对应的子目录。

#### 8.3.2 表在文件系统中的定义

数据都是以「记录」的形式插入到表中的，每个表的信息可以分为两种：

-   表结构的定义，用二进制文件`表名.frm`表示
-   表中的数据，InnoDB和MyISAM保存方式不同



#### 8.3.3 InnoDB存储表数据的方式



**InnoDB中：**

-   使用`页`为基本单位来管理存储空间，默认`页`大小为16KB
-   每个索引都对应一棵B+树，该B+树的每个节点都是一个数据页，这些数据页之间是用「双向链表」连接的
-   聚簇索引的叶子结点存储了完整的用户数据，也就是「索引即数据，数据即索引」

为了管理这些「页」，InnoDB中提出了一个`表空间`（也叫`文件空间`)的概念，「表空间」是一个抽象的概念，它可以对应文件系统上一个或多个真实文件（不同表空间对应的文件数量可能不同）。每一个「表空间」可以被划分为很多个「页」，表数据就存放在某个「表空间」下的某些页中。

表空间有几种不同的类型：

##### 系统表空间（system tablespace）

所谓「系统表空间」可以对应文件系统上一个或多个实际的文件，默认情况下，InnoDB会在「数据目录」下创建一个名为`ibdata1`大小为12M的文件，这个文件就是对应的「系统表空间」在文件系统上的表示，这个文件是「自扩展文件」，当不够用的时候它会自己增加文件大小。

如果像让系统表空间对应系统文件上多个实际文件，可以修改配置文件：

```ini
[server]
innodb_data_filepath=data1:512M;data2:521M:autoextend
```

这样就会有两个512M的文件作为系统表空间，其中`autoextend`表示这两个文件如果不够用会自动扩展`data2`文件的大小。

在MySQL服务器中，系统表空间只有一份，从MySQL5.5.7～MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个「系统表空间」。

##### 独立表空间（file-per-table tablespace）

在MySQL5.6.6之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。

同时这个表示该「独立表空间」的文件在「该表所属数据库对应的子目录」下，文件名和表名相同，后缀为`.ibd`，例如：`表名.idb`。

所以在某个数据库的子目录下，有：

```
-rw-r-----. 1 root mysql   61 1月   6 01:22 db.opt
-rw-r-----. 1 root mysql 8.5K 1月   6 01:22 user.frm
-rw-r-----. 1 root mysql  96K 1月   6 01:33 user.ibd
```

`user.ibd`存储的就是`user`表中的数据和索引。

我们还可以自己指定使用`系统表空间`还是`独立表空间`来存储数据：

```ini
[server]
innodb_file_per_table=0
```

这个参数值为0，代表使用系统表空间，当`innodb_file_per_table`为1，表示使用独立表空间，但是这个参数只对新建的表起作用。

如果想把已经存放在系统表空间中的表转移到「独立表空间」可以使用下面的语法：

```sql
alter table 表名 tablespace [=] innodb_file_per_table;
```

或者把已经存在「独立表空间」的表转移到「系统表空间」，可以使用：

```sql
alter table 表名 tablespace [=] innodb_system;
```

用`[]`中括号括起来的参数表示可有可无。

##### 其他类型的表空间

随着MySQL的发展，又出现了一些表空间：

-   通用表空间（general tablespace）
-   undo表空间（undo tablespace）
-   临时表空间（temporary tablespace）



#### 8.3.4 MyISAM存储表数据的方式

在`MyISAM`中索引全部都是`二级索引`，该存储引擎的「数据」和「索引」是分开放的。所以文件系统中需要使用不容的文件来存储数据文件和索引文件。

与InnoDB不同，MyISAM并不存在所谓「表空间」，表数据都存放在「对应的数据库子目录下」，也就是都是「独立表空间」。创建一个test表，在数据库子目录下有三个子文件：

```txt
test.frm
test.MYD
test.MYI
```

其中`test.MYD`代表数据文件，也就是我们插入的用户记录；`test.MYI`代表表的「索引文件」。



#### 8.3.5 视图在文件系统中的表示

在MySQL中，「视图」就是虚拟的表，所以存储视图的时候不需要存储真实数据，只需要存储结构，也就是`视图名.frm`文件。



#### 8.3.6 其他文件

除了上述用户自己存储的数据外，`数据目录`下还包括了更好运行程序的一些额外文件：

-   服务器进程文件

    每运行一个MySQL服务器程序，都意味着启动一个进程，MySQL服务器会把自己的进程ID写入到一个文件中

-   服务器日志文件

-   默认/自动 生成的SSL和RSA证书和密钥文件



### 8.4 文件系统对数据库的影响

因为MySQL的数据都是存在文件系统中的，所以需要收到文件系统的一些制约，其中「数据库和表的命名」、表的大小和性能 方面比较明显：

-   数据库名称和表的名称不得超过文件系统所允许的最大长度

    每个数据库都对应`数据目录`的一个子目录，每个表都会在数据库子目录下生成一个`.frm`文件，这些目录和文件名的长度都受限于文件系统所允许的长度

-   特殊字符问题

    为了避免因为数据库名和表名出现某些特殊字符而造成文件系统不支持的情况，`MySQL`会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 `@+编码值`的形式作为文件名。比方说我们创建的表的名称为`'test?'`，由于`?`不属于数字或者拉丁字母，所以会被映射成编码值，所以这个表对应的`.frm`文件的名称就变成了`test@003f.frm`。

-   文件大小受文件系统最大大小的限制

    对于`InnoDB`的独立表空间来说，每个表的数据都会被存储到一个与表名同名的`.ibd`文件中；对于`MyISAM`存储引擎来说，数据和索引会分别存放到与表同名的`.MYD`和`.MYI`文件中。这些文件会随着表中记录的增加而增大，它们的大小受限于文件系统支持的最大文件大小。



### 8.5 MySQL系统数据库

MySQL的系统数据库包含了MySQL服务器运行过程中所需要的一些信息和运行状态信息：

-   `mysql`

    核心数据库，存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

-   `information_schema`

    这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引等。这些信息并不是真实的用户数据，而是一些描述性信息，有时也被称为「元数据」。

-   `performance_schema`

    这个数据库里主要保存MySQL服务器运行的一些状态信息，相当于对MySQL服务器的一个性能监控。包括最近执行了什么语句，在执行的过程的每个阶段都花费了多长时间，内存的使用情况等信息。

-   `sys`

    这个数据库主要通过「视图」的形式把`information_schema`和`performance_schema`结合起来，让程序员可以更方便了解MySQL服务器的一些性能信息。

## 09. InnoDB的表空间

「表空间」是一个抽象的概念，对于系统表空间而言，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应文件系统中一个名为`表名.ibd`的实际文件。

表空间可以被想象成被切分成许多个`页`的池子，当想为某个表插入一条记录的时候，就要从池子中选择一个对应的「页」写入数据。

### 9.1 回忆页面相关知识

#### 9.1.1 页面类型

页面有很多类型，常用的就是`FIL_PAGE_INDEX`也就是「索引页」也叫「数据页」。为了表述方便，把前面的`FIL_PAGE`省略，简称`INDEX`类型。

类似，`FIL_PAGE_TYPE_ALLOCATED`简称`ALLOCATED`类型。



#### 9.1.2 页面通用部分

任何类型的页面都有：

-   `File Header`：记录页面的一些通用信息
-   `File Trailer`：检验页是否完整，保证从内存到磁盘刷新时内容的一致性



### 9.2 独立表空间结构

InnoDB中支持许多类型的表空间，但是重点还是「独立表空间」和「系统表空间」的结构。它们的结构比较相似，但是「系统表空间」中额外包含了一些关于整个系统的信息。



#### 9.2.1 区（extent）的概念

表空间的页太多了，为了更好地管理这些页面，InnoDB使用「**区**」（extent）的概念。对于16KB的页而言，**物理上**连续的64个页就是一个「区」，也就是说一个区默认占用1MB空间大小，不论是系统表空间还是独立表空间，都可以视为由若干个区组成的，每256个区被划分成一组：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/1/16a739f33df9307a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:67%;" />

从上图可知：

-   第一组的最开始三个页面的类型是固定的，也就是说`extent 0`这个区最开始三个页面的类型 是固定的：
    -   `FSP_HDR`类型，这个类型的页面是用来登记整个表空间的一些整体属性以及本组的所有区，也就是`extent0 ~ extent255`这256个区的属性，整个表只有一个`FSP_HDR`类型的页面。
    -   `IBUF_BITMAP`类型，这个类型的页面存储本组所有的区所有页面关于`INSERT BUFFER`的信息
    -   `INODE`类型，存储了许多`INODE`的数据结构。

-   其余各组最开始的两个页面的类型是固定的：
    -   `XDES`，是`extent descriptor`的缩写，用来登记本组256个区的属性，与`FSP_HDR`类似，但是`FSP_HDR`还会额外存储一些表空间的属性。
    -   `IBUF_BITMAP`


**记住一点，区内是连续的页。**

#### 9.2.2 段（segment）的概念

>   为什么会有区？
>
>   如果表中数据很少，只要几百几十条，确实不用区，因为只需要简单几个页就可以把对应的数据存储起来，但是如果表中数据很多，虽然页之间有双线链表链接起来，但是如果这些「页」距离很远，磁盘的「随机IO」速度比「顺序IO」要慢很多。
>
>   所以引入「区（extent）」，一个「区」就是物理位置上连续的64个页，也就是1M。
>
>   当表中数据量很大的时候，为某个索引分配空间分配空间的时候，就不是按「页」，而是按「区」分配。虽然可能会造成存储空间的浪费（数据不足以填满整个区），但是可以消除很多「随机IO」，总的来说还是利大于弊。



所谓的「范围查询」，其实就是对B+树的「叶子结点」进行扫描，所以MySQL的设计者对B+树的叶子结点和非叶子结点进行了区别对待，存放叶子结点的区的集合算一个「段」，存放非叶子结点的区的集合也算一个「段」。所以一个索引会生成两个段，一个「叶子结点段」，一个「非叶子结点段」。

如果数据很小，将一个完整的区分配个某个段，会造成太浪费存储空间。所以「碎片\(fragment\)区」的概念出现了，「碎片区」可以用于不同的目的，直属于表空间，并不属于任何一个段。

所以为某个段分配存储空间的策略是：

-   在刚开始向表中插入数据的时候，段是从某个「碎片区」以单个「页」为单位来分配存储空间的
-   当某个段的占用到达32个「碎片区页面」之后，就会以完整的「区」为单位来分配存储空间

除此之外，InnoDB中来存储中一些特殊数据的段，例如回滚段等。



#### 9.2.3 区的分类

表空间由若干区组成的，区大体上分为4类，同时也被称为区的4种状态（state）

-   空闲的区：现在还没有用到这个区的任何页面，state为`FREE`
-   有剩余空间的碎片区：表示碎片区中还有可用的页面，state为`FREE_FRAG`
-   没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面，state为`FULL_FRAG`
-   附属于某个段的区：每个索引都可以分为叶子结点段和非叶子结点段，state为`FSEG`

前面三种状态都是独立的，直属于表空间，最后的`FSEG`是附属于某个段的。



#### 9.2.4 XDES Entry

为了方便管理区，每个区都对应了一个`XDES Entry`结构（Extent Descriptor Entry），这些结构记录了对应的区的一些属性：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/1/16a739f343654829~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

`XDES Entry`是一个40字节的结构：

-   `Segment ID`

    表示该区所在的段的ID，每个段都有唯一的一个`Segment ID`

-   `List Node`

    这部分可以将若干个`XDES Entry`结构串成一个链表

    -   `Prev Node Page Number`和`Pre Node Offset`的组合就是指向前一个`XDES Entry`的指针
    -   `Next Node Page Number`和`Next Node Offset`的组合后一个`XDES Entry`的指针

-   `State`

    表名区的状态，可选有4个

-   `Page State Bitmap`（16字节）

    一个区有64个页，每个页对应两个bit比特位。前一个比特位表示对应的页是否是空闲，后一个比特位没有用。



>   之后的内容有点没看懂。先缓缓看下一章。



## 10. 单表访问方法

先建立一个表：

```sql

create table single_table(
    id int not null auto_increment,
    key1 varchar(100),
    key2 int,
    key3 varchar(100),
    key_part1 varchar(100),
    key_part2 varchar(100),
    key_part3 varchar(100),
    common_field varchar(100),
    primary key (id),
    key idx_key1(key1),
    unique key idx_key2 (key2),
    key idx_key3 (key3),
    key idx_key_part(key_part1, key_part2, key_part3)
)engine=InnoDB charset=utf8;
```

我们为这个`single_table`表建立了一个聚簇索引和四个二级索引。

同时为这个表插入10000行记录。



### 10.1 访问方法（access method）的概念

从MySQL中获取想要插叙的数据有很多方式，对于单表查询的执行方式，大致分为两种：

-   使用全表扫描进行查询
-   使用索引进行查询。这种方法也又分为很多种类：
    -   针对主键或唯一二级索引的等值查询
    -   针对普通二级索引的等值查询
    -   针对索引列的范围查询
    -   直接扫描整个索引

MySQL执行查询语句的方式被称为「访问方法」或「访问类型」。同一条查询语句可能有多种「访问方法」来执行，它们效率不同，但是结果是相同的。



### 10.2 const访问方法

通过主键来定位一条记录：

```sql
select * from single_table where id = 1438;
```

MySQL会直接利用主键值在「聚簇索引」中定位对应的用户记录。

>   B+树是长得像一个矮矮的大胖子。

同时，用唯一「二级索引」来定位一条记录也是很快的：

```sql
select * from single_table where key2 = 3841;
```

这个查询分为两部，因为`idx_key2`对应的B+树索引中的叶子结点是`key2 + id`，查询的是`*`，所以还需要根据`id`回表。



通过主键 或者 唯一二级索引列 与 「常数」的等值比较 来定位一条记录的访问方法定义为`const`，意思是常数级别的，代价可以忽略不计。

如果主键和唯一二级索引是由多个列构成的，索引中的每一个列都需要和 「常数」进行等值比较，这个 const 的访问方法才有效。

对于唯一二级索引来说，查询该列值为`NULL`比较特殊：

```sql
select * from single_table where key2 is null;
```

因为唯一二级索引列并不限制`null`值的数量，所以上述语句可能访问到多条记录，也就是说这个语句不能用`const`的方法来访问。





### 10.3 ref访问方法

有时候我们需要对某个普通的二级索引列常数进行等值比较，例如：

```sql
select * from single_table where key1 = 'abc';
```

对于这个查询，可以选择「全表扫描」逐一对比搜索条件是否满足要求，也可以先使用二级索引找到对应记录的`id`值，然后「回表」到聚簇索引中查找完整的用户记录。

但是普通二级索引并不限制索引列的唯一性，所以可能找到多条对应的记录，使用二级索引来执行查询的代价取决于「等值匹配」匹配到的二级索引记录数。如果匹配的记录比较少，则回表的代价低，如果匹配的记录比较多，还不如直接「全表扫描」。

这种搜索条件被称为「二级索引列与常数等值比较」，采用二级索引来执行查询的访问方法被称为「ref」。对于普通的二级索引来说，通过索引列进行等值比较后可能匹配到多条连续的记录，而不是像「主键」和「唯一二级索引」那样最多只能匹配到 1 条记录，但是在二级索引等值比较时匹配的记录较少时的效率也很高，但是需要注意：

-   二级索引列值为`NULL`的情况

    不论是普通索引，还是唯一二级索引，它们对索引列包含`NULL`值的数量并不限制，所以使用`key is null`这种形式的搜索条件时，**最多**只能使用`ref`的访问方法，而不是`const`的访问方法

-   二级索引列有多个列

    对于包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就**有可能**采用`ref`的访问方法，但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能成为`ref`了，例如使用范围比较。



### 10.4 ref_or_null访问方法

有时我们不仅想找出某个二级索引列的值为某个常数的记录，还想把该列值为`NULL`的记录也找出来：

```sql
select * from single_table where key1 = 'abc' or key1 is null;
```

当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的「访问方法」就被称为`ref_or_null`。



### 10.5 range 访问方法

```sql
select * from single_table where key2 in (1438, 6238) or (key2 >= 38 and key2 <= 79);
```

`in`表示在这两个数中，而不是表示范围，也可以被称为「单点区间」，后面的范围被称为「连续范围区间」。

首先要牢记，仍然可以使用「全表扫描」的方式来执行这个查询。

如果采用「二级索引 + 回表」的方式来执行的话，这种访问方式称为`range`。



### 10.6 index 访问方法

```sql
select key_part1, key_part2, key_part3 from single_table where key_part2 = 'abc';
```

由于`key_part2`并不是联合索引`idx_key_part`最左索引列，所以我们无法使用`ref`或者`range`访问方法来执行这个语句，但是这个查询符合这两个条件：

-   它的查询列表只有 3 个列：`key_part1`,`key_part2`,`key_part3`，正好被索引`idx_part`所包含。
-   搜索条件的列`key_part2`也被包含在索引`idx_key_part`中。

也就是说，我们可以直接遍历`idx_key_part`索引的叶子节点记录来比较`key_part2 = 'abc'`这个条件是否成立，然后在结果集中添加「二级索引」记录的`key_part1, key_part2, key_part3`。

由于二级索引记录比聚簇索引要小得多（不包含所有的列和所谓隐藏列），所以这样**遍历二级索引记录**还是比「全表扫描」要快的多，这种方式被称为`index`访问方法。



### 10.7 all 访问方法

全表扫描（对于 InnoDB来说也就是扫描聚簇索引），被称为`all`。



### 10.8 注意事项

一般情况下只能利用单个二级索引执行查询，例如：

```sql
select * from single_table where key1 = 'abc' and key2 > 1000;
```

「查询优化器」会识别到这个查询中两个搜索条件：

-   `key1 = 'abc'`
-   `key2 > 1000`

优化器一般会根据`single_table`表的统计数据来判断到底使用哪个条件 对应的 「二级索引」中 查询扫描的行数会更少，选择扫描行数比较少的条件到对应的二级索引中查询。然后将从该二级索引中查询到的结果经过回表得到完整的用户记录，再根据其他`where`条件过滤记录。

一般来说，等值查找比范围查找需要扫描的行数更少，也就是`ref`比`range`，但也不一定，这里假设优化器使用`idx_key1`索引进行查询，查询过程如下：

-   使用二级索引定位记录，根据条件`key1 = 'abc'`从`idx_key1`索引代表的 B+ 树中找到对应的二级索引记录。
-   回表。根据上一步找到的记录的主键进行「回表」，再根据条件`key2 > 1000`过滤。



>   Tips：
>
>   一般来说，执行一个查询只会用到一个二级索引，但是有特殊情况。



### 10.9 明确 range 访问方法使用的范围区间

对于 B+树来说，只要索引列和常数使用`=, <=>, in, not in, is null, is not null, <, >, <=, >=, between, != 或 <>`，或者`like`操作符连接起来就可以产生一个所谓的「区间」。



>   Tips:
>
>   需要注意的是，`like`操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引。
>
>   `in`操作符本质上就是多个`=`之间用`or`连接起来。



当想使用`range`访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。

#### 10.9.1 所有搜索条件都可以使用某个索引的情况

有时候每个搜索条件都可以使用到某个索引，例如：

```sql
select * from single_table where key2 > 100 and key2 > 200;
select * from single_table where key2 > 100 or key2 > 200
```

没什么多说的，本质上，就是多个搜索条件可以合并成一个



#### 10.9.2 有的搜索条件无法使用索引的情况

例如：

```sql
select * from single_table where key2 > 100 and common_field = 'abc';
```

这个查询语句中能利用索引的只有`idx_key2`一个，而`idx_key2`这个二级索引的记录中又不包含`common_field`这个字段，所以第二个条件是在「回表」阶段才会用到。

所以使用二级索引查询`idx_key2`的范围就是`(100, 正无穷)`。

但是如果使用`or`连接查询条件：

```sql
select * from single_table where key2> 100 or common_field = 'abc';
```

如果强制使用`idx_key2`索引，回表需要把全部二级索引的记录回表，所以使用`or`连接的搜索条件需要注意。



#### 10.9.3 复杂搜索条件下找出范围匹配的区间

还是一句话，简化条件，找出该查询可用的索引以及这些索引对应的范围区间。

### 10.10 索引合并

一般情况下 MySQL 执行一个查询最多用到单个耳机索引。但是有些特殊情况下也有可能在一个查询中使用到多个二级索引。使用多个索引来完成一次查询的方式被称为「index merge」。

#### 10.10.1 Intersection 合并

`Intersection`就是「交集」。这里指的是，某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，例如：

```sql
select * from single_table where key1 = 'a' and key3 = 'b';
```

假设这个查询使用`Intersection`合并的方式执行的话，过程如下：

-   从`idx_key1`二级索引对应的 B+树中取出`key1 = 'a'`的相关记录
-   从`idx_key3`二级索引对应的 B+树中取出`key3 = 'b'`的相关记录
-   二级索引的记录都是`索引列 + 主键`的形式，所以我们可以计算这两个结果集中`id`值的交集
-   回表



如果只使用`idx_key1`或者`idx_key3`，然后回表的时候过滤另一个搜索条件，成本如下：

-   按照某个搜索条件读取一个二级索引
-   根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件

读取二级索引是「顺序 IO」，而回表操作是「随机 IO」，如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录非常少，当节省的因为回表而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。

MySQL 在某些特定的情况下才会使用到`Intersection`索引合并：

----

**情况 1：**二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。

例如下面这个查询**可能**用到`idx_key1`和`idx_key_part`这两个二级索引进行`Intersection`索引合并的操作：

```sql
select * from single_table where key1 = 'a' and key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c';
```

而下面这两个查询就不能进行`Intersection`索引合并：

```sql
SELECT * FROM single_table WHERE key1 > 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';

SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a';
```

第一个查询是因为出现了范围匹配，第二个查询是因为联合索引只出现了一部分。



**情况 2：**主键列可以是范围匹配

比如下面这个查询可能用到主键和`idx_key1`进行`Intersection`索引合并的操作：

```sql
select * from single_table where id > 100 and key1 = 'a';
```

本质是：二级索引的用户记录是`索引列+主键`构成的，所以如果二级索引的索引列相同，则按照主键值排序。

所以上面的 sql 语句中从`idx_key1`中找到索引列为`a`的记录，并过滤。

>   优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过`Intersection`索引合并后需要回表的记录数大大减少时才会使用`Intersection`索引合并。



#### 10.10.2 Union合并



不同的`OR`搜索条件会用到不同的索引，例如：

```sql
select * from single_table where key1 = 'a' or key3 = 'b';
```

`Union`表示「并集」，与`Intersection`类似，MySQL 在某些特定情况下才会使用到`Union`索引合并：



**情况 1：**二级索引列是「等值匹配」的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能只出现匹配部分列的情况。

例如：

```sql
select * from single_table where key1 = 'a' or (key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c');
```

上面这个就**可以**使用`idx_key1`和`idx_key_part`这两个耳机索引进行`Union`索引合并的操作。

再有：

```sql
select * from single_table where key1 > 'a' or (key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c');
select * from single_table where key1 = 'a' or key_part1 = 'a';
```

上面这两个查询就**不能**使用Union 索引合并。



**情况 2：**主键列可以是范围匹配

**情况 3：**使用`Intersection`索引合并的搜索条件

例如：

```sql
select * from single_table where key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c' or ( key1 = 'a' and key3 = 'b');
```

上诉查询中「搜索条件」的某些部分就是用了`Intersection`索引合并的方式得到主键集合和其他方式得到的主键集合取交集。

优化器可能采取如下方式执行这个查询：

-   先按照搜索条件`key1 = 'a' and key3 = 'b'`从索引`idx_key1`和`idx_key3`中使用`Intersection`索引合并的方式得到一个主键集合。
-   再按照搜索条件`key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'`从联合索引`idx_key_part`中得到另一个主键的集合
-   采用`Union`索引合并的方式把上述两个主键集合取并集，然后进行回表操作。



#### 10.10.3 Sort-Union 合并

`Union`索引合并的使用条件太苛刻，必须保证每个二级索引列在进行「等值匹配」的条件下才可能被用到，例如：

```sql
select * from single_table where key1 < 'a' or key3 > 'z';
```

这是因为根据`key1 < 'a'`从`idx_key1`索引中获取的二级索引记录的主键值不是排序好的，后者也类似。但是这两个搜索条件又特别合适，所以优化器可能采用被称为「`Sort-Union`索引合并」的方式：

-   先根据`key1 < 'a'`条件从`idx_key1`二级索引中获取记录，并按照记录的主键值进行排序
-   再根据`key3 > 'z'`条件从`idx_key3`二级索引中获取记录，并按照记录的主键值进行排序
-   由于上述两个二级索引的主键值都是排序好的，所以剩下的方式就是和`Union`索引合并方式是一样的。



>   Tips:
>
>   但是没有「Sort-Intersection」索引合并，因为「Sort-Union」的适用场景是单独根据搜索条件从某个二级索引获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序，代价也不是特别大。
>
>   而「Intersection索引合并」的适用场景是：单独根据某个搜索条件从某个而今索引中获取的记录数太多，导致回表的代价太大，合并后可以明显减低回表开销，如果加入「Sort-Intersection 索引合并」，就需要为大量二级索引记录按照主键值排序，这个成本很大，所以没有引入「Sort-Intersection」。

### 10.11 联合索引代替 Intersection 索引合并

```sql
select * from single_table where key1 = 'a' and key3 = 'b';
```

这个查询之所以可能使用`Intersection`索引合并的方法执行，因为`idx_key1`和`idx_key3`是两个单独的`B+`树索引。

**如果没有单独查询`key3`的业务场景，可以建立`key1`和`key3`的联合索引！**



## 11. 连接的原理

建立两个表，两个表的数据类型相同

```sql
create table t1 (m1 int, n1 char(1));
create table t2 (m2 int, n2 char(1));
insert into t1 values (1, 'a'), (2, 'b'), (3, 'c');
insert into t2 values (2, 'b'), (2, 'c'), (3, 'd');
```



### 11.1 连接简介

#### 11.1.1 连接的本质

「连接」的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户，把`t1`和`t2`两个表连接起来如图：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230513205012345.png" alt="image-20230513205012345" style="zoom:50%;" />

这个过程看起来就像把各个「连接表」中的记录连起来组成更大的记录，所以这个查询被称为「连接查询」。

连接查询的结果集中 包含 一个表中每一条记录和另一个表中的每一个记录 相互匹配的组合，像这样的结果集被称为「**笛卡尔积**」。 两个表连接后笛卡尔积有 「m * n」条记录。

MySQL中连接查询的语法：

```sql
select * from t1, t2;
```



#### 11.1.2 连接过程简介

如果没有任何限制条件，不同表连接起来产生的「笛卡尔积」非常巨大。所以需要采取过滤条件：

-   涉及单表的条件

    也就是「搜索条件」，例如`t1.m1 > 1`这种

-   设计多表的条件

    例如`t1.m1 > t2.m1`这种



**举例：**

```sql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.m2 and t2.n2 < 'd';
```

使用了三个过滤条件，这个连接查询的过程如下：

1.   首先确定第一个需要查询的表，这个表被称为「驱动表」。然后选择一个「执行方法」去执行单表查询。假设选择`t1`作为「驱动表」，从`t1`中找出满足`t1.m1 > 1`的记录，有两条：

     <img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230513212703696.png" alt="image-20230513212703696" style="zoom:50%;" />

2.   针对上一步中从驱动表中产生的结果集中的每一条记录，分别需要到`t2`表中查找匹配的记录，所谓「匹配的记录」，指的是「符合过滤条件的记录」。因为是根据`t1`表中的记录去找`t2`表中的记录，所以`t2`表也被称为「被驱动表」。上一步从「驱动表」中获得了两条记录，所以需要查询 2 次`t2`表，`m1`列的值分别是「2 和 3」

     1.   当`t1.m1 = 2`时，过滤条件就相当于`t2.m2 = 2`，所以此时`t2`表中就有就有`t2.m2 = 2`和`t2.n2 < 'd'`两个过滤条件，然后到`t2`表中执行单表查询。
     2.   当`t1.m1 = 3`，同上。

     

最后的结果：

```
+------+------+------+------+
| m1   | n1   | m2   | n2   |
+------+------+------+------+
|    2 | b    |    2 | b    |
|    3 | c    |    3 | c    |
+------+------+------+------+
```



如果把`t1.m1 > 1`这个条件去掉，那么从`t1`表中查询的记录就有 3 条，就要查询 3 次`t2`表。

也就是说，在「两表的连接查询」中，「驱动表」只需要访问一次，「被驱动表」可能被访问多次。



### 11.2 内连接和外连接

先创建两个具有现实意义的表：

```sql
create table student
(
    number int not null auto_increment comment '学号',
    name varchar(5) comment '姓名',
    major varchar(30) comment '专业',
    primary key (number)
)engine = InnoDB charset = utf8 comment '学生信息表';

create table score
(
    number int comment '学号',
    subject varchar(30) comment '科目',
    score tinyint comment '成绩',
    primary key (number, subject)
)engine = InnoDB charset = utf8 comment '学生成绩表'


```

添加一点数据：

**student表**

| nmber    | name | major            |
| -------- | ---- | ---------------- |
| 20230101 | 张三 | 软件工程         |
| 20230102 | 李四 | 计算机科学与技术 |
| 20230103 | 王五 | 计算机科学与技术 |




**score 表**

| number   | subject  | score |
| -------- | -------- | ----- |
| 20180101 | 操作系统 | 88    |
| 20180101 | 数据结构 | 100   |
| 20180102 | 操作系统 | 98    |
| 20230101 | 数据结构 | 78    |



现在想查询「每个学生的考试成绩」，就需要两表连接了。连接的过程就是从`student`表中取出记录，在`score`表中查找`number`相同的成绩记录，所以过滤条件就是`student.number = score.number`:

```sql
select s1.number, s1.name, s2.subject, s2.score from student as s1, score s2 where s1.number = s2.number;
```

查询结果：

| number   | name | subject  | score |
| -------- | ---- | -------- | ----- |
| 20230101 | 张三 | 操作系统 | 88    |
| 20230101 | 张三 | 数据结构 | 78    |
| 20230102 | 李四 | 操作系统 | 98    |
| 20230102 | 李四 | 数据结构 | 100   |

上述有成绩的各个同学的各科成绩被查询出来了，但是有个问题，那就是`学号`为`20230103`的同学没有参加考试，所以在`score`表中没有对应的成绩记录。如果老师想查看**所有同学**（包括没有参加考试）的考试成绩。但是目前的`连接查询`无法完成这样的需求。

这个需求的本质思想是：**驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。**为了解决这个问题，引入了「**内连接**」和「**外连接**」的概念：

-   对于`内连接`的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集，上面的所有连接都是`内连接`。
-   对于`外连接`的两个表，驱动表中的记录即使在被驱动表中找不到匹配的记录，也需要加入到结果集中。

在 MySQL 中，根据选取驱动表的不同，外连接又被分为：

-   左外连接：选取左侧的表为驱动表，简称`左连接`
-   右外连接：选取右侧的表为驱动表，简称`右连接`

但是，对于外连接而言，有时候我们也并不想把驱动标的全部记录加入到最后的结果集，所以有了两种过滤条件：

-   `where`子句中的过滤条件，不论是内连接还是外连接，只要不符合`where`子句的过滤条件的记录都不会被加入到最后的结果集。

-   `on`子句中的过滤条件：

    对于外连接的驱动表的记录来说，如果无法在「被驱动表」中找到匹配`on`子句中的过滤条件的记录，那么这个记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用`null`值填充。

    需要注意的是：`on`子句是专门为外连接「驱动表」中的记录在「被驱动表」中找不到匹配记录时 应不应该把该记录加入结果集 这个场景下提出的，所以在内连接中，`on`子句和`where`子句是等价的。



>   一般情况下，我们把只涉及单表的过滤条件放到`where`子句中，把涉及两表的过滤条件都放到`on`子句中，`on`子句也被称为`连接条件`。



#### 11.2.1 左（外）连接的语法

例如，我们想把`t1`表和`t2`表进行左外连接查询：

```sql
select * from t1 left [outer] join t2 on 连接条件 [where 普通过滤条件];
```

`outer`关键字是可以省略的。对于`left join`类型的连接来说，放在左边的表被称为「外表」或「驱动表」，右边的表被称为「内表」或「被驱动表」。所以上面的例子中，`t1`就是驱动表，`t2`是被驱动表。

对于左连接和右连接来说，**必须使用`on`子句来指出连接条件。**

把所有的学生的成绩信息都查询出来，即使缺考的考生也被放到结果集中：

```sql
select s1.number, s1.name, s2.subject, s2.score from student as s1 left join score as s2 on s1.number = s2.number;
```

| number   | name | subject  | score  |
| -------- | ---- | -------- | ------ |
| 20230101 | 张三 | 操作系统 | 88     |
| 20230101 | 张三 | 数据结构 | 78     |
| 20230102 | 李四 | 操作系统 | 98     |
| 20230102 | 李四 | 数据结构 | 100    |
| 20230103 | 王五 | `null`   | `null` |

虽然`王五`没有对应的成绩记录，但是采用的是`左外连接`，所以仍然把他放到了结果集中，只不过没有的列采用`null`填充。

上面的语句中，没有`where`子句，所以不会过滤掉`s1`表中的记录。

#### 11.2.2 右（外）连接的语法

右连接和左连接的原理是一样的，语法就是把`left`换成`right`：

```sql
select * from t1 right [outer] join t2 on 连接条件 [where 普通过滤条件];
```

只不过驱动表是右边的表。



#### 11.2.3 内连接的语法

内连接和外连接的根部区别就是：在驱动表中的记录不符合`on`子句中的连接条件时不会把该记录加入到最后的结果集。针对内连接，MySQL 提供了很多不同的语法：

```sql
select * from t1 [inner | cross] join t2 [on 连接条件] [where 普通的过滤条件];
```

在 MySQL 中，下面这几种内连接的写法是等价的：

```sql
select * from t1 join t2;
select * from t1 inner join t2;
select * from t1 cross join t2;
select * from t1, t2;
```

推荐使用`inner join`的形式书写内连接。在内连接中，`on`和`where`子句是等价的，所以内连接的`on`可有可无。



连接的本质就是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户。对于内连接来说，就相当于把不符合`on`和`where`子句条件的记录在笛卡尔积中过滤，所以，对于内连接而言，驱动表和被驱动表可以互换。

但是对于外连接来说，由于驱动表中的记录 即使在被驱动表中找不到 符合`on`子句条件的记录时 也要将其加入到结果集，此时驱动表和被驱动表的关系就很重要了。





### 11.3 连接的原理

为什么有的连接查询运行很快，有的很慢。



#### 11.3.1 嵌套循环连接（Nested-Loop Join）

对于两表连接而言，「驱动表」只会被访问一遍，得到查询结果后，有多少条记录，「被驱动表」就要被访问多少次。

`t1`表和`t2`表执行内连接查询的大致过程：

1.   选择驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法 来执行对驱动表的单表查询
2.   对上一步骤中查询驱动表得到的结果集中的每一条记录，都分别到被驱动表中查找匹配的记录

如果有 3 个表进行连接，那么步骤 2 中得到的结果集就像新的驱动表，而第三个表就成为了新的被驱动表，这个过程就像一个嵌套的循环，这种连接的执行方式被称为「嵌套循环连接（Nested-Loop Join）」。



#### 11.3.2 使用索引加快连接速度

在`嵌套循环连接`的步骤 2 中可能需要多次访问被驱动表，如果访问被驱动表的方式都是全表扫描，很慢。但是可以通过索引来加快查询速度。

例如：

```sql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
```

使用`t1.m1 > 1`查询`t1`表，得到两条记录，「嵌套循环连接算法」需要对被驱动表查询2 次：

-   当`t1.m1 = 2`，查询`t2`表，对`t2`表的查询等价于：

    ```sql
    select * from t2 where t2.m2 = 2 and t2.n2 < 'd';
    ```

-   当`t1.m1 = 3`，再查询一次`t2`表，等价与：

    ```sql
    select * from t2 where t2.m2 = 3 and t2.n2 < 'd';
    ```

可以看到，在针对`t2`表做查询的时候，关于`t1`的条件就已经确定了，所以我们只需单独针对`t2`表进行查询优化即可。

上述两个对于`t2`表的查询语句中利用到的列是`m2`和`n2`列，我们可以：

-   在`m2`列上建立索引，因为对`m2`列的条件是「等值查找」，所以可能使用到`ref`的访问方法，假设使用`ref`的方法去执行对`t2`表的查询，需要回表之后再判断`t2.n2 < 'd'`这个条件是否成立

    这里有一个比较特殊的情况，就是如果`m2`列是`t2`表的「主键」或者「唯一二级索引」，那么使用`t2.m2 = 常数值`这样的条件从`t2`表中查找记录的过程的代价就是常数级别的，被称为`const`,而在「连接查询中对被驱动表使用『主键』或者『唯一二级索引列』的值进行等值查找」的查询执行方式称为`eq_ref`。

-   在`n2`列上建立理所因，涉及到的条件时`t2.n2 < 'd'`，可能使用到`range`的访问方法。

假设`m2`和`n2`列上都存在索引，那么就需要从这两个中挑一个代价更低的去执行对`t2`表的查询。当然，建立了索引不一定使用索引，只有在`二级索引 + 回表`的代价比全表扫描的代价更低时才会使用索引。

建议在真实工作中最好不要使用`*`作为查询列表，最好把真实用到的列作为查询列表，因为可以使用`index`的访问方法来查询被驱动表。



#### 11.3.3 基于块的嵌套循环连接（Block Nested-Loop Join）

扫描一个表的过程首先要把这个表从磁盘加载到内存中，然后从内存中比较匹配条件是否满足。真实环境中有很多几千万上亿条记录的表。内存中可能不能存下表中的所有记录，所以在扫描前面记录的时候，后面的记录可能还在磁盘上，等到扫描后面记录的时候，又因为内存不足，需要把前面的记录从内存中释放。

而采用「嵌套循环连接」短发的两表连接过程中，被驱动表需要被访问很多次，如果这个被驱动表中的数据特别多而且不能使用索引访问，那就相当于要从磁盘上读好几次这个表，IO 代价非常大。所以需要**尽可能减少访问被驱动表的次数**。

做法是：在把「被驱动表」的记录加载到内存的时候，一次性和多条驱动表中的记录做匹配，这样就可以大大减少重复从磁盘上加载「被驱动表」的代价了。

对此，MySQL 使用一个`join buffer`的概念，所谓`join buffer`就是：执行连接查询前申请一块固定大小的内存，先把若干条「驱动表结果集」中的记录放在`join buffer`中，然后开始扫描被驱动表，每一条被驱动表中的记录一次性和`join buffer`中多条驱动表记录做匹配，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的 IO 代价。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230514154254565.png" alt="image-20230514154254565" style="zoom:50%;" />

最好的情况就是 `join buffer` 足够大，能容纳驱动表中的所有记录，这样只需要访问一次「被驱动表」就能完成连接操作了，这种加入了`join buffer`的嵌套循环连接算法被称为`基于块的嵌套连接`(Block Nested-Loop Join)算法。

这个`join buffer`可以通过启动参数或者系统变了进行设置，默认是`256KB`。

>   Tips:
>
>   需要注意的是，驱动表的记录并不是所有列都会被放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中，所以不要把`*`作为查询列表。



## 12. MySQL 基于成本优化

### 12.1 什么是成本

MySQL 执行一个查询可以有不同的执行方案，它会选择其中成本最低的方案去执行查询，MySQL 中一条查询语句的成本由两方面组成：

1.   IO 成本

     `MyISAM`,`InnoDB`存储引擎都是将数据和索引存储到磁盘上的，当想查询表中的记录时，需要先把数据或索引加载到内存中然后再操作。从磁盘到内存的加载过程损耗的时间被称为「IO 成本」。

2.   CPU 成本

     读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等操作的损耗时间被称为「CPU 成本」。

对于`InnoDB`存储引擎来说，「页」是磁盘和内存之间交互的基本单位，MySQL 规定读取一个「页」的成本默认是`1.0`，读取以及检测一条记录是否符合搜索条件的成本默认是`0.2`，这些数字被称之为`成本常数`。



>   Tips:
>
>   不管读取记录时需不需要检测其是否满足搜索条件，成本都被认为是0.2。



### 12.2 单表查询的成本

#### 12.2.1 准备工作

还是`innodb_demo_db`数据库中的`single_table`表，这个表中有 10000 条记录，除`id`列外其余的列都插入随机值。



#### 12.2.2 基于成本的优化步骤

在一条单表查询语句真正执行前，MySQL 的「查询优化器」会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的「执行计划」，之后才会调用存储引擎提供的接口执行真正的查询。总结如下：

1.   根据搜索条件，找出所有可能使用的索引
2.   计算全表扫描的代价
3.   计算使用不同索引执行查询的代价
4.   对比各种执行方案的代价，找出成本最低的一个。



分析这个 SQL 语句：

```sql
select *
from single_table
where key1 in ('a', 'b', 'c')
  and key2 > 10
  and key2 < 1000
  and key3 > key2
  and key_part1 like '%hello%'
  and common_field = '123';
```

##### 1. 根据搜索条件，找出所有可能使用的索引

对于 B+树索引来说，只要索引列和常数之间使用`=`,`<=>`,`in`,`not in`,`is null`,`is not null`,`>`,`<`,`>=`,`<=`,`between`,`!=`,`like`连接起来，就可以产生一个所谓的`范围区间`(`like`匹配字符串前缀也可以)，也就是说这些搜索条件都有可能使用到索引，一个查询中可能使用到的全部索引被称为`possible keys`。

我们分析一下上面查询中涉及到的几个搜索条件：

-   `key1 in ('a', 'b', 'c')`，这个搜索条件可以使用二级索引`idx_key1`。
-   `key2 > 10 and key2 < 1000`，这个搜索条件可以使用二级索引`idx_key2`
-   `key3 > key2`，没有使用到索引
-   `key_part1 like '%hello%'`，没有匹配字符开头，也不能使用索引
-   `common_field = '123'`，这个列没有索引

所以，这个查询语句的`possible keys`是`idx_key1`和`idx_key2`。



##### 2. 计算全表扫描的代价

对于`InnoDB`存储引擎来说，全表扫描的意思就是把聚簇索引中的记录都依次和给定的搜索条件比较，然后把符合条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜索条件。

查询成本 = IO 成本 + CPU 成本，所以计算全表扫描的代价需要两个信息：

-   聚簇索引占用的页面数
-   该表中的记录数

关于这些信息，MySQL为每个表维护了一系列的`统计信息`,可以使用`show table status`语句来查看：

```sql
SHOW TABLE STATUS LIKE 'single_table';

```
| | |
| :- | :- |
| **Name** | single\_table |
| **Engine** | InnoDB |
| **Version** | 10 |
| **Row\_format** | Dynamic |
| **Rows** | 3495 |
| **Avg\_row\_length** | 107 |
| **Data\_length** | 376832 |
| **Max\_data\_length** | 0 |
| **Index\_length** | 458752 |
| **Data\_free** | 0 |
| **Auto\_increment** | 3511 |
| **Create\_time** | 2023-05-07 16:18:24 |
| **Update\_time** | NULL |
| **Check\_time** | NULL |
| **Collation** | utf8\_general\_ci |
| **Checksum** | NULL |
| **Create\_options** |  |
| **Comment** |  |



我们关心的两个统计信息：

-   `Rows`：3495,表示表中的记录条数，对于使用`MyISAM`存储引擎的表来说，这个值是准确的，对于使用`InnoDB`存储引擎的表来说，该值是一个估计值。

-   `Date_length`：表示表占用的存储空间字节数，对于使用`MyISAM`存储引擎的表来说，这个值就是数据文件的大小，对于使用`InnoDB`存储引擎的表来说，该值就相当于聚簇索引占用的存储空间的大小，也就是 等于`聚簇索引的页面数量 × 每个页面的大小`。

    默认每个「页」的大小是 16KB，上表的`Data_length`为`376832`，所以聚簇索引的页面数为`376832 / 16/ 1024 = 23`.

这样就得到了聚簇索引占用的页面数量以及该表记录数的估计值，这样就可以计算全表扫描的成本了：

-   IO 成本：

    ```ini
    23 × 1.0 + 1.1 = 24.1
    ```

    23 是聚簇索引的页面数，1.0 是加载一个页面的成本常数，1.1 是微调。

-   CPU 成本：

    ```ini
    3495 × 0.2 + 1.0 = 700.0
    ```

    3495在 InnoDB 中是记录数的估计值，0.2 是访问一条记录的成本常数，1.0 是微调。

-   扫描全表的总成本：`724.1`

>   Tips:
>
>   这个成本的计算很简单粗暴。



##### 3. 计算使用不同索引执行查询的代价

从第一步的分析可以得知，上述查询可能使用`idx_key1`和`idx_key2`这两个索引，我们需要分别分析单独使用这些索引执行查询的成本，最后还要分析是否可能使用到索引合并。

需要注意的是，MySQL 的查询优化器 会先分析使用唯一二级索引的成本，再分析使用普通索引的成本。

##### 4. 使用`idx_key2`执行查询的成本分析

`idx_key2`对应的搜索条件是：`key2 > 10 and key2 < 1000`，也就是说对应范围区间就是`(10, 1000)`，使用`idx_key2`搜索:

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230527091953643.png" alt="image-20230527091953643" style="zoom:50%;" />

对于使用`二级索引 + 回表`方式的查询，计算成本依赖主要依赖两个方面：

-   范围区间数量


    不论某个范围内的二级索引到底占了多少页面，查询优化器都简单认为读取索引的一个范围的 IO 成本和 读取一个页面是相同的，所以访问这个范围区间的二级索引付出的 IO 成本就是：

    ```
    1 × 1.0 = 1.0
    ```

-   需要回表的记录数

    优化器需要计算二级索引
