# MySQL 索引

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230828173137286.png" alt="image-20230828173137286" style="zoom:50%;" />



## 1. 什么是索引

「索引」是帮助存储引擎快速获取「数据」的一种「数据结构」，「索引」就是「数据」的目录。

所谓的「存储引擎」，就是「如何存储数据」、「如何为存储的数据建立索引」、「如何更新」、「查询数据」等技术的「**实现**」。

索引和数据位于「存储引擎」中：

<img src="https://cdn.xiaolincoding.com//mysql/other/1623727651911_20170928110355446.png" style="zoom:100%;" />

## 2.索引的分类

可以从四个角度对索引进行分类：

-   按「数据结构」分类：**B+Tree索引、Hash索引、Full-text索引**。
-   按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）。**
-   按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**
-   按「字段个数」分类：**单列索引、联合索引。**

### 2.1  按物理存储分类

从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。他们都可以使用 B+树索引。

-   主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
-   二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

InooDB 是MySQL5.5之后的默认「存储引擎」。B+树索引也是 MySQL 存储引擎采用的最多的索引类型。

在创建表的时候，InnoDB 存储引擎会根据不同的场景选择不同的列作为聚簇索引：

-   如果有主键，默认会使用主键作为「聚簇索引」的「索引键」（key）；
-   如果没有主键，就会选择「第一个不包含 NULL 值的唯一列」作为聚簇索引的索引键
-   如果都没有，则 InnoDB 会自动生成一个隐式自增id 列作为聚簇索引的索引键



### 2.2 按数据结构分类

从「数据结构」来看，MySQL 常见的索引有「B+树索引」、「Hash 索引」、「Full-text 索引」。

常见引擎支持的索引类型：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230828113825938.png" alt="image-20230828113825938" style="zoom:40%;" />

#### 聚簇索引的 B+树

其他索引都属于「辅助索引」，也被称为「二级索引」或者「非聚簇索引」。**创建的主键索引和二级索引默认使用的都是 B+树索引**：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230828135325233.png" alt="image-20230828135325233" style="zoom:40%;" />

-   B+树是一种「多叉树」，**叶子节点存放数据，非叶子节点只存放索引**。同时每个节点里的数据是**按主键顺序存放的**。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成了一个「双向链表」（上图是单项链表，但是实际上是双向链表）。
-   B+树存储千万级别的数据也只需要 3~4 层就可以满足。我们可以把读取一个节点当做一次磁盘 IO 操作，这意味着在千万级别的数据下，查询一个数据磁盘的 IO 也只有 3~4 次。

#### 二级索引的 B+树

主键索引的 B+树 和 二级索引的 B+树区别如下：

-   聚簇索引的 B+树的叶子节点存放的是实际数据，所有完整的「用户记录」都存放在主键索引的 B+树的「叶子节点」里。
-   二级索引的B+树的「叶子节点」存放的是「主键值」，而非实际数据

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230828140806519.png" alt="image-20230828140806519" style="zoom:50%;" />

注意上图中叶子节点是单项链表，但是实际上是双向链表。

使用二级索引查询时：

-   会根据二级索引中的索引值，找到B+树对应的叶子节点，然后获取「主键值」。如果要查询的本来就是「主键值」，那么就到此为止了。
-   根据主键值在「聚簇索引」的 B+树找到对应的叶子节点，然后获取整行数据。这个过程称为**回表**。

#### B+树的优点

1.   **B+ 树 VS B树**

     B+树只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+树单个节点的数据量更小。

     同时 B+树的叶子节点采用双链表连接，适合于 MySQL 中常见的「基于范围查找」。

2.   **B+树 VS 二叉树**

     B+树是多叉树，千万级别的数据，B+树也只有 3~4 层，而二叉树则要高出很多，所以查询时二叉树需要经历更多次磁盘 IO

3.   **B+树 VS Hash**

     Hash 在做等值查询的时候时间复杂度为$O(1)$，但是Hash 不适合做范围查询





### 2.3 按字段特性分类

从字段特性来看，索引分为「主键索引」、「唯一索引」、「普通索引」、「前缀索引」。

#### 主键索引

主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列不能有 NULL。语法：

```sql
create table table1(
	....
    primary key(column_name using btree
)
```

#### 唯一索引

「唯一索引」是建立在`unique`字段上的索引，一张表可以有多个「唯一索引」，**索引列必须唯一**，但允许有NULL。

建表时创建唯一索引语法：

```sql
create table table2(
	....
    unique key(column_name1, column_name2, ...)
)
```

建表后创建唯一索引语法：

```sql
create unique index idx_name 
on table1(column_name1, column_name2, ...)
```

#### 普通索引

普通索引就是建立在「普通字段」上的索引，即不要求字段为主键，也不要求字段为`unique`。

建表时创建普通索引的语法：

```sql
create table table3(
	....
    index(column_name1, column_name2,...)
)
```

建表后创建普通索引的语法：

```sql
create index idx_name
on table3(idx1, idx2,...);
```

#### 前缀索引

「前缀索引」指的是只对 「字符类型的前几个字符建立索引」，而不是在整个字段上建立索引，前缀索引可以建立在字段类型为`char, varchar, binary, varbinary`的列上。使用前缀索引可以减少索引占用的存储空间，提升查询效率。

建表时创建前缀索引的语法：

```sql
create table table4(
	...
    index(column_name(length))
)
```

建表后创建前缀索引的语法：

```sql
create index idx_name
on table4(column_name(lenth));
```

### 2.4 按字段个数分类

从字段个数的角度来看，索引分为「单列索引」、「联合索引（复合索引）」。

-   建立在单列上的索引被称为单列索引，例如主键索引
-   建立在多列上的索引被称为联合索引。

```sql
CREATE INDEX index_product_no_name ON product(product_no, name);
```



## 3. 联合索引的最左匹配原则

联合索引是由多个列组成的索引，排序的规则就是 先按左边的列排序，如果相同，则依次向后的列排序。

使用联合索引是，存在「**最左匹配原则**」，也就是按照「最左优先」的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，「联合索引」会失效。

### 3.1 等值查询

例如，创建一个`(a, b, c)`的索引，下面的语句都可以匹配上联合索引：

-   `where a = 1;`
-   `where a = 1 and b = 2 and c = 3`

同时，有「查询优化器」的存在，所以`where`子句的顺序并不重要，如果是下面这几种，则不符合最左匹配原则，联合索引会失效：

-   `where b = 2`
-   `where c = 3`

**b 和 c 列是全局无序，局部有序的，**所以在没有遵循最左匹配原则的情况下，联合索引失效。只有当 a 相同的情况下，b 才是有序的。



### 3.2 范围查询

在「范围查询」的情况下，可能存在**只有部分字段使用了联合索引的 B+树**。

#### a > 1 and b = 2

```sql
select * from t_table where a > 1 and b > 2;
```

**上述查询语句，联合索引`(a,b)`哪一个字段使用到了联合索引的 B+树？**

a 字段用到了联合索引，b 字段没有。因为在符合`a>1`条件的「二级索引记录」的范围里，b 字段的值是无序的。

| a    | 1    | 2    | 2    | 2    | 3    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| b    | 1    | 3    | 4    | 5    | 0    |

例如上表，当我们使用`a = 2 and b = 4`的查询语句的时候， 先扫描找到`a = 2`的范围（在这次扫描中，是没有管 `b`字段的），当扫描到`a= 3`时证明找到右边界了，停止扫描，然后依次对`b`字段也扫描，然后找到对应的主键并回表。

但是我们使用`a > 2 and b = 4`时：

-   先对 `a`字段扫描，定位到 `a>2`满足的第一条记录，然后扫描直到不满足`a>2`。
-   得到的结果中的 b 字段是无序的，无法直接扫描出边界范围。比如我们扫描到 b=5 时，如果 b 有序，就可以不用扫描了，但是在这里不行。所以没有用到 B+树有序的特性，采用的是暴力查找。

#### a >= 1 and b = 2

对`a`字段扫描，得到`a>=1`的所有记录，这些记录可以分为两个部分：`=a`和`>a`，对于前者，b字段有序，可以通过`b=2`**减少**需要扫描的二级索引的范围（也就是利用联合索引查询）。但是后者还是要从`a>1`范围的第一个扫描到最后一个。

所以这两个字段都用到了联合索引进行查询。

#### a between 2 and 8 and b = 2

对于 MySQL 而言，between 是左闭右闭的区间，所以同上。

#### name like 'j%' and age = 22

对于`name`字段，扫描的是`['j', 'k')`的区间，所以减少了扫描次数，用到了联合索引。而对于`age = 22`。符合`j%`的记录中，age 是无序的，但是对于单独的`name = 'j'`，age 是有序的，所以都用到了联合索引进行查询。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230828161553077.png" alt="image-20230828161553077" style="zoom:50%;" />



>   所以能不能用到联合索引，需要分析是不是可以减少扫描的次数。这个规律可以总结为「最左匹配」原则。联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引

### 3.3 索引下推

对于联合索引`(a,b)`，执行`select * from t1 where  a > 1 and b = 2;`语句时，只有 a 字段能用到索引，在联合索引的 B+树中找到第一个满足主键值（a>1的第一个字段）之后，判断其他条件（b=2）是在联合索引里判断还是回主键索引中判断呢？

-   在 MySQL5.6 之前，只能在主键索引中回表，如果满足第一个条件的记录很多，则回表数据也很多。
-   MySQL5.6 之后，引入了「索引下推优化」，可以在联合索引遍历的过程中，对联合索引中包含的字段也判断，直接过滤掉不满足条件的记录，这样可以减少回表的次数。



### 3.4 索引区分度

区分度就是某个字段「不同值的个数」除以「表的总行数」：
$$
区分度 = \frac{\operatorname{distinct}(\operatorname{column})}{\operatorname{count}(*)}
$$
比如，性别的区分度就很小，而 UUID 区分度就很高。

在建立联合索引的时候，我们尽量把「区分度」大的字段放在前面。例如性别，如果建立索引，扫描一次会有大量记录，还不如不要，MySQL 的查询优化器如果发现某个值在表的记录中占比很高（一般是 30%），会忽略索引，进行全表扫描。



### 3.5 order by和联合索引

针对下面这条 SQL，如何通过索引来提高查询效率？

```sql
select * from order where id = 1 order by create_time asc;
```

答案是：给「id+create_time」列建立联合索引，这样根据`id=1`筛选出来的数据就是有序的，而如果只给`id`列（字段）建立索引，还需要对`create_time`进行排序。

## 4. 索引的创建与否

索引最大的好处就是提高查询速度，但是索引也是有缺点的：

-   需要占用物理空间
-   创建索引和维护索引需要耗费时间，这种时间随着数据量增加而增大
-   会降低表「增删改」的效率，因为每次「增删改」索引，B+树都要动态维护



### 4.1 什么时候适用索引

-   字段具有唯一性，例如商品编码
-   经常用于`where`查询条件的字段
-   经常用于`group by`和`order by`的字段，这样查询的时候就可以减少排序



### 4.2 什么时候不要创建索引

-   `where, group by, order by`中用不到的字段，索引的价值是快速定位，此时不要建立索引浪费空间
-   字段存在大量重复，也就是字段的区分度低
-   表数据太少的时候
-   经常更新的字段不用创建索引，因为需要维护 B+树



## 5. 索引的优化

常见的优化索引的方法：

-   前缀索引优化
-   覆盖索引优化
-   主键索引最好是自增的
-   防止索引失效

### 5.1 前缀索引优化

前缀索引就是使用某个字段中字符串的前几个字符建立索引。

**优点：**

-   减少索引字段的大小，可以增加一个索引页中存储的索引值，提高查询效率。

**缺点：**

-   order by 无法使用前缀索引
-   无法把前缀索引用作索引覆盖



### 5.2 覆盖索引优化

如果我们需要通过`a`字段查询`b`字段和`c`字段，那么我们可以把`abc`作为一个联合索引，这样可以避免回表。

### 5.3 主键最好是自增的

InnoDB 会创建主键索引默认作为聚簇索引，数据被存放在了 B+树的叶子节点上。如果自增，则每次都插入在最后，如果不是自增，则会插入某个位置，后者会导致「页分裂」。

另外，主键字段的长度也不要太大，因为「二级索引」的叶子节点会存「主键字段」。



### 5.4 索引最好设置为 NOT NULL

为了更好地利用索引，索引列要设置为 NOT NULL 约束：

-   第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
-   第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中**至少会用 1 字节空间存储 NULL 值列表**

## 6. 索引失效

### 6.1 explain

查看执行计划，参数有：

-   `possible_keys`字段表示可能用到的索引
-   `key`字段表示实际使用的索引，如果为`NULL`，则证明没有使用索引。
-   `key_len`字段表示索引的长度
-   `rows`表示扫描的数据行数
-   `type`表示扫描的类型，常见的扫描类型的执行效率从低到高的顺序为：
    -   `ALL`表示全表扫描
    -   `index`表示全索引扫描
    -   `range`表示索引范围扫描
    -   `eq_ref`表示唯一索引扫描
    -   `const`表示「结果只有一条    的主键或唯一索引扫描」

### 6.2 索引的存储结构

索引的存储结构和 MySQL 使用哪种存储引擎有关，因为存储引擎的功能之一就是实现把数据持久化在磁盘中，而不同的存储引擎采用的「索引数据结构」也不相同。

MySQL 默认的存储引擎是 InnoDB，它采用 B+树 作为索引的数据结构。而 MyISAM 存储引擎支持多种索引数据结构，例如「B+树索引」、「R 树索引」、「Full-Text」索引。MyISAM 创建表时，创建的主键索引默认就是 B+树索引。

InnoDB 和 MyISAM中 B+树索引的区别：

-   InnoDB 存储引擎：B+树索引的叶子节点保存的是数据本身
-   MyISAM 存储引擎：B+树索引的叶子节点保存的是「数据的物理地址」。



### 6.3 对索引使用左或者左右模糊匹配

这个不多说了，在 3.2 中有。

### 6.4 对索引使用函数

如果「查询条件」中对索引字段使用函数，就会导致索引失效：

```sql
// name 为二级索引
select * from t_user where length(name)=6;
```

因为索引保存的是索引字段的原始值，而不是函数计算后的值，所以不能走索引。

不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据，给「函数计算后的字段」加索引的语法：

```sql
alter table t_user add key idx_name_length(length(name));
```

### 6.5 对索引进行表达式计算

例如：

```sql
 select * from t_user where id + 1 = 10;
```

与 6.4 同理，索引保存的不是计算之后的值。



### 6.6 对索引隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。例如`phone`是`varchar`类型，同时也是二级索引。

```sql
select * from t_user where phone = 1300000001;
```

上述语句不会走索引。但是如果 id 是`int`，将它隐式转换为字符串类型：

```sql
select * from t_user where id = '1';
```

**上述语句可以走二级索引。MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。**



### 6.7 联合索引最左匹配原则

见 第三章。

>   但是有一种特殊情况，那就是如果除了主键，其余所有的字段共同组成了联合索引。
