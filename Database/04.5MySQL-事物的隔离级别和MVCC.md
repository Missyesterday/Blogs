# MySQL 的隔离级别和 MVCC

## 0. 准备

先创建一个表，插入数据：

```sql
create table hero(
    number int,
    name varchar(100),
    country varchar(100),
    primary key (number)
)engine = InnoDB charset = utf8;

insert into hero values(1, '刘备', '蜀');
```



## 1. 事务隔离级别

MySQL 是一个「客户端/服务器」架构的软件，对于同一个服务器而言，可以有多个客户端与之连接，每个客户端和服务器连接上之后，就可以被称为一个「会话（Session）」。每个客户端在自己的「会话」中像服务器发出请求语句。

我们想保持 「事务的隔离性」，又想让服务器处理同一个数据 的多个事务时 性能更高，所以需要舍弃一部分「隔离性」。



### 1.1 事务并发执行遇到的问题

#### 1.1.1 脏写（Dirty Write）

如果一个事务修改了另一个「未提交事务」修改过的数据，那就意味着发生了「脏写」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230806192440725.png" alt="image-20230806192440725" style="zoom:50%;" />

如图`Session A`和`Session B`各开启了一个事务，二者的事务都把 `number`列为`1`的记录的`name`修改了，如果`Session B`把事务进行了回滚，那么`Session A`的中的更新也将不复存在，这种情况被称为「脏写」。`Session A`的事务发现数据更新了，事务也提交了，但是没有任何效果。



#### 1.1.2 脏读（Dirty Read)

如果一个事务读到了「另一个未提交事务」修改过得数据，那就意味着发生了「脏读」，如图：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230806194253397.png" alt="image-20230806194253397" style="zoom:50%;" />

`Session A`和`Session B`各开启了一个事务，B 先修改，A 读，然后 B 回滚了，相当于`Session A`读到了一个不能存在的数据，这种情况被称为「脏读」。



#### 1.1.3 不可重复读（Non-Repeatable Read)

如果一个事务只能读到另一个「已经提交的事务」修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询到最新值，那就意味着发生了「不可重复读」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230806204711919.png" alt="image-20230806204711919" style="zoom:50%;" />

注意`update`会隐式提交事务。每次修改事务提交之后，Session A 中的事务都可以查看到最新的值。



#### 1.1.4 幻读（Phantom）

如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些调价你的记录，原先的事务再次按相同的条件查询时，能把另一个事务插入的记录也读出来，被称为「幻读」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230806205212156.png" alt="image-20230806205212156" style="zoom:50%;" />

需要注意的是，如果 Session B 删除了先前查询出来的记录，不属于「幻读」，而是属于「不可重复读」。「幻读」强调之前没有获取到的记录。



### 1.2 SQL 标准中的四种隔离级别

并发事务执行的过程中，会遇到上面的问题，这些问题也有 缓急 之分，我们给这些问题按严重性排序：

```sql
脏写 > 脏读 > 不可重复读 > 幻读
```

所以`SQL标准`中，设立了四个「隔离级别」：

-   READ UNCOMMITTED：未提交读
-   READ Committed：已提交读
-   REPEATABLE READ：可重复读
-   SERIALIZABLE：可串行化



`SQL标准`中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

| 隔离级别           | 脏读         | 不可重复读   | 幻读         |
| ------------------ | ------------ | ------------ | ------------ |
| `READ UNCOMMITTED` | Possible     | Possible     | Possible     |
| `READ COMMITTED`   | Not Possible | Possible     | Possible     |
| `REPEATABLE READ`  | Not Possible | Not Possible | Possible     |
| `SERIALIZABLE`     | Not Possible | Not Possible | Not Possible |

任何隔离级别，都不允许「脏写」。

### 1.3 MySQL 中支持的四种隔离级别

不同数据库厂商对于`SQL标准`中规定的四种隔离级别支持不同，MySQL 虽然支持四种隔离级别，但是和`SQL标准`规定的四种隔离级别有些出入。



#### 1.3.1 

MySQL 的默认隔离级别为`REPEATABLE REDA`，