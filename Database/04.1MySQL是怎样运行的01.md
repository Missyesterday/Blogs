

# MySQL是怎样运行的01

## 1. 重新认识MySQL

-   启动`MySQL`服务器的进程默认名为`mysqld`，`MySQL`客户端进程默认名为`mysql`。



### 1.1 MySQL的安装和路径

macOS和Linux下MySQL的安装目录是：

```bash
/usr/local/mysql/
```

#### 1.1.1 bin目录下的可执行文件

`MySQL`的安装目录下有一个`bin`目录，存放的是「许多可执行文件」，可以把这个路径设置为环境变量`PATH`。

`PATH`的值表示：<u>当输入一个命令的时候，系统会从这些目录下搜索是否存在我们输入的命令，如果存在就执行目录下的可执行文件。</u>把`MySQL`安装目录下的`bin`目录添加到`PATH`中，就可以直接使用`mysqld`而不是`/usr/local/mysql/mysqld`了。



### 1.2 启动MySQL服务器程序

#### 1.2.1 类UNIX系统中的启动服务器程序

大部分`MySQL`安装目录在`bin`目录下：

**mysqld**

`mysqld`可执行文件代表`MySQL`服务器程序，运行这个文件就可以直接启动一个服务器进程。但是它不常用。

**mysqld_safe**

`mysqld_safe`是一个启动脚本，它会间接调用`mysqld`，同时还启动了另外一个监控进程。这个监控进程在服务器进程挂了的时候，可以帮助重启；同时，它还会将服务器程序的「出错信息」和「其他诊断信息」重定向到某个文件中，产生出错日志。

**mysql.server**

`mysql.server`也是一个启动脚本，它会间接的调用`mysqld_safe`，在调用`mysql.server`时在后面指定`start`参数可以启动服务器程序，使用`stop`参数可以停止服务器

```bash
mysql.server start
mysql.server stop
```

这个`mysql.server`是一个软链接，它实际指向`../support-files/mysql.server`



### 1.3 启动MySQL客户端程序

`bin`目录下有许多客户端程序，例如`mysqladmin`,`mysqldump`,`mysqlcheck`等。也可以使用`mysql`启动：

```bash
mysql -h主机名 -u用户名 -p密码
```

| 参数名 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| `-h`   | 表示服务器进程所在的计算机的IP地址（也可以是域名），如果是本机可以省略这个参数 |
| `-u`   | 用户名                                                       |
| `-p`   | 密码，注意`-p`和密码之间不能有空白字符，其他参数可以空格也可以不加空格 |

>   需要注意，「只有一个英文字母的参数」成为「短形式的参数」，使用时前面需要加`-`。而`host`,`user`等大于一个字母的参数称为「长形式的参数」，使用时前面加`--`双短划线



### 1.4 客户端和服务器连接的过程

**客户端向服务器发送请求并获得回复的过程本质上是「进程间的通信」，**`MySQL`支持三种通信方式：

#### 1.4.1 TCP/IP

真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间**必须**通过网络来进行通讯。`MySQL`服务器会默认监听`3306`端口。也可以使用`-P`来指明端口号：

```bash
mysqld -P3307
```

客户端默认连接`3306`端口，如果想要连接其他端口，需要加`-P`参数（注意是大写的`P`，小写的`p`是指定密码的）。

#### 1.4.2 命名管道和共享内存



使用共享内存方式进行通信的客户端进程和服务器进程必须在同一台`Windows`主机中。



#### 1.4.3 Unix域套接字文件

如果服务器进程和客户端进程都运行在同一台`类Unix`的机器上，可以使用`Unix域套接字文件`来进行进程间通信。



### 1.5 服务器处理客户端请求

不管客户端和服务器进程采用哪种方式进行通信，最后的效果都是：

-   **客户端进程向服务器进程发送一段文本（MySQL语句）**
-   **服务器进程处理后向客户端发送一段文本（处理结果）**

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/28/167f4c7b99f87e1c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image" style="zoom:100%;" />

服务器程序处理来自客户端的查询请求，大致需要经过三个部分：

1.   **连接管理**
2.   **解析与优化**
3.   **存储引擎**

#### 1.5.1 连接管理

客户端进程可以采用多种方式向服务器进程建立连接，每一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来处理这个客户端的交互，`MySQL`服务器可能有「类似线程池」的设计，来避免频繁创建和销毁线程。如果连接太多，线程也会很多，会影响系统性能。

当客户端进程发起连接的时候，需要携带「主机信息」、「用户名」、「密码」，服务器会对这些信息进行认证，如果客户端和服务器进程不在同一台计算机上，还可以采用使用了`SSL`（安全套接字）的网络连接来进行通信，来保证数据传输的安全性。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求，`MySQL`服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理。

解析与优化中比较重要的就是：

-   查询缓存
-   语法解析
-   查询优化

#### 1.5.2 解析与优化之查询缓存

`MySQL`会将刚刚处理过的查询请求和结果「**缓存**」起来，如果有相同的请求，直接从缓存中查询结果就好了。**这个「查询缓存」可以在不同的客户端之间共享。**

但是，如果两个查询请求在任何字符上的不同（如：空格、注释、大小写），都会导致缓存不命中。另外，如果查询请求中包含「某些系统函数」、「用户自定义变量和函数」、「一些系统表」（如：`mysql`,`information_schema`,`performance_schema`数据库中的表），那么这个请求就不会被缓存。

-   例如系统函数`NOW`，两次调用的结果不同，所以不能用缓存。



**缓存失效：**MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，例如使用了`INSERT`,`UPADTE`等语句，那么这个表**所有的**高速缓存查询都将变为无效，并从高速缓存中删除。

>   Tips：
>
>   查询缓存会有维护的开销，从MySQL5.7.20开始不推荐使用查询缓存，并在MySQL8.0中删除



#### 1.5.3 解析与优化之语法解析

如果查询缓存没有命中，那么就需要进入正式的查询阶段了，本质上是一个编译过程。

#### 1.5.4 解析与优化之查询优化

自己写的`MySQL`语句执行起来效率可能不是很高，`MySQL`的优化程序会对`MySQL`语句进行一些优化，可以使用`EXPLAIN`语句来查看某个语句的执行计划。



#### 1.5.5 存储引擎

`MySQL`服务器把数据的存储和提取操作都「封装」到了一个叫「存储引擎」的模块中。所谓「表格」，是由一行一行的记录组成的，但这只是一个**逻辑上的概念**，物理上怎么表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是「存储引擎」负责的事情，`MySQL`提供了多种「存储引擎」，不同「存储引擎」管理的表具体的存储结构可能不同，采用的存储算法也不同。

>   在以前，「存储引擎」被称为「表处理器」，它的功能就是接收上层传下来的指令，如何对表中的数据进行提取或写入操作。

为了管理方便，我们把「连接管理」、「查询缓存」、「语法解析」、「查询优化」这些不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为「存储引擎」的功能。各种不同的存储引擎向上层的`MySQL server`层提供**统一的调用接口**（也就是存储引擎API），包含了几十个底层函数，例如「读取索引第一条内容」、「读取索引下一条内容」、「插入记录」等。

所以，在`MySQL server`完成了查询优化后，只需要按照生成的「执行计划」调用底层「存储引擎」提供的API，获取到数据后返回给客户端就好了。



### 1.6 常用存储引擎

`MySQL`有非常多的存储引擎：

| 存储引擎 | 简述                                   |
| -------- | -------------------------------------- |
| ARCHIVE  | 用于数据存档（行被插入后不能再被修改） |
| BLACKHLE | 丢弃写操作，读操作会返回空内容         |
| CSV      | 存储数据时，用`,`分割各个数据项        |
| InnoDB   | 具备外键支持功能的事务存储引擎         |
| MEMORY   | 置于内存的表                           |
| MyISAM   | 主要的非事务处理存储引擎               |

还有很多存储引擎。但是最常用的是`InnoDB`和`MyISAM`，偶尔会提到`Memory`。其中`InnoDB`是`MySQL`的默认存储引擎。



#### 1.6.1 查看当前服务器程序支持的存储引擎

可以使用`SHOW ENGINES;`来查看当前服务器支持的存储引擎

```bash
mysql> SHOW ENGINES;
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
9 rows in set (0.01 sec)
```

其中，`Transactions`代表是否支持事物处理，`XA`代表是否支持「分布式事务」，`Savepoints`代表是否支持部分事务回滚。



#### 设置表的存储引擎

1.   创建表时指定存储引擎：

     ```sql
     CREATE TABLE 表名
     (
     	建表语句;
     ) ENGINE = XXX;
     ```

     其中XXX代表存储引擎，可以是`MyISAM`等。

2.   修改表的存储引擎：

     ```sql
     ALTER TABLE 表名 ENGINE = 存储引擎名称;
     ```



## 2. 启动选项和系统变量

`MySQL`的客户端和服务器有很多设置项，例如对于`MySQL`服务器，可以指定「允许同时联入的客户端数量」、「客户端和服务器的通信方式」、「表的默认存储引擎」、「查询缓存的大小」等。对于`MySQL`客户端，可以设置「需要连接的服务器程序所在主机的主机名或IP地址」、「用户名和用户密码」等信息。

这些设置一般都有默认值，也可以在启动时放在命令行中指定，也可以放在配置文件中指定。



### 2.1 在命令行上使用选项

在服务器端使用`skip-networking`启动选项，可以禁止客户端使用`TCP/IP`网络进行通信：

```bash
mysqld --skip-networking
```

>   `skip-networking`和`skip_networking`是等价的。



在服务端使用`--default-storage-engine=XX`可以在启动时指定默认的存储引擎：

```sql
mysqld --default-storage-engine=MyISAM
```

>   注意，`=`左右两边不可以有空格。

### 2.2 在配置文件中使用选项

我们可以把需要设置的启动选项写在一个配置文件中，这样只需要配置一次，不用每次都显式的把启动选项写在命令行中，所以推荐使用这种方式。



#### 2.2.1 配置文件的路径

在类UNIX操作系统中，MySQL会按照下列路径来寻找配置文件：

| 路径名                | 备注                                 |
| --------------------- | ------------------------------------ |
| `/etc/my.cnf`         |                                      |
| `/etc/mysql/my.cnf`   |                                      |
| `SYSCONFDIR/my.cnf`   |                                      |
| `$MYSQL_HOME/my.cnf`  | 特定于服务器的选项（仅限于服务器）   |
| `defaults-extra-file` | 命令行指定的额外配置文件路径         |
| `~/.my.cnf`           | 用户特定选项                         |
| `~/.mylogin.cnf`      | 用户特定的登陆路径选项（仅限客户端） |

-   `SYSCONFDIR`表示在使用`CMake`构建`MySQL`时使用`SYSCONFDIR`选项指定的目录。默认情况下，这是位于编译安装目录下的`etc`目录

-   `MYSQL_HOME`是一个环境变量，可以自己设置，这个「变量的值」代表一个路径。这个路径下的`my.cnf`只能放关于服务器启动相关的选项。没有特殊说明的配置文件既能存放服务器相关的选项也能存放客户端相关的选项。

    如果使用`mysqld_safe`启动服务器程序，这个环境变量的值将被设置为`MySQL`的安装目录。

-   我们在启动程序时可以通过指定`defaults-extra-file`参数的值来添加额外的配置文件路径。（extra代表「额外」的意思）

-   `.mylogin.cnf`有些特殊，它不是一个纯文本文件（其他的配置文件都是纯文本文件），而是使用`mysql_config_editor`实用程序创建的加密文件。文件中只能包含一些用于启动客户端软件时连接服务器的一些选项，包括 `host`、`user`、`password`、`port`和 `socket`。而且它只能被客户端程序所使用。

    有专门的语法来修改这个文件。

#### 2.2.2 配置文件的内容

```ini
[server]
option1
option2 = value
(具体的启动选项...)

[mysqld]
(具体的启动选项...)

[mysqld_safe]
(具体的启动选项...)

[client]
(具体的启动选项...)

[mysql]
(具体的启动选项...)

[mysqladmin]
(具体的启动选项...)
```

配置文件中的启动项被划分成若干个组，每个组有一个组名，用`[]`中括号括起来，例如上面的配置文件就定义了很多个组，组名分别是：`server`,`mysqld`,`mysqld_safe`等。

`option1`代表没有赋值，`option2`代表可以指定，同时`=`左右可以出现空格。

配置文件中不同的选项组，是给不同的启动命令使用的：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230429152458316.png" alt="image-20230429152458316" style="zoom:50%;" />

如果在`/etc/mysql/my.cnf`这个配置文件中写：

```ini
[server]
skip-networking
default-storage-engine=MyISAM
```

重启MySQL后，不能用TCP/IP连接，远程连接连不上了；同时默认的存储引擎变为`MyISAM`。

我们可以在选项组的名称后加上特定的`MySQL`版本号，比如对于`[mysqld]`选项组来说，我们可以定义一个`[mysqld-5.7]`的选项组，它的含义和`[mysqld]`一样，只不过只有版本号为`5.7`的`mysqld`程序才能使用这个选项组中的选项。



#### 2.2.3 配置文件的优先级

`MySQL`会按照前面的表依次读取各个配置文件，如果不存在则忽略，同时后面的配置会**覆盖**前面的配置。

同时，同一个文件中的同一个组，如果有同样的配置项，也是以「最后一个出现」的启动选项为准。



如果不想让`MySQL`到默认的路径下搜索配置文件，可以在命令行指定`defaults-file`选项：

```bash
mysqld --defaults-file=/tmp/myconfig.txt
```

那么程序启动的时候，**只会**在`/tmp/myconfig.txt`路径下搜索配置文件。很显然，这个启动选项只能在命令行中使用。

如果配置文件和命令行冲突，以命令行为准。

### 2.3 系统变量

#### 2.3.1 系统变量简介

`MySQL`服务器运行的时候会用到许多影响程序行为的变量，它们被称为「`MySQL`系统变量」，比如：

-   `max_connections`：表示允许同时连入的客户端数量
-   `default_storage_engine`：表示默认存储引擎
-   `query_cache_size`：表示查询缓存大小
-   等等，共有几百条

每个系统变量都有默认值，也可以使用「命令行」或「配置文件」的选项在启动的时候修改一些系统变量。大多数的系统变量的值也可以在程序运行的过程中修改，而不需要停止并重新启动它。



#### 2.3.2 查看系统变量

查看`MySQL`服务器支持的系统变量和当前的值：

```mysql
show variables [like 匹配的模式];
```

`[]`中括号代表中间的内容可有可无。可以使用`like`的过滤条件来查看系统变量的值。例如：

```sql
mysql> show variables like 'default_storage_engine';
+------------------------+--------+
| Variable_name          | Value  |
+------------------------+--------+
| default_storage_engine | MyISAM |
+------------------------+--------+
1 row in set (0.01 sec)

mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

-   当前默认存储引擎为：MyISAM
-   当前最多允许151条客户端连接

也可以使用通配符模糊查询：

```sql
show variables like 'default%';
```



#### 2.3.3 设置系统变量

大部分的「系统变量」可以使用命令行和配置文件设置。需要注意，对于启动选项来说`_`和`-`是一样的，但是对应的系统变量单词必须使用`_`下划线，所以可以统一使用`_`。



**服务器程序运行过程中设置：**

大部分的系统变量的值可以在服务器程序运行的时候动态修改，而无需重启服务器，但是系统变量有「作用范围」之分。



**设置不同范围的系统变量：**

多个客户端程序可以同时连接到同一个服务器程序。如果对于同一个系统变量，我们希望让不同的客户端有不同的值，这样使用时很方便，但是每个客户端都私有一份系统变量会存在两个问题：

-   有一些系统变量不是针对单个客户端的，例如`max_connections`最大客户端连接数量 和 `query_cache_size`最大缓存大小，这样公共的系统变量让某个客户端私有并不合适。
-   一个新连接到服务器的客户端对应的系统变量的值如何设置。

所以，`MySQL`提出了「系统变量」的「作用范围」的概念，具体来说，「作用范围」分为：

-   `GLOBAL`：全局变量，影响服务器的整体操作
-   `SESSION`：会话变量，影响某个客户端连接的操作。（`SESSION`有个别名叫：`LOCAL`）

在服务器启动时，会将每个全局变量初始化为默认值（可以通过命令行和配置文件修改）。同时，服务器还为每个连接的客户端维护一组「会话变量」，客户端的会话变量在连接的时候使用「相应的全局变量」的当前值初始化。

通过启动选项设置的系统变量的作用范围都是`GLOBAL`的，也就是对所有客户端都有效。如果客户端想在服务器运行期间修改系统变量，可以使用：

```sql
set [GLOBAL|SESSION] 系统变量名 = 值;
```

如果省略作用范围，默认的作用范围就是`SESSION`。

如果想把「作用范围为`GLOBAL`的系统变量`default_storage_engine`」的值修改为`MyISAM`，也就是让之后连接到服务器的客户端都用`MyISAM`作为默认的存储引擎，可以用：

```sql
set global default_storage_engine = MyISAM;
#或者
set @@global default_storage_engine = MyISAM;
```

注意修改某个系统变量在`GLOBAL`作用范围的值，不会影响当前已经连入的客户端，只会影响新联入的客户端。

如果只想对本客户端生效，可以使用：

```sql
set session default_storage_engine = MyISAM;
#或者
set @@session default_storage_engine = MyISAM;
#或者
set default_storage_engine = MyISAM;
```



#### 2.3.4 查看不同作用范围的系统变量

`show variables`默认查看的是「`SESSION`作用范围的系统变量」。

如果想加上「作用范围」，可以使用：

```sql
show [global|session] variables [like 匹配模式];
```



#### 2.3.5 注意事项

-   并不是所有的系统变量都有`GLOBAL`和`SESSION`的作用范围：
    -   例如`max_connections`表示服务器最多支持多少个客户端同时连接，只有`GLOBAL`范围
    -   `insert_id`只有`SESSION`的作用范围，它表示对某个包含`AUTO_INCREMENT`的列进行插入时，该列初始的值。
    -   大多数系统变量都有`GLOBAL`和`SESSION`的作用范围
-   有些系统变量是只读的，不能设置值：
    -   例如`version`表示当前`MySQL`的版本，它不能被修改。

### 2.4 状态变量

`MySQL`服务器进程还维护了许多关于程序运行状态的变量，用来让用户更好地了解服务器程序的运行情况，这些变量被称为「**状态变量**」，例如：

-   `Threads_connected`表示当前有多少客户端与服务器建立了连接
-   `Handler_update`表示已经更新了多少行记录
-   等等

「状态变量」只能被服务器程序设置，不能自己修改，与「系统变量」类似，「状态变量」也有`GLOBAL`和`SESSION`两种作用范围，所以查看「状态变量」的语句可以这么写：

```sql
show [global|session] status [like 匹配模式];
```

默认显示`SESSION`的范围，例如：

```sql
mysql> show status like 'thread%';
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_cached    | 0     |
| Threads_connected | 2     |
| Threads_created   | 2     |
| Threads_running   | 1     |
+-------------------+-------+
4 rows in set (0.00 sec)
```



## 3. 字符集和比较规则

### 3.1 字符集简介

计算机存储的都是二进制数据，存储字符需要**建立字符与二进制数据的映射关系**，需要注意：

-   界定字符范围
-   如何映射
    -   把字符映射成二进制数据称为「编码」，把二进制数据映射为字符称为「解码」

于是，「**字符集**」的概念被抽象出来，这个概念用来描述「某个字符范围的编码规则」。

英文字母只有26个，但是汉字有几万个。

#### 3.1.1 一些重要的字符集

常用的字符集有：

-   `ASCII`字符集：

    收录了128个字符，用一个字节进行编码：

    ```rust
    'L' ->  01001100（十六进制：0x4C，十进制：76）
    'M' ->  01001101（十六进制：0x4D，十进制：77）
    ```

-   `ISO 8859-1`字符集：

    共收录256个字符，在`ASCII`基础上又增加了西欧常用字母，也可以用1个字节进行编码。这个字符集还有一个别名：`latin1`

-   `GB2312`字符集：

    还有汉字、日文平假片假名、拉丁字母等。兼容`ASCII`字符集，所以采用「变长编码方式」。

    -   如果该字符在`ASCII`字符集中，则采用1字节编码（0～127）
    -   否则采用2字节编码

-   `GBK`字符集：

    对`GB2312`进行扩充，编码方式上兼容`GB2312`

-   `utf8`字符集：

    收录地球上所有的字符，还在不断扩充。兼容`ASCII`字符集。采用变长编码，编码一个字符需要1～4个字节。

>   Tips:
>
>   严格来说，utf8只是Unicode字符集的一种编码方案，Unicode字符集有utf8、utf16、utf32集中编码方案，utf8使用1～4个字节编码一个字符，utf16使用「2个或4个」字节编码一个字符，utf32使用4个字节编码一个字符。

MySQL中不区分字符集和编码方案的概念，所以utf8、utf16、utf32都被当作同一种字符集对待。



### 3.2 MySQL中支持的字符集和排序规则

#### 3.2.1 MySQL中的utf8和utf8mb4

虽然`utf8`字符集需要使用1～4个字节，但是常用的字符使用1~3个字节表示就可以了。而在MySQL中字符集表示一个字符所用的最大字节长度会在某些方面影响系统的存储和性能，所以MySQL定义了两个概念：

-   `utf8mb3`：阉割过的`utf8`字符集，只使用1~3个字节表示字符
-   `utf8mb4`：正统的`utf8`字符集

同时，在MySQL中，`utf8`是`utf8mb3`的别名，所以MySQL中的`utf8`意味着使用1～3个字节来表示一个字符，如果需要使用4字节编码一个字符的情况，例如存储「emoji表情」，需要使用`utf8mb4`。



#### 3.2.2 字符集的查看

使用`show charset;`可以查看当前`MySQL`支持的字符集：

```sql
show charset;
```

当前我使用的`MySQL`版本一共支持`41`种字符集，同时`Default`列的值为`YES`就代表是该字符集的默认比较规则。



#### 3.2.3 比较规则的查看

使用`show collation [like 匹配模式];`可以查看`MySQL`中支持的比较规则，例如想查看`utf8`字符集下的比较规则：

```sql
mysql> show collation like 'utf8\_%';
+--------------------------+---------+-----+---------+----------+---------+
| Collation                | Charset | Id  | Default | Compiled | Sortlen |
+--------------------------+---------+-----+---------+----------+---------+
| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |
| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |
| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |
| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |
| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |
| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |
| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |
| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |
| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |
| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |
| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |
| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |
| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |
| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |
| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |
| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |
| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |
| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |
| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |
| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |
| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |
| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |
| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |
| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |
| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |
| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |
| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |
+--------------------------+---------+-----+---------+----------+---------+
27 rows in set (0.00 sec)
```



**比较规则的命名规律：**

-   比较规则一般用相关的「字符集」的名称开头

-   后面跟着的是该比较规则主要用于哪种语言，例如`utf8_polish_ci`表示波兰语的比较，`utf8_general_ci`是一种通用的比较规则。

-   名称的后缀意味着是否区分语言中的重音、大小写等：

    <img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230430113421881.png" alt="image-20230430113421881" style="zoom:50%;" />

### 3.3 字符集和比较规则

#### 3.3.1 各级别的字符集和比较规则

`MySQL`有4个级别的字符集和比较规则：

-   服务器级别
-   数据库级别
-   表级别
-   列级别

`CHARACTER SET`和`CHARSET`是同义词，用任意一个都可以。

#### 3.3.2 服务器级别

`MySQL`有两个「系统变量」来表示服务器级别的字符集和比较规则：

-   `character_set_server`：服务器级别的字符集
-   `collation_server`：服务器级别的比较规则

查看一下这两个变量的值：

```sql
mysql> show variables like 'character_set_server';
+----------------------+--------+
| Variable_name        | Value  |
+----------------------+--------+
| character_set_server | latin1 |
+----------------------+--------+
1 row in set (0.01 sec)

mysql> show variables like 'collation_server';
+------------------+-------------------+
| Variable_name    | Value             |
+------------------+-------------------+
| collation_server | latin1_swedish_ci |
+------------------+-------------------+
1 row in set (0.01 sec)

```

这两个值可以修改。



#### 3.3.3 数据库级别

可以在创建和修改数据库的时候指定该数据库的字符集和比较规则：

```sql
CREATE DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];

ALTER DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];
```

例如创建一个名为`charset_demo_db`的数据库，指定使用`gb2312`字符集，比较规则为`gb2312_chinese_ci`：

```sql

mysql> create database charset_demo_db
    -> character set gb2312
    -> collate gb2312_chinese_ci;
```

如果想查看数据库级别的字符集和比较规则，首先需要使用`use`选择想查看的数据库，然后用`show variables like 'xx';`查看「系统变量」：

-   `character_set_database`：当前数据库的字符集
-   `collation_database`：当前数据库的比较规则



>   需要注意的是，这两个系统变量是只读的，想修改这两个系统变量需要使用`alter`语句。



#### 3.3.4 表级别

同样，可以在创建和修改表的时候指定表的字符集和比较规则：

```sql
CREATE TABLE 表名 (列的信息)
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]]

ALTER TABLE 表名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]
```

例如创建一个名为`t`的表，并指定字符集和比较规则：

```sql
mysql> CREATE TABLE t(
    ->     col VARCHAR(10)
    -> ) CHARACTER SET utf8 COLLATE utf8_general_ci;
Query OK, 0 rows affected (0.03 sec)
```

如果创建表的语句中没有指明字符集和比较规则，那么就采用该表所在的数据库的字符集和比较规则作为该表的字符集和比较规则。



#### 3.3.5 列级别

对于存储「字符串」的列，同一个表中不同的列也可以有不同的字符集和比较规则。

创建/修改某一个列的字符集和比较规则的语法：

```sql
CREATE TABLE 表名(
    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
    其他列...
);

ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
```



>   Tips:
>
>   在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的话就会出错，因为ascii字符集并不能表示汉字字符。



#### 3.3.6 仅修改字符集或仅修改比较规则

如果只修改其中一个，规则如下：

-   只修改字符集，则比较规则变为修改后的字符集默认的比较规则
-   只修改比较规则，则字符集将变为比较规则对应的字符集

不论哪个级别的字符集和比较规则，这两条规则都适用。



### 3.4 字符集的应用

#### 3.4.1 客户端和服务器通信中的字符集

字符串在计算机上的体现是「字节串」，如果使用不同的字符集去解码这个字节串，也会有不同的结果。服务器向客户端返回的结果（字符串）**不是使用一种字符集的编码方式一条道走到黑的**，从发送请求到返回结果的过程中发生了多次字符集的转换。这个过程使用了三个系统变量：

-   `character_set_client`：服务器解码请求时使用的字符集
-   `character_set_connection`：服务器处理请求时会把字符串从`character_set_client`转为`character_set_connection`
-   `character_set_results`：服务器向客户端返回数据时使用的字符集



一般情况下，客户端使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一样：

-   类`Unix`使用`utf8`
-   `Windows`使用`gbk`



一般把这上个系统变量设置为相同的字符集，`MySQL`提供了：

```sql
set names 字符集名;
```

等价于：

```sql
SET character_set_client = 字符集名;
SET character_set_connection = 字符集名;
SET character_set_results = 字符集名;
```



## 4. InnoDB的记录结构

真实数据存放在不同存储引擎的存储格式是不同的，有的存储引擎例如`Memory`都不用磁盘来存储数据，关闭服务器后表中的数据就消失了。

`InnoDB`是`MySQL`默认的存储引擎。

### 4.1 InnoDB页简介

`InnoDB`是一个将表中数据存储到磁盘上的存储引擎，所以即使关机数据还是存在。真正处理数据的过程是发生在内存中，所以需要把磁盘中的数据「加载」到内存中，如果是处理「写入」或「修改」的请求，还需要把内存中的内容刷新到磁盘上，当时读写磁盘的速度相比于读写内存差了几个数量级。

所以`InnoDB`不会把记录一条一条从磁盘上读取出来，而是把数据划分为若干「**页**」，以「页」作为磁盘和内存交互的基本单位，`InnoDB`中「页」的大小一般为`16KB`，也就是每次最少从磁盘读取`16KB`的内容到内存中，一次最少把内存中`16KB`的内容刷新到磁盘中。



### 4.2 InnoDB行格式

我们平时是以「记录」为单位向表中插入数据，这些记录在磁盘上的存放方式被称为`行格式`或`记录格式`。InnoDB有4中不同的`行格式`：

-   Compact
-   Redundant
-   Dynamic
-   Compressed

#### 4.2.1 指定行格式

语法：

```sql
create table 表名 (列的信息) row_format=行格式名称
alter table 表名 row_format=行格式名称
```

**例1**

创建一个表，字符集为`ascii`，所以不能插入汉字，「行格式」为`Compact`，同时插入两条记录：

```sql
use innodb_demo_db;
create table record_format_demo
(
    c1 varchar(10),
    c2 varchar(10) not null,
    c3 char(10),
    c4 varchar(10)
)charset=ascii row_format = compact;

insert into record_format_demo(c1, c2, c3, c4) values ('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', null, null);
select * from record_format_demo;
```



#### 4.2.2 Compact行格式

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e8fafc21aa~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image)

-   一条完整的记录被分为：「记录的额外信息」和「记录的真实数据」两个部分



##### 记录的额外信息

这部分信息是服务器为了描述这条记录而不得不添加的一些额外信息，有「变长字段长度列表」、「NULL值列表」和「记录头信息」。

##### 变长字段长度列表

`MySQL`的`varchar()`,`BLOB`,`TEXT`等数据类型都是变长的，它们被称为「**变长字段**」，在存储真实数据的时候需要把这些数据占用的字节数页存储起来，所以变长字段占用的存储空间分为两部分：

-   真正的数据内容
-   占用的字节数

在`Compact`行格式中，把所有变长字段的真实数据占用的字节长度都放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序「**逆序存放**」。

如果内容占用的字节数比较少，那么用1个字节就可以表示，如果占用的字节数比较多，那么就可能需要2个字节。

如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节。`M`是`varchar(M)`允许最多存放M个字符，`W`是字符集中一个字符最多需要的字节数。

「变长字段长度列表」中只存储值为`非NULL`的列内容占用的长度。值为`NULL`的列不存储。

##### NULL值列表

`Compact`把值为`NULL`的列统一管理，存储到「NULL值列表」中，处理过程如下：

1.   首先统计表中允许存储`NULL`的列有哪些
2.   每个允许存储NULL的列对应一个二进制位，也是按照列的顺序逆序排列。
     -   二进制为1，表示列的值为NULL
     -   二进制为0，表示列的值部位NULL



##### 记录头信息

它是固定的5个字节：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e97718ef01~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.image)

##### 记录真实的数据

除了自己定义的列的数据外，`MySQL`还会为每个记录默认的添加一些「**隐藏列**」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230430163614388.png" alt="image-20230430163614388" style="zoom:50%;" />

>   InnoDB表对主键的生成策略：
>
>   1.   优先使用用户自定义的主键
>   2.   如果没有定义主键，则选一个`Unique`的键作为主键
>   3.   如果没有，则InnoDB会为表添加一个名为`row_id`的隐藏列作为主键。

对于`char(10)`，如果没有填充满10个char，则用空字符代替，也就是`0x20`

#### 4.2.3 Redundant行格式

其他的行格式都是照葫芦画瓢了。`Redundant`是`MySQL5.0`之前的一种行格式，已经非常老了。



#### 4.2.4 行溢出数据

`varchar(M)`类型的列最多可以占用`65535`个字节，其中`M`代表该类型最多存储的字符数量，如果使用`ascii`字符集，一个字符代表一个字节：

```sql
create table varchar_size_demo(
    c varchar(65535)
)charset = ascii row_format = compact ;
```

输出结果：

```sql
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
```

`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不好扩隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节，例如存储一个`varchar(M)`类型的列，需要3部分的存储空间：

-   真实数据
-   真实数据占用字节的长度
-   `NULL`值标识，除非该列是`not null`

所以一个`varchar`类型的列存储的数据长度其实是不到`65535`字节的。所以如果`varchar(M)`类型使用其他字符集，那么`M`的取值是根据「字符集表示一个字符需要的最多字符数」。



#### 4.2.5 记录中数据太多而溢出

```sql
create table varchar_size_demo(
    c varchar(65532)
)charset = ascii row_format = compact ;
insert into innodb_demo_db.varchar_size_demo(c) values (repeat('a', 65532));
```

插入一行数据为「65532个`a`」，也就是65532个字节，一个「页」放不下。

在`Compact`和`Redundant`行格式中，对于占用存储空间非常大的列，在「记录的真实数据」处只会存储该列的一部分数据，把剩余的数据分散存储几个其他的页中，然后「记录的真实数据」处用20个字节指向这些页的地址：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/12/169710e9aab47ea5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

除了`varchar(M)`类型的列，`TEXT`,`BLOB`类型的列在存储数据非常多的时候也会发生「**行溢出**」。



#### 4.2.6 Dynamic和Compressed行格式



MySQL5.7的默认行格式就是`Dynamic`。

`Dynamic`和`Compressed`行格式和`Compact`想死，但是在处理「行溢出」时，它们不会记录真实数据的前多少个字节，而是把所有的字节都存储到其他页面中，只在「记录的真实数据」处存储「其他页面的地址」。

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。



## 5. InnoDB数据页结构

### 5.1 不同类型的页

「**页**」是InnoDB管理存储空间的基本单位，一个页的大小一般是`16KB`。InnoDB设计了许多不同类型的页，比如「存放表空间头部信息的页」，「存放`Insert Buffer`的页」，「存放`INODE`信息的页」，「存放`undo`日志信息的页」。还有核心的：「**索引页**」(Index page)。索引也是数据，可以暂时称为「数据页」。



### 5.2 数据页结构的快速浏览

`16`KB的数据页被划分为：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/17/16f13ee1e2dfac7c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom:50%;" />

| 名称               | 中文名             | 占用空间 | 描述                   |
| ------------------ | ------------------ | -------- | ---------------------- |
| File Header        | 文件头部           | 38字节   | 页的一些通用信息       |
| Page Header        | 页面头部           | 56字节   | 数据页专有的一些信息   |
| Infimum + Supremum | 最小记录和最大记录 | 26字节   | 两个虚拟的行记录       |
| User Records       | 用户记录           | 不确定   | 实际存储的行记录内容   |
| Free Space         | 空闲空间           | 不确定   | 页中没有被使用的空间   |
| Page Directory     | 页面目录           | 不确定   | 页中某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8字节    | 检验页是否完整         |

### 5.3 记录在页中的存储

每插入一条记录，都会从`Free Space`部分，申请一个记录大小划分到`User Records`部分，当`Free Space`为空，就意味着这个页使用完了。



#### 5.3.1 记录头信息

```sql
create table page_demo(
    c1 int,
    c2 int,
    c3 varchar(10000),
    primary key (c1)
)charset = ascii row_format = compact

```

创建一个字符集为`ascii`，行格式为`compact`的表。这个表中记录的行格式如图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c0feca77be3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

`记录头信息`非常重要：

| 名称           | 大小（单位：bit） | 描述                                                         |
| -------------- | ----------------- | ------------------------------------------------------------ |
| 预留位1        | 1                 | 没有使用                                                     |
| 预留位2        | 1                 | 没有使用                                                     |
| `delete_mask`  | 1                 | 标记该记录是否被删除                                         |
| `min_rec_mask` | 1                 | B+树的每层非叶子结点中的最小记录都会添加该标记               |
| `n_owned`      | 4                 | 表示当前记录拥有的记录数                                     |
| `heap_no`      | 13                | 表示当前记录在记录堆的位置                                   |
| `record_type`  | 3                 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录 |
| `next_record`  | 16                | 表示下一条记录的相对位置                                     |



插入几条记录：

```sql
insert into page_demo values (1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
```

有：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c0ff83f9870~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

这些记录是连续的。

-   `delete_mask`

    为1代表被删除了（逻辑删除）。之后所有被删掉的记录都会组成一个所谓「垃圾链表」。这些记录的存储空间可以被覆盖掉。

-   `min_rec_mask`

    每一层的非叶子结点中的最小记录都会添加这个标记。

-   `n_owned`，暂时跳过

-   `heap_no`

    这个**属性**表示当前记录在本页中的位置，InnoDB会自动给每个页添加两个记录，被称为「伪记录」或「虚拟记录」，这两个记录一个代表「最大记录」，一个代表「最小记录」。这两个记录被存放在`Infimum + Supremum`的部分。

    所以用户插入的记录从`2`开始，2、3、4、5。。。这样排序。对于一条完整的记录来说，比较记录大小比较的是`主键`的大小。

-   `record_type`

    表示当前记录的真实数据到下一条记录的真实数据的地址偏移量。这其实是一个「链表」，「下一条」记录不是插入的顺序，而是按照「主键」从小到大排序的下一条记录。

    「链表」的头尾分别是「最小记录」和「最大记录」

    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c1084c440b4~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)
    
    删除一条元素就是把`delete_mask`置为1，同时移动链表的指针。如果要添加记录，直接复用空间就行，不需要重新分配空间。



### 5.4 Page Directory（页目录）

「页」中维护了一个按照主键值从小到大串成的一个单链表。此时我们如果想根据主键值查找页中的某条记录，例如：

```sql
select * from page_demo where c1 = 3;
```

单链表的查询时间复杂度为`O(n)`，肯定不能顺序查找。

InnoDB为「记录」设计了一个类似目录的结构，做法如下：

1.   将所有正常的未被删除的记录（包括最大和最小的记录）划分为几个组。
2.   每个组的最后一条记录（也就是组内最大的一条记录）的「头信息」中的`n_owned`属性表示该记录「该组内共有几条记录」。
3.   将每个组的最后一条记录的地址偏移量单独提出出来，按顺序存储到靠近「页」的尾部的地方，这个地方就是`Page Directory`，也就是「页目录」。「页目录」这些地址偏移量被称为「slot」（槽）。

例如`page_demo`表中正常的记录共有六条，InnoDB把他们分为两组，第一组只有「最小记录」，第二组是其余的5条记录：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10c57164a6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

-   `槽1`中的值是112，代表最大记录的地址偏移量（也就是从页面的「0字节」处开始+112字节就是最大记录的地址），`槽0`中的值是99，代表最小记录的地址偏移量。
-   最小记录的`n_owned`值为1，代表以最小记录结尾的这个分组中只有1条记录
-   最大记录的`n_owned`值为5，代表以最大记录结尾的这个分组中有5条记录，包括最大记录本身还有4条记录。



单纯从逻辑上看，这些记录和页目录之间的关系：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/8/16a95c10f2e61ad5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

每个分组中的记录条数是有规定的：<u>对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数在1～8条之间，剩下的分组中记录的条数只能在4～8条之间。</u>所以分组按照下面的步骤进行：

-   初始情况下，一个数据页中只有最小记录和最大记录两条记录，它们属于两个分组
-   之后每插入一个记录，都会从`页目录`中找到「主键值比本记录的主键值大」并且「差值最小」的槽，然后把该槽对应记录的`n_owned`值加一，直到该组中的记录数等于8个。
-   在一个组的记录数「等于8个」后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个组中5条记录。并且会在`页目录`中新增加一个`槽`来记录这个新增分组中「最大的那条记录的偏移量」。



### 5.5 Page Header（页面头部）

这部分占用固定的56个字节，用来存储「**各种状态信息**」：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230501150205516.png" alt="image-20230501150205516" style="zoom:50%;" />

-   从`PAGE_N_DIR_SLOTS`到`PAGE_LAST_INSERT`都是字面意思

-   `PAGE_DIRECTION`：记录插入的方向

    假如一条新插入的记录的主键值比上一条记录的主键值大，则称「这条记录的插入方向是**右边**」，反之则是**左边**。

-   `PAGE_N_DIRECTION`：一个方向连续插入的记录数量

    假设连续几条插入新纪录的方向是一致的，InnoDB会把沿着同一个方向插入的条数记录起来。如果有一条记录的插入改变了方向，这个值就会被清零。



### 5.6 File Header（文件头部）

`Page Header`是专门针对「**数据页**」记录各种状态信息。而`File Header`针对「各种类型的页」都通用。不管什么类型的页，都会以`File Header`作为第一个组成部分。这个部分占用固定38字节：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230501151745239.png" alt="image-20230501151745239" style="zoom:50%;" />

-   `FIL_PAGE_OFFSET`：

    页号，InnoDB通过「页号」定位唯一一个「页」。

-   `FIL_PAGE_TYPE`：代表当前「页」的类型，之前说的都是「数据页」（也叫`索引页`），还有很多种「页」：

    <img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230501152002047.png" alt="image-20230501152002047" style="zoom:50%;" />

-   `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

    InnoDB以「页」为单位存放数据，如果数据非常大，可能需要很多页，那么这些页不一定是连续的，所以InnoDB设计了类似于「双链表」的结构来连接这些页。

    并非所有类型的页都有「上一页」和「下一页」属性，但是`数据页`是有这两个属性的。



### 5.6 File Trailer（文件尾）

为了检测一个页是否完整，每个页都有「文件尾」部分，这部分由8个字节组成，可以分成两个部分：

-   前四个字节：代表页的校验和

    这部分和`File Header`中的校验和对应。如果修改一个页，会先修改「文件头」的校验和，写完后再写「文件尾」的校验和，二者如果不同就代表同步的过程中出错了。

-   后四个字节：代表页面被最后修改时对应的日志序列位置（LSN）

    也是为了检验页的完整性。

>   File Trailer 和 File Header 都是所有类型的页通用的。



## 6. B+树索引

### 6.1 没有索引的查找

先看：

搜索条件为对某个列精确匹配的情况，所谓「精确匹配」，就是搜索条件中用`=`连接起的表达式：

```sql
select [列名列表] from 表名 where 列名 = xxx;
```

#### 6.1.1 在一个页中查找

**以主键为搜索条件：**

可以在「页目录」中使用二分法快速定位到「槽」，然后遍历槽对应分组中的记录就可以**快速找到**指定的记录。

**以其他列为搜索条件**

数据页中没有对非主键列建立所谓「页目录」，此时只能顺序遍历单链表。这种查找的效率**十分低下**。



#### 6.1.2 在很多页中查找

其实**大部分情况下**，表中存储的记录是很多的，需要很多数据页来存储这些记录。在很多页中查找记录分为：

1.   定位到记录所在的页
2.   从所在的页中查找相应的记录

**由于不能快速定位到记录所在的页**，所以只能从第一个页沿着双向链表一直找，对于每个页都采用`6.1.1`的查找方法。这种方法**超级耗时**，所以就有了「**索引**」。



### 6.2 引入索引之前

新建一个表：

```sql
create table index_demo(
    c1 int,
    c2 int,
    c3 char(1),
    primary key (c1)
)row_format = compact;
```

简化的行格式：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd1ba8d05b2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

-   `record_type`：「记录头」信息的一项属性，表示记录的类型，0代表普通记录、2表示最小记录、3表示最大记录
-   `next_record`：下一条记录地址
-   `各个列的值`：共三列：c1、c2、c3
-   `其他信息`：隐藏列的值，记录的额外信息等

把一些记录放到页中：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd1be0d43ce~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

### 6.3 一个简单的索引方案

类似于「定位记录在页中的位置设立一个页目录」，「定位某个记录所在的数据页」也可以建立一个「别的目录」，这个目录需要完成：

-   下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。我们需要通过一些诸如「记录移动」的操作来保证这个状态一直成立。这个过程也被称为「**页分裂**」

-   给所有的页建立一个目录页

    由于数据页的编号不一定连续，例如：

    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd27e1f3cf3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

    由于这些`16KB`的页在物理存储上可能并不挨着，所以每个页对应一个「目录项」，每个「目录项」由两部分组成：

    -   **页的用户记录中最小的主键值，**用`key`来表示
    -   页号，用`page_no`来表示

    ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd282d6b9b9~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**这些目录，又被称为`索引`。**



### 6.4 InnoDB种的索引方案

事实上， 上面方案中的目录项，和「普通的用户记录」差不多，只不过`目录项`中的两个列是「主键」和「页号」而已。所以InnoDB复用了「存储用户记录的数据页」来存储「目录项」。把这些用来表示目录项的记录称为「目录记录项」。

使用「记录头」信息中的`record_type`属性：

-   0，普通的用户记录
-   1，目录项记录
-   2，最小记录
-   3，最大记录

把目录项放到「数据页」中：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd295fd42b5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

上图说明，重新分配了一个编号为`30`的页专门用来存储`目录记录项`，这个页也会为主键生产`Page Directory`。

例如查找主键为20的记录：

1.   先从「存储`目录项记录`的页」，也就是「页30」中二分查找快速找到对应的「目录项」，也就是找到「页9」
2.   从「页9」中二分查找定位到主键为20的用户记录



此时有一个新的问题，如果「页30」不够用了怎么办呢？会继续生成一个更高级的目录，类似于多级目录。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd2a6c7a65f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

这种数据结构被称为「B+树」。

-   存放用户记录的节点叫「叶子结点」
-   其他存放目录项的节点叫「非叶子结点」

一般，使用到的B+树不会超过4层。



#### 6.4.1 聚簇索引

B+树本身就是一个目录，或者是一个索引，有两个特点：

-   使用记录（这是一个名词）「主键值的大小」进行记录（这是一个动词）和「页的排序」，这句话有三个方面的含义：
    -   页内的记录是按照主键的大小顺序排成一个单向链表
    -   每个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表
    -   存放「目录项记录」的页分为不同的层次，每个层次也是根据页中「目录项记录」的主键大小排序成双向链表
-   B+树的叶子结点存储的是完整的用户记录

我们把具有这两种特性的B+树称为「聚簇索引」，所有完整的用户记录都存放在这个「聚簇索引」的叶子结点处。这种「聚簇索引」并不需要我们在`MySQL`语句中显式地使用`index`语句去创建。InnoDB存储引擎会自动为我们创建「聚簇索引」。

另外，在InnoDB中，「聚簇索引」就是数据的存储方式（所有的用户记录都存在了「叶子结点」），也就是所谓的索引即是数据，数据即是索引。



#### 6.4.2 二级索引

「聚簇索引」只在搜索条件是「主键值」时才能发挥作用，因为B+树中的数据都是按照主键进行排序的。

如果想以别的列作为搜索条件，可以多建立几颗B+树，不同的B+树采用不同的排序规则。

这个B+树与「聚簇索引」有几个不同：

-   使用非主键的列进行排序，例如建立`c2`列的索引：
    -   页内的记录按照c2列排序成单向链表
    -   存放记录的页也是根据页中记录的c2列大小排序成一个双向链表
-   B+树的叶子结点存储的不是完整的用户记录，而是`c2列 + 主键`这两个列（为了节省空间）
-   目录项中记录的不是`主键+页号`，而是`c2 + 页号`

**注意到，叶子结点中存储的是`c2列 + 主键`的结构，**所以最后只能找到`主键值`，如果想知道完整的用户记录，还需要到「聚簇索引」中再查找一遍，这个过程也被称为「**回表**」

也就是说，根据非主键查找一个完整的用户记录，需要使用两颗B+树。

这种B+树也被称为「二级索引」，或者「辅助索引」。例如使用`c2列`作为B+树的排序规则，也称这个B+树为c2列建立的索引。



#### 6.4.3 联合索引

还可以同时为多个列的大小作为排序规则，也就是为多个列建立索引。例如想让B+树按照`c2`和`c3`进行排序：

-   如果c2列的值相同，则采用c3列进行排序
-   B+树叶子结点的用户记录由`c2 c2 和 主键c1`三列组成

这种索引本质上也是二级索引。

### 6.5 InnoDB的B+树索引的注意事项

#### 6.5.1 B+树的形成过程

-   每当为某个表创建一个「B+树索引」的时候（聚簇索引是默认创建的），都会为这个索引创建一个`根结点`页面
-   向表中插入「用户记录」，如果`根结点`页面空间不够用，跟结点页面就会分裂（页分裂），`跟结点`便升级为存储「目录项记录」的页。

**一个B+树索引的根结点不会移动，这样需要使用索引的时候，总是从根结点开始查询。**



#### 6.5.2 内结点中目录记录的唯一性

B+树索引的内结点目录项记录的是`索引列+页号`的搭配，但是索引列可能相等，插入的时候会产生不好的后果。所以，对于「二级索引」，采用的是`索引列 + 主键 + 页号`构成，如果c2列相等，则比较主键。

这样可以使的B+树中同一层的不同目录项记录的值是唯一的。



#### 6.5.3 一个页面最少存储2条记录

B+树本质上是一个大的多层级目录，每经过一个目录的时候都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。所以InnoDB的一个「数据页」最少存放两个记录。



### 6.6 MyISAM中索引方案

InnoDB中索引即数据，也就是「聚簇索引」中B+树的叶子结点已经把所有完整的用户记录都包含了。而MyISAM的索引方案虽然也是使用树形结构，但是是把索引和数据分开存储的：

-   将表中的记录按照「插入顺序」单独存储在一个文件中，称为`数据文件`。这个文件并不划分为若干数据页，记录全部存放在这个文件中。我们可以通过行号快速访问到一条记录。所以不能用二分查找
-   `MyISAM`记录也需要记录头信息来存储一些额外的数据。
-   使用`MyISAM`存储引擎会把索引的信息存储到另外一个`索引文件`中，`MyISAM`会为表的主键单独创建一个索引，但是索引的叶子结点存储的是「主键值 + 行号」的组合。也就是先查找主键，再查找行号。所以`MyISAM`中建立的索引全部是`二级索引`，都需要`回表`。
-   也可以在`MyISAM`中建立其他列的索引和联合索引。



### 6.7 MySQL中创建和删除索引的语句

`InnoDB`和`MyISAM`会自动为「主键」或者「声明为`unique`的列」去自动建立B+树索引。其余的列建立索引需要使用语法：

```sql
CREATE TALBE 表名 (
    各种列的信息 ··· , 
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)
```

`key`和`index`是同义词，两个单词是一样的。

也可以使用`alter`语句建立索引：

```sql
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```

删除索引：

```sql
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
```

例如：

```sql
create table index_demo_2(
    c1 int,
    c2 int,
    c3 char(1),
    primary key (c1),
    index idx_c2_c3(c2, c3)
);
```

建议索引名使用`idx_`为前缀，多个列名之间用`_`下划线分割开。

删除索引：

```sql
alter table index_demo_2 drop index idx_c2_c3;
```



## 7. B+树索引的使用



### 7.1 索引的代价

B+树索引，在时间和空间上都有代价：

-   空间上的代价

    每建立一个索引都要建立一颗B+树，每一颗B+树的每一个节点都是一个数据页，每个页默认`16KB`

-   时间上的代价

    每次对表中的数据进行「增、删、改」操作的时候，都要去修改B+树的索引。会产生「页面分裂、页面回收」等操作。时间上的代价主要指的是「维护B+树」的代价。

一个表上的索引建立的越多，就会占用越多的存储空间，在「增删改」记录的时候性能就越差。

所以建立索引需要：<u>又少又好。</u>



### 7.2 使用索引进行匹配

>   所有对索引发挥最大能效的技巧都来自于 对B+树索引本质的了解。

先建立一个表，用来存储人的一些信息：

```sql
create table person_info(
    id int not null auto_increment,
    name varchar(100) not null,
    birthday date not null,
    phone_number char(11) not null ,
    country varchar(100) not null,
    primary key (id),
    key idx_name_birthday_phone_number (name, birthday, phone_number)
); 
```

-   建立一个`person_info`表，主键是`id`自动递增，InnoDB 自动为id列建立「聚簇索引」
-   额外定义一个二级索引`idx_name_birthday_phone_number`，这是三个列组成的联合索引。所以这个索引对应的叶子结点只会保留着三个列外加「主键」，不会保存`country`列。这个二级索引按照`name, birthday, phone_number`排序。



#### 7.2.1 全值匹配

如果我们的搜索条件中的列和索引列一致的话，这种情况就称为「全值匹配」，例如：

```sql
select * from person_info where name = 'Ashburn' and birthday = '1990-09-27' and phone_number = '15123983239';
```

这个`select`和`idx_name_birthday_phone_number`索引包含的三个列一样，所以可以使用索引。

`where`子句中的几个搜索条件对查询结果没有影响，也就是说调换`name`,`birthday`,`phone_number`的搜索顺序对「查询的执行过程」没有影响。`MySQL`有「查询优化器」。



#### 7.2.2 匹配左边的列

在搜索语句中，也可以不用包含「联合索引」全部的列，只需要包含**左边**的就行，例如：

```sql
select * from person_info where name = 'Ashburn';
select * from person_info where name = 'Ashburn' and birthday = '1990-07-20';
```

也可以使用`idx_name_birthday_phone_number`联合索引。

但是下面的语句无法使用这个联合索引：

```sql
select * from person_info where birthday = '1990-07-20';
```

下面的语句只能使用`name`列的索引：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```



#### 7.2.3 匹配列前缀

>   为某个列建立索引的意思其实就是在对应的B+树的记录中使用该列的值进行排序。

例如想查询名字以`'As'`开头的记录，可以写：

```sql
select * from person_info where name like 'As%';
```

这样也可以用到`name`的索引，但是下面的索引不行：

```sql
select * from person_info where name like '%As%';
```



**一个例子：**

假如某个表中有一列`url`，用来存储网站，如果我们想查询`com`为后缀的网站，可以写：

```sql
where url like '%.com';
```

但是这样无法使用`url`列的索引，为了在查询时使用到这个索引但不全表扫描，我们可以把「后缀查询」改为「前缀查询」，不过需要我们把表中的数据全部「逆序存储」，那么`url`列中的数据如下：

```txt
+----------------+
| url            |
+----------------+
| moc.udiab.www  |
| moc.elgoog.www |
| nc.vog.www     |
| ...            |
| gro.otw.www    |
+----------------+
```

这样再搜索以`com`为后缀的网址，可以使用：

```sql
where url like 'moc%';
```



#### 7.2.4 匹配范围值

由于所有记录都是按照索引列的值从小到大排序的，所以很方便查询「索引列」的值在「某个范围内」的记录，例如：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

查询过程如下：

-   通过B+树在叶子结点中找到第一条`name`值大于`'Asa'`的索引记录，获得该记录的主键，然后回表获得「聚簇索引」记录
-   沿着记录所在的链表向后寻找（同一页面中的记录使用单向链表连接，数据页之间用双向链表连接起来）下一条二级索引记录一直寻找，符合就回表，直到不符合`name < 'Barlow'`为止

但是只有对索引最左边的列进行范围查找的时候才能使用B+树索引。



#### 7.2.5 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，多个列都进行范围查找时，只能用到最左边的索引列，但是如果**左边的列**是精确查找，则右边的列可以进行范围查找，例如：

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

name精确查找，查找的结果按照birthday排序，所以birthday可以使用索引，但是phone_number不行。

### 7.3 使用索引进行排序





#### 7.3.1 用于排序

`select`语句经常需要通过`order by`子句按照某种规则进行排序。

一般情况下，我们只能把记录都加载到内存中，然后再排序，如果记录太多，不能在内存中排序，还需要借助「磁盘的空间」来存放「中间结果」。在`MySQL`中，把这种在内存中或磁盘上进行排序的方式统称为「文件排序」（filesort），这些操作非常慢，因为涉及到了文件。

但是如果`order by`子句中使用到了「索引列」就有可能省去在内存或文件中排序的步骤，例如：

```sql
select * from person_info order by name, birthday, phone_number limit 10;
```

这个查询的结构按照`name, birthday, phone_number`依次排序。正好和之前建立的`idx_name_birthday_phone_number`二级索引相同。所以可以直接从索引中提取前10个数据，然后进行「回表」操作「提取出该索引中不包含的列」就好了。



#### 7.3.2 使用联合索引进行排序注意事项

使用「联合索引」，`order by`子句中的列也必须按照索引列的顺序给出，例如如果使用`RDER BY phone_number, birthday, name`就不能使用B+树索引。

下面的`order by`子句可以使用索引：

```sql
SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
```

因为如果name相同，是按照birthday和phone_number进行排序。

>   因为order by子句是按照后面给定的顺序进行排序的。



#### 7.3.3 索引失效：ASC、DESC混用

对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，要么都是`ASC`，要么都是`DESC`。

>   Tips:
>
>   order by子句后的列默认是升序

例如，如果是下面的情况：

```sql
ORDER BY name, birthday LIMIT 10
ORDER BY name DESC, birthday DESC LIMIT 10
```

-   前者直接从左边读10条就行了
-   后者直接从最右边开始读10行记录就行

但是，如果我们查询的需求是先按照`name`列进行升序排列，再按照`birthday`列进行降序排列，例如：

```sql
select * from person_info order by name, birthday desc limit 10;
```

如果使用索引，过程如下：

-   先从索引的最左边确定`name`列最小的值，然后找到所有`name`列等于「该值」的所有记录，然后从`name`列等于「该值」的最右边的记录开始向左找10条记录。
-   如果`name`列等于最小的值不满10条，则继续找`name`「次小」的记录，重复上面的过程，知道满足10条

这样的效率可能还不如「文件效率」快，所以MySQL的设计者规定：

-   如果使用联合索引，各个排序列的排序顺序必须一致。



#### 7.3.4 索引失效：排序列包含非同一个索引的列

如果用来排序的多个列不是一个索引里的，也无法使用索引进行排序。



#### 7.3.5 索引失效：排序列使用了复杂的表达式

要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是经过修饰的形式，比如：

```sql
select * from person_info order by upper(name) 10;
```

使用`upper()`函数修饰过的列就不是单独的列了，不能使用索引进行排序。



### 7.4 使用索引进行分组

有时为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组，例如下面这个「分组查询」：

```sql
select name, birthday, phone_number, count(*) from person_info group by name, birthday, phone_number;
```

这个查询语句相当于做了3次分组操作：

1.   先把记录按照`name`值进行分组，所有`name`值相同的记录划分为一组。
2.   将每个`name`值相同的分组里的记录再按照`birthday`的值进行分组，将`birthday`值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又划分了好多小分组。
3.   再将上一步中产生的小分组按照`phone_number`继续分组，形成「小小分组」。

然后针对「小小分组」进行统计，如果分组顺序和B+树中索引列的顺序一致，则可以直接使用B+树进行分组。

分组和排序的情况下使用索引的规则类似。



### 7.5 回表的代价

例如下面这个查询：

```sql
select * from person_info where name > 'Asa' and name < 'Barlow';
```

在使用`idx_name_birthday_phone_number`索引进行查询的时候大致分为：

1.   从索引`idx_name_birthday_phone_number`对应的B+树中取出值在`'Asa'`到`'Barlow'`之间的用户记录。这些记录是连续的，所以被称为「顺序IO」
2.   但是这个索引对应的B+树只包含`name, birthday, phone_number, id`这四个字段，但是查询的是`*`所有列，所以还需要把上一步获取到的每一条记录的`id`都到「聚簇索引」对应的B+树中找到完整的用户记录，这一步就是「回表」。这些`id`字段并不相连，所以被称为「随机IO」。

一般来说`顺序IO`比`随机IO`要快得多，所以有时候可能还不如直接扫描「聚簇索引」（也就是全表扫描）。所以这个时候「查询优化器」就会工作，它会事先对表中的记录计算一些统计数据，然后利用这些统计数据根据「查询的条件」来计算一下「需要回表的记录数」：

-   需要回表的记录越多，就越倾向于`全表扫描`
-   需要回表的记录越少，就越倾向于`二级索引+回表`

一般情况下，**限制查询**获取较少的记录数会让优化器更倾向于选择使用`二级索引 + 回表`的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;
```

添加`limit 10`的查询容易让优化器采用`二级索引 + 回表`的方式进行查询。



#### 7.5.1 覆盖索引

为了彻底告别`回表`操作带来的性能损耗，建议：**最好在查询列表中只包含索引列，**例如：

```sql
SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

这三个列都在`idx_name_birthday_phone_number`索引中，这要就不用`回表`了。我们把这种只需要用到索引的查询方式称为「**索引覆盖**」。排序操作也优先使用「索引覆盖」的方式进行查询。

所以很不鼓励用`*`作为查询列表，最好把需要查询到的列依次表明。



### 7.6 如何挑选索引

也就是如何「建立索引」和「编写查询语句」



#### 7.6.1 只为用于搜索、排序或分组的列创建索引

也就是说，只为出现在「`where`子句中的列」、「连接子句中的连接列」，或者出现在「`order by`或`group by`子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了，例如：

```sql
SELECT birthday, country FROM person_name WHERE name = 'Ashburn';
```

这个查询语句，就不要为`birthday`，`country`列建立索引，只为`name`建立索引。



#### 7.6.2 考虑列的基数

「**列的基数**」指的是某一列中不重复数据的个数，例如某个列包含值：

```txt
2, 5, 8, 2, 5, 8, 2, 5, 8
```

虽然有9条记录，但是「列的基数」为3。

在记录行数一定的情况下，列的基数越大，该列中的值越**分散**；列的基数越大，该列中的值越**集中**。

假设某个列的基数为1，所有的记录在该列中的值都一样，建立索引也就没有必要了，如果某个建立了二级索引的列重复值特别多，那么使用这个二级索引查处的记录还需要大量回表，性能损耗很大。

结论：**尽量为列的基数大的列建立索引。**



#### 7.6.3 索引列的类型尽量小

`MySQL`数据列的类型有很多，整数类型就有：`tinyint`,`mediumint`,`int`,`bigint`这么几种，它们占用的存储空间递增。「类型大小」指的是该类型表示数据范围的大小。

能用`int`，就尽量不要用`bigint`，因为：

-   数据类型越小，在查询时比较操作越快
-   数据类型越小，索引占用的存储空间就越小，在一个数据页内就能放下更多的记录，从而减少磁盘IO带来的性能损耗。

这个建议对表的主键来说更加适用。因为所有的索引（聚簇索引和二级索引）都会存储一份记录的主键。如果主键使用更小的数据类型，就意味着节省更多存储空间和更高效的IO。



#### 7.6.4 索引字符串的前缀

当字符串很长的时候，建立这个字符串的索引的B+树中存在下面的问题：

-   B+树索引中的记录需要把该列完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
-   如果B+树索引中索引列存储的字符串很长，字符串比较会占用更多的时间

**在建立二级索引时，只对字符串的前几个字符进行索引，也就是说在二级索引的记录中只保留字符串的前几个字符。**这样查找记录时不能精确定位到记录的位置，但是能定位到「相应前缀」所在的位置，然后根据前缀相同的记录的主键值「回表」查询完整的字符串值，再的对比。这样只在B+树中存储字符串前几个字符的编码，节约空间，减少字符串的比较时间，大致上解决了排序的问题。

例如只对`name`列的前10个字符进行索引：

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);  
```

非常鼓励只索引字符串值的前缀，尤其是在字符串类型比较长的时候。



但是这样对排序有影响，例如：

```sql
select * from person_info order by name limit 10;
```

使用索引列前缀的方式无法支持索引排序，只能用文件排序。



#### 7.6.5 让索引列在比较表达式中单独出现

假设表中有一个整数列`my_col`，我们为这个列建立了索引，下面这两个`where`子句：

-   `where my_col * 2 < 4`
-   `where my_col < 4/2`

虽然语义一样，但是效率不同。第一个语句中，存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于4，所以这种情况下用不到`my_col`列建立的B+树索引。但是第二个语句的`my_col`单独出现，可以直接使用B+树索引。



#### 7.6.6 主键插入顺序

对于InnoDB存储引擎，表中的数据存储在「聚簇索引」的叶子结点中。如果插入的主键忽大忽小，可能会导致页分裂和性能损耗。

建议是：**让主键具有`auto_increment`，让存储引擎自动为表生成主键，而不是手动插入。**



#### 7.6.7 冗余和重复索引

不要为同一个列创建多个索引，例如：

```sql
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10))
);  
```

通过`idx_name_birthday_phone_number`就可以对`name`列进行快速搜索，再创建一个`idx_name`没有什么用。

同时不要为主键定义索引。



### 7.7 总结

1.   B+树再空间上和时间上都有代价，不要随便建立索引
2.   B+树索引适用于：
     1.   全值匹配
     2.   匹配左边的列
     3.   匹配范围值
     4.   精确匹配某一列并范围匹配另外一列
     5.   用于排序
     6.   用于分组
3.   建立索引时需要注意：
     1.   只为搜索、排序、分组的列创建索引
     2.   为列的基数大的列创建索引
     3.   索引列的类型尽量小
     4.   可以只为字符串的前缀建立索引
     5.   只有索引在「比较表达式」中单独出现的时候才能适用索引
     6.   为了尽量避免「聚簇索引」发生页面分裂，建议让主键自增 
     7.   定位并删除表中的重复和冗余索引
     8.   尽量使用「覆盖索引」查询，避免回表操作
