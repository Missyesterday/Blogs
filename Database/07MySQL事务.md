 

# MySQL 事务

## 1. 事务的特性

MyISAM 不支持事务，InnoDB 支持。

ACID：

-   **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束再中间某个环节，事务在执行过程中发生错误，会回滚到事务开始前的状态。
-   **一致性（Consistency)**：事务操作前和操作后，数据满足完整性约束，数据库保持一致的状态。数据库中的数据要符合现实世界中的约束，例如身份证号不能重复，性别只能是男或女，我们说这些数据是符合「一致性」的。
-   **隔离性（Isolation）**：数据库允许多个并发事务对其数据进行读写和修改，隔离性可以防止多个事务并发执行时干扰别的事务。
-   **持久性（Durability）**：事务处理结束后，对数据的修改是永久的。



InnoDB 如何保证事务的这四个特性：

-   原子性：undo log
-   持久性：redo log
-   隔离性：MVCC（多版本并发控制）或 锁机制
-   一致性则是通过「持久性+原子性+隔离性」来保证

## 2. 并行事务的问题

MySQL 服务器允许多个客户端连接，MySQL 会出现同时处理多个事务的情况。

在同时处理多个事务的时候，就有可能出现 脏读、不可重复读、幻读 的问题。

### 2.1 脏读

dirty-read。

**如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。**



### 2.2 不可重复读

non-repeatable read。

**在「一个事务内」多次读取同一个数据，如果前后两次读到的数据不一致的情况，就意味着发生了「不可重复读」现象。**



### 2.3 幻读

phantom read。

**在一个事务内多次查询某个符合查询记录的「记录数量」，如果前后两次查询到的记录数量不一样，则证明发生了「幻读」。**



>   「幻读」强调之前没有获取到的记录，针对 insert 和 delete 操作；而「不可重复读」强调的是前后数据不一致，针对 update 操作。前者使用「表级锁」解决，后者使用「行级锁」解决。



## 3. 事务的隔离级别

### 3.1 SQL 标准

这三个现象的严重性从大到小分别是：脏读、不可重复读、幻读。

SQL标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低：

-   **读未提交**：指一个事务还没有提交，它所做的变更就能被其他事务看到
-   **读已提交**：指一个事务提交之后，它所做的变更才能被其他事务看到
-   **可重复读**：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的「数据」是一致的，MySQL InnoDB 引擎默认的隔离级别就是这个
-   **串行化**：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了多谢冲突，后面的事务必须等待前一个事务执行完成，才能继续执行

这四种隔离级别可能出现的问题如图：



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829001419297.png" alt="image-20230829001419297" style="zoom:50%;" />



### 3.2 InnoDB 的隔离级别

不同数据库厂商对于 SQL 标准中规定的 4 种隔离级别的支持不一样，MySQL 虽然支持 4 种级别，但是和 SQL 规定的 4 种级别有些出入。

InnoDB 存储引擎默认的级别虽然是「可重复度」但是可以很大程度上避免「幻读」现象的产生，解决方案有两种：

-   针对**快照读**（普通select语句），是通过 MVCC 方式解决了「幻读」，因为在可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以能避免「幻读」问题。
-   针对**当前读**（select ... for update等语句），是通过「next-key lock（记录锁+间隙锁」方式解决了幻读，因为当执行`select ... for update`的时候，会加上「next-key lock」，如果有其他事务在「next-key lock」锁范围插入了一条语句，那么这个插入语句就会被阻塞，无法成功插入，所以能避免「幻读」问题。

**举例：**

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829131145154.png" alt="image-20230829131145154" style="zoom:50%;" />

假设账户的余额为 100W，不同的隔离级别下，事务 A 和事务 B 查询到的余额会不同：

-   在「读未提交」隔离级别下，事务 B 修改查询余额后，虽然没有提交事务，但是此时的余额已经可以被「事务 A」看见了，所以 V1、V2、V3 都是 200 万。
-   在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以「事务 A」中的 V1 为 100 万，V2 和 V3 都是 200 万。
-   在「可重复读」隔离级别下，「事务 A」只能看到「启动事务时」的数据，所以 V1 和 V2 都是 100 万，V3 是 200 万。
-   在「串行化」隔离级别下，事务 B 在执行修改余额的时候，由于事务 A 执行了读操作（加了读锁），所以发生了读写冲突，会被锁住，直到事务 A 提交完成后，事务 B 才能继续执行，所以 V1 和 V2 都是 100 万，V3 是 200 万。

这四种隔离级别如何实现：

-   对于「读未提交」隔离级别的事务来说，因为可以直接读到未提交的事务，所以直接读取最新的数据就好了。
-   对于「串行化」隔离级别的事务来说，通过加「读写锁」的方式来避免并行访问。
-   对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过「Read View」来实现的。Read View 可以理解为一个数据快照，它们的区别在于创建 Read View 的时机不同：
    -   「读提交」隔离级别在「每个语句执行前」都会重新生成一个 Read View
    -   「可重复读」隔离级别在「启动事务时」生成一个 Read View，然后整个事务期间都用这个 Read View

## 4. Read View 在 MVCC

MVCC（Multi-Version Concurrency Control），也就是多版本并发控制。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829144548449.png" alt="image-20230829144548449" style="zoom:40%;" />

**Read View 有四个重要的字段：**

-   m_ids：指的是在创建 ReadView 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，「活跃事务」指的是启动了但还没提交的事务。
-   min_trx_id：指的是在创建 ReadView 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是`m_ids`的最小值
-   max_trx_id：并不是 `m_ids`的最大值，而是**创建 ReadView 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大事务的事务 id+1
-   creator_trx_id：指的是**创建该 ReadView 的事务的事务 id**



<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829144854193.png" alt="image-20230829144854193" style="zoom:40%;" />

**聚簇索引记录中的两个隐藏列：**

-   trx_id，当一个事务对某条聚簇索引进行改动时，就会**把该事务的事务 id 记录在 trx_id隐藏列中。**
-   roll_pointer，每次对某条聚簇索引进行改动时，都会把旧版本的记录写入到`undo日志`中，这个隐藏列是一个「指针」，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

在创建 ReadView 后，我们可以将记录中`trx_id`划分为这三种状态：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829145238792.png" alt="image-20230829145238792" style="zoom:40%;" />

当一个事务去访问记录的时候，除了自己的更新记录总是可见外，还有这几种情况：

-   如果记录的`trx_id`小于 ReadView中的`min_trx_id`值，表示这个版本的记录是在创建 ReadView **前** 已经提交的事务生成的，所以该版本的记录对当前事务**可见**
-   如果记录的`trx_id`大于等于 ReadView 中的`max_trx_id`值，表示这个版本的记录是在创建 ReadView **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见。**
-   如果该记录的`trx_id`介于 ReadView 的`min_trx_id`和`max_trx_id`之间，需要判断`trx_id`是否在`m_ids`列表中：
    -   如果该记录的`trx_id`在，证明生成该版本记录的活跃事务还没提交，所以该版本记录对当前事务**不可见**
    -   如果不在，则证明生成该版本记录的事务已经被提交，所以该版本记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**在 MySQL 中，是通过 ReadView 和 记录的隐藏列 实现。



## 5. 可重复读如何工作

**可重复读隔离级别就是启动事务时生成一个 ReadView，然后整个事务期间都用这个 ReadView。**

假设事务 A 和事务 B 先后启动，那么这两个事务创建的 ReadView 如下：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829153455726.png" alt="image-20230829153455726" style="zoom:30%;" />

在可重复读隔离级别下，事务的 ReadView 不会更新。事务 A 和事务 B 按如下顺序执行：

-   B 读取到 100W
-   A 将余额修改为 200W，但是并没有提交事务
-   B 读取余额，仍然是 100W
-   A 提交事务
-   B 读取余额，仍然是 100W

MySQL InnoDB 的默认隔离级别就是「可重复读」

## 6. 读提交如何工作

在读提交隔离级别下，每次读取数据都会生成一个新的 ReadView。

事务 A 提交修改数据：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230829231949074.png" alt="image-20230829231949074" style="zoom:50%;" />

-   B 读取到 100W
-   A 将余额修改为 200W，但没有提交事务
-   B 读取，仍然是 100W
-   A 提交事务，如上图所示，记录的`roll_pointer`被修改
-   B 读取，读取的时候，会更新 ReadView，其中会更新`min_trx_id`，这就意味着这条事务的更新可以被读取到。

正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

