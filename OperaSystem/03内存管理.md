# 3 内存管理

## 3.1 为什么要有虚拟内存

### 3.1.1 虚拟内存

单片机没有操作系统，CPU 操作的是内存的「物理地址」，这种情况下，要在内存中同时运行两个程序几乎不可能，如果两个程序同时操作一块内存，会崩溃。

操作系统为每个进程分配独立的「虚拟内存」，进程不能直接操作物理内存，而「虚拟内存」和「物理内存」的映射，则是操作系统负责的。

CPU 中的「内存管理单元」MMU 负责将虚拟地址转变成物理地址，然后通过物理地址访问内存。

「内存分段」和「内存分页」是两种 建立映射关系的手段。

>   内存分段 VS 内存分页

### 3.1.2 内存分段

>   一般来说，计算机中一个概念有两个实现，前面一个都很简单，属于炮灰，但是「内存分段」很重要。



进程分为多个逻辑段（segmentation），有 代码段、数据段、栈、堆等。「内存分段」机制下，虚拟内存由两个部分组成：「段选择因子」和「段内偏移量」。

<img src="https://cdn.xiaolincoding.com//mysql/other/a9ed979e2ed8414f9828767592aadc21.png" alt="img" style="zoom:50%;" />

-   **段选择因子**保存在段寄存器中，「段选择因子」中最重要的是「段号」，所谓「段号」就是段表的索引。段表中保存的是这个段在物理内存中的「基地址」、「段的界限」和「特权等级」等，每个进程都有段表。
-   **段内偏移量**，就是「段基地址」+「段内偏移量」得到物理内存地址，前提是这个偏移量不能超过段界限。



#### **内存分段的问题：**

-   内存碎片
-   内存交换效率低



#### **内存碎片问题：**

分段的粒度太粗了，一个段可能很大，而且一个虚拟内存段映射到物理内存上也需要连续。

内存碎片在这里可以分为两种：「内部内存碎片」和「外部内存碎片」。内存分段管理可以根据实际需要分配内存，所以前者不会出现。但是每个段的长度不固定，而多个段之间可能不会紧密的排列，所以会产生多个不连续的小物理内存。

解决「外部内存碎片」可以使用「内存交换」，也就是先把一段内存写到硬盘上，然后再读回到内存中（注意这里的「写」和「读」），这样段之间就是紧密排列的。这个「存在于磁盘中的」用于「内存交换」的空间，就是所谓的「Swap 空间」。进行一次「内存交换」，不用多说了，这个肯定很慢，然后用户就觉得「卡」。



### 3.1.3 内存分页

分段的好处就是每个段在物理内存中也是连续的，但是粒度太粗了。所以有了「内存分页」。

「内存分页」就是把虚拟内存和物理内存空间都切成 4KB 的固定大小，这个固定的内存空间，被称为「页（Page）」。虚拟地址和物理地址之间通过「页表」来映射。

「页表」是存储在内存中，MMU 负责将虚拟地址内存转换为物理内存。当进程访问的虚拟地址在页表中查询不到时，系统会产生一个「**缺页异常**」，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

#### **分页解决内存碎片和内存交换效率低：**

<img src="https://cdn.xiaolincoding.com//mysql/other/388a29f45fe947e5a49240e4eff13538-20230309234651917.png" alt="img" style="zoom:50%;" />

**内存分页的内存空间在物理内存和虚拟内存中都是预先划分好的。**所以不会在「页与页之间」产生碎片，每个页都是排列紧密的，所以没有「外部内存碎片」。

但是页是固定的大小，如果进程用不到一页，就会出现「内部内存碎片」。

如果物理内存中空间不够，OS 就会把其他进程中「最近没有被使用」的内存页「换出」（Swap Out）到硬盘上，需要的时候再加载进来，称为「换入」（Swap In）。每次写入磁盘可能就几个页，所以内存交换效率很高。

同时，内存分页机制在加载程序的时候，不需要把程序全部加载到物理内存中，而是先建立映射（先在物理空间中保留空间），然后用到虚拟内存页中的数据时，再加载到物理内存中。



#### 单级页表

**一种简答的实现方法**

与分段机制类似，在分页机制下，虚拟地址也分两个部分：「页号」和「页内偏移」，「页号」是「页表」的索引，「页表」中存储的是「虚拟页号+物理内存的基地址」。

那么将「虚拟内存」转换成「物理内存」，分为三步：

-   把虚拟地址切成「页号」和「偏移量」
-   根据页号，从「页表」中查询对应的「物理基地址」（物理页号）
-   再加上偏移量，得到物理内存的地址

#### 简单分页的缺陷

以 32 位环境为例，虚拟地址空间共有 4GB（$2^{32}$Byte)，一个页大小为 4KB（$2^{12}$），那么就需要 $2^{20}$个页，每个「页表项」需要 4 个字节来存储，也就是一个「页表」需要 $2^{22}$字节，也就是 4MB 的内存来存储页表。



>   1G = $2^{30}$，大约是 10 亿
>
>   1M = $2^{20}$，大约是 100 万
>
>   1K = $2^{10}$，大约是 1000

需要注意的是，每个进程都有自己的虚拟地址空间，每个进程都有「页表」，如果有 100 个进程，就需要 400MB 来存储页表，这显然有点过多了。



#### 多级页表

为了解决上面页表过大的问题，需要采用「多级页表」（Multi-Level Page Table）的方案。

一个页表共有 $2^{20}$ 项，我们把这大约 100万 「页表项」分成$2^{10} \times 2^{10}$，也就是 1024 个「二级页表」，每个「二级页表」有 1024 个页表项，同时建立一个「一级页表」，这样「虚拟地址」就变成了「一级页号+二级页号+偏移量」：



<img src="https://cdn.xiaolincoding.com//mysql/other/19296e249b2240c29f9c52be70f611d5.png" alt="img" style="zoom:40%;" />



虽然多了一个「一级页表」（4KB）大小的内存，而二级页表仍然是 4MB。但是**如果有一个「一级页表」的「页表项」没有被用到，那么不需要创建这个「一级页表项」对应的「二级页表」，在需要时才创建二级页表。**例如，如果只有 20% 的「一级页表项」被用到了，那么页表占用的空间就减少了大约 80%，比单级页表需要的内存少。



**为什么单级页表不能这样「需要时再创建『页表项』呢」？**

因为页表首先要覆盖「全部虚拟地址空间」，而多级页表中的「一级页表」可以覆盖。

>   举个例子，假设采用单级页表，同时单级页表中只存放用过的地址，那么当要查找一个不存在的地址（错误的非法地址），此时 操作系统判断不出来，仍然选择添加到单级页表中。



对于64 位系统，分页变成了四级。



#### TLB

多级页表存在一个问题，那就是从虚拟地址转换到物理有几道转换的工序，会降低地址转换的速度。根据「局部性」，在一段时间内，可能一个程序只会执行某一个部分，而访问的存储空间也局限于某个内存区域内。

利用这个特性，我们可以把最常访问的「几个页表项」存储到访问速度更快的硬件上，CPU 中有一个 TLB（Translation  Lookaside Buffer），也被称为「页表缓存」等。

那么，MMU 在进行地址转换的时候，就会先访问 TLB，如果 TLB 中没有才会查页表。 

TLB 存储的是「虚拟地址的所有页号」和「物理地址基地址」的映射。



### 3.1.4 段页式内存管理

内存分段和内存分页并不是对立的，我们可以组合起来使用：

-   首先将程序划分为大小不一的逻辑段
-   接着把每个段分为固定大小的页。

这样，虚拟地址就由「段号+页号+偏移」组成。

<img src="https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img" style="zoom:50%;" />

## 3.2 malloc

### 3.2.1 Linux 进程的内存分布

在 Linux 操作系统中，虚拟地址空间被分为「内核空间」和「用户空间」。在 32 为地址中，一个进程的虚拟地址空间有 4G，高位的 1G 为内核空间，剩下的 3G 是用户空间：

-   进程在用户态时只能访问用户空间的内存
-   进程在内核态时，才可以访问内核空间的内存

虽然每个进程都有自己独立的虚拟内存，但是**每个虚拟内存中的内核地址，关联的都是相同的物理地址。**所有的「系统资源」的管理都是在内核空间进行的，例如访问磁盘、读取网卡的数据、新建一个线程等等。



<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="虚拟内存空间划分" style="zoom:50%;" />

-   内存的开始区域是保留的，我们认为比较小数值的地址不是一个合法地址
-   代码段：二进制的可执行代码
-   数据段：已初始化的静态常量和全局变量
-   BSS段：未初始化的静态变量和全局变量
-   堆：动态分配的内存，`malloc()`分配
-   文件映射：包括动态库、共享内存等，`mmap()`分配
-   栈：局部变量和函数调用的上下文，大小固定



### 3.2.2 malloc 分配内存

首先，`malloc()`不是系统调用，而是 C库中的函数，用来动态分配内存。**malloc 分配的内存都是虚拟内存。**

在Linux 中，通过`malloc()`分配内存的时候，会有两种方式向操作系统申请堆内存：

-   方式一：通过`brk()`系统调用从「堆」分配内存
-   方式二：通过`mmap()`系统调用从「文件映射区」分配内存

**需要注意的是，通过`malloc()`**分配的内存，会带一个额外的区域，称为`cookie`，`free`就是通过`cookie`从而知道需要这个指针指向的内存区域有多大，因此，`free()`函数传入的只能是`malloc()`或者`cmalloc()`这类函数返回的指针。

<img src="https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" style="zoom:50%;" />

### 3.2.3 `brk()`系统调用

如果用户分配的内存小于 128KB，则通过`brk()`申请内存，如果大于 128KB，则通过`mmap()`申请内存。

<img src="https://cdn.xiaolincoding.com//mysql/other/75edee0cb75450e7987a8a482b975bda.png" alt="图片" style="zoom:50%;" />

-   调用`brk()`就会预分配额外的内存
-   `brk()`从堆空间分配的内存，调用`free()`也不会归还给操作系统，而是存到`malloc()`维护的一个内存池中，内存池中的虚拟内存和物理内存的映射关系还在。
-   后续如果`malloc()`再要内存，先看内存池中有没有，如果没有再分配
-   如果真的需要分配内存了，则 brk 指针向上移动
-   缺点就是会产生内存碎片，而且无法检测，所以需要`mmap()`

>   可以通过 `cat /proc/PID/maps`来查看内存分布，如果有[heap] 标记，则证明是 brk()分配的内存（当然前提是用`malloc()`），如果没有，则是`mmap()`系统调用

### 3.2.4 `mmap()`系统调用

当`malloc()`分配的内存大于 128KB，就会使用`mmap()`系统调用中使用「私有匿名映射」的方式，在文件映射区分配一块内存。

同时`free()`归还的时候，会将`mmap()`分配的内存归还给操作系统，那么这块虚拟内存和物理内存的映射就不在了。如果真的分配了虚拟内存（不是从`brk()`内存池中拿），第一次访问这个虚拟地址的时候，都会产生缺页中断，导致 CPU 消耗较大，同时每次调用都会产生系统调用进入内核态。