# 4 进程管理

## 4.1 进程、线程基础

### 4.1.1 进程



<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系统/进程和线程/8-进程五个状态.jpg" style="zoom:50%;" />

在操作系统中，通常会把阻塞状态的进程的物理内存交换到硬盘，等到需要再换入到物理内存。

### 4.1.2 线程



**线程是进程中的一条执行流程**。

同一个进程中多个线程之间可以共享「代码段」、「数据段」、「打开的文件」，每个线程有自己独立的「寄存器」和「栈」。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg" alt="多线程" style="zoom:50%;" />

**线程的优点：**

-   一个进程中可以同时存在多个线程；
-   线程之间可以并发执行
-   线程之间可以分享地址空间和文件等资源
-   线程创建比进程快，终止也比进程快，因为需要释放的资源更少。
-   线程的切换很快，而进程的切换需要换页表
-   线程之间数据传递更快

**线程的缺点：**

-   进程中的一个线程崩溃时，会导致其所属进程的所有进程崩溃（C/C++是如此，Java 中线程崩溃并不会导致进程崩溃）



>    进程是资源（内存、打开的文件）分配的单位，线程是 CPU调度的单位；进程有一个完整的资源平台，而线程只独享必不可少的资源，线程也有「就绪、阻塞、运行」的状态。



**线程的上下文切换**

所谓操作系统的任务调度，实际上调度的对象是线程，而进程只是提供「虚拟内存」等资源。切换时，如果两个线程属于一个进程，则只需要切换私有数据；如果两个线程不属于同一个进程，则需要切换整个虚拟内存。



### 4.1.3 线程的实现

线程有三种实现方式：

-   用户线程（User Thread）：在用户空间实现线程，不由内核管理，由用户态的「线程库」管理。
-   内核线程（Kernel Thread）：在内核中实现的线程，由内核管理。
-   轻量级线程（LIghtWeight Thread）：在内核中来支持用户线程。（前几天腾讯刚问的我，没回答上。😭）

同时还需要考虑一个问题：用户线程和内核线程的对应关系。

-   多个用户线程对应同一个内核线程
-   一个用户线程对应一个内核线程
-   多个用户线程对应多个内核线程



### 4.1.4 如何理解「用户线程」

用户线程是基于「用户态」的「线程管理库」来实现的，那么**线程控制块（Thread Control Block TCB）**，也是在库里面来实现的，对于操作系统而言是看不到这个 TCB 的，它只能看到整个进程的 PCB。

所以，**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

用户级线程的模型，类似于「多对一」的关系，也就是多个用户线程对应一个用户线程：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230901000437194.png" alt="image-20230901000437194" style="zoom:50%;" />

**用户线程的优点：**

-   每个进程都需要它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程函数来维护，可以用于不支持线程技术的操作系统
-   用户线程的切换也是由线程库函数来完成的，无需用户态和内核态的切换，所以很快

**用户线程的缺点：**

-   由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那该进程所包含的所有的用户线程都会阻塞
-   当一个线程开始运行，除非它主动交出 CPU 的使用权，否则它所在的进程中其他线程无法运行，因为用户太的线程无法打断运行中的线程，只有操作系统才有这个权限，但是用户线程不是操作系统管理的。

### 4.1.5 如何理解「内核线程」

内核线程是由操作系统负责管理的，线程对应的 TCB 也是放在操作系统重，这样线程的创建、终止和管理都是操作系统负责。

内核线程的管理模型，类似于「一对一」的关系，也就是一个用户线程对应一个内核线程，如图：

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230901002626133.png" alt="image-20230901002626133" style="zoom:50%;" />

**内核线程的优点**

-   在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行
-   分配给线程，多线程的进程可以获得更多的 CPU 运行时间

**内核线程的缺点：**

-   在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB
-   线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说开销较大

### 4.1.6 如何理解「轻量级进程」

轻量级进程（Light-Weight Process，LWP）是内核支持的用户线程，一个进程可以有多个 LWP，每个 LWP 和内核线程是一对一的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是内核管理的，并且像普通进程一样被调度。

在大多数系统中，**LWP 和普通进程的区别在于它只有一个最小的执行上下文和调度程序所需的统计信息。**一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程，因为一个执行线程不像进程那样需要那么多状态信息，所以 LWP 也不带有这样的信息。

<img src="https://raw.githubusercontent.com/Missyesterday/picgo/main/picgo/image-20230901003121214.png" alt="image-20230901003121214" style="zoom:33%;" />

在 LWP 之上也可以使用用户线程，那么 LWP 和用户线程的对应关系就有几种：

-   一个 LWP 对应一个用户线程：如上图「进程 4」
    -   优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP
    -   缺点：每一个用户线程，就产生一个内核线程，创建线程的开销比较大
-   一个 LWP 对应多个用户线程，如「进程 2」，线程的管理是在用户空间完成的，此模式中的用户线程对操作系统不可见：
    -   优点：用户线程随便开，上下文切换发生在用户空间，切换的效率高
    -   缺点：一个用户线程阻塞，则整个进程都会阻塞，在多核的 CPU 中，没办法充分利用 CPU
-   多个 LWP 对应多个用户线程，如上图「进程 3」，该模型提供了两级控制，多个用户线程对应多个 LWP，LWP 再一一对应到内核线程：
    -   优点：结合了前两种优点，大部分的线程上下文发生在用户空间，而且多个线程可以充分利用多核CPU 的资源
-   组合模式：如「进程 5」，此进程结合 1:1 模型和 M：N 模型，开发人员可以针对不同的应用特点调节内核线程的数据来达到物理并行性和逻辑并行性。

## 4.2 调度

### 4.1.3 调度时机

### 4.3 死锁

死锁需要同时满足 4 个条件：

-   互斥条件
-   持有并等待条件
-   不可剥夺条件
-   环路等待条件

